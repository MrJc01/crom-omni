# Generated by Omni Compiler

# ===== INLINE: std/core.omni =====
def print_opt(msg, show_ui):

    
    import sys
    # Console output
    sys.stdout.write(str(msg) + '\n')
    sys.stdout.flush()
    
    # UI Output (Tkinter)
    if show_ui:
        try:
            import tkinter as tk
            if not hasattr(sys, 'omni_root') or sys.omni_root is None:
                sys.omni_root = tk.Tk()
                sys.omni_root.title("Omni App Logs")
                sys.omni_root.geometry("600x400")
                sys.omni_root.configure(bg="#1a1a2e")
                
                sys.omni_text = tk.Text(sys.omni_root, bg="#1a1a2e", fg="#0f0", font=("Consolas", 10))
                sys.omni_text.pack(expand=True, fill='both')
                
                # Handle close
                def on_close():
                    sys.omni_root.destroy()
                    sys.omni_root = None
                sys.omni_root.protocol("WM_DELETE_WINDOW", on_close)
    
            if sys.omni_root:
                sys.omni_text.insert(tk.END, str(msg) + "\n")
                sys.omni_text.see(tk.END)
                sys.omni_root.update()
        except Exception as e:
            sys.stderr.write(f"UI Error: {e}\n")
        
def print(msg):
    print_opt(msg, True);
def to_string(n):
    result = ""

    
    result = str(n)
        
    return result
def to_string_f(n):
    result = ""

    
    result = str(n)
        
    return result
def to_string_b(b):
    result = ""

    
    result = 'true' if b else 'false'
        
    return result
# ===== END: std/core.omni =====

# ===== INLINE: std/3d.omni =====
class Scene3D:
    constructor(data = {}) {
        this.handle = data.handle;
    }

class Camera3D:
    constructor(data = {}) {
        this.handle = data.handle;
    }

class Renderer3D:
    constructor(data = {}) {
        this.handle = data.handle;
    }

class Mesh3D:
    constructor(data = {}) {
        this.handle = data.handle;
    }

def ThreeJS_load(callback):

    
            callback()
        
def Scene_create():
    scene = new Scene3D({ handle: 0 })

    
            scene.handle = {'type': 'scene', 'objects': []}
        
    return scene
def Camera_create():
    cam = new Camera3D({ handle: 0 })

    
            cam.handle = {'x': 0, 'y': 0, 'z': 10, 'fov': 75}
        
    return cam
def Renderer_create():
    ren = new Renderer3D({ handle: 0 })

    
            import tkinter as tk
            root = tk.Tk()
            root.title("Omni 3D App")
            root.configure(bg='#1a1a2e')
            canvas = tk.Canvas(root, width=600, height=400, bg='#1a1a2e', highlightthickness=0)
            canvas.pack(fill='both', expand=True)
            ren.handle = {'root': root, 'canvas': canvas, 'width': 600, 'height': 400}
        
    return ren
def AnimationLoop(callback):

    
            import tkinter as tk
            # We need access to the renderer root to schedule loop
            # We can find it via a global hack or assume it's created
            # But for now, we just loop using root.after if we can find the root
            # Or we rely on the user having created a renderer.
            
            # NOTE: We need the callback to run within Tkinter loop
            def loop():
                 callback()
                 # We assume active_tk_root is set by Renderer_create
                 # But here we don't have it scope. 
                 # We'll rely on the renderer logic to drive this, 
                 # OR we impl a global registry in python block
                 pass 
            
            # Hack: The renderer creation sets a global 'omni_tk_root'
            try:
                 global omni_tk_root
                 if 'omni_tk_root' in globals() and omni_tk_root:
                     omni_tk_root.after(16, loop) # kick off
                     # mainloop moved to main or handled by UI_run? 
                     # Usually loop must start before mainloop
                     
                     def _forever():
                         loop()
                         omni_tk_root.after(30, _forever)
                     _forever()
                     
                     omni_tk_root.mainloop() 
            except:
                 pass
        
def Sphere_create(radius, color, scene):
    mesh = new Mesh3D({ handle: 0 })

    
            obj = { 
                'type': 'sphere', 
                'radius': radius, 
                'color': f"#{color:06x}",
                'x': 0.0, 'y': 0.0, 'z': 0.0,
                'rx': 0.0, 'ry': 0.0, 'rz': 0.0
            }
            scene.handle['objects'].append(obj)
            mesh.handle = obj
        
    return mesh
def Cube_create(size, color, scene):
    mesh = new Mesh3D({ handle: 0 })

    
            obj = { 
                'type': 'cube', 
                'size': size, 
                'color': f"#{color:06x}",
                'x': 0.0, 'y': 0.0, 'z': 0.0,
                'rx': 0.0, 'ry': 0.0, 'rz': 0.0
            }
            scene.handle['objects'].append(obj)
            mesh.handle = obj
        
    return mesh
def Mesh_set_position(mesh, x, y, z):

    
            if mesh.handle:
                mesh.handle['x'] = x
                mesh.handle['y'] = y
                mesh.handle['z'] = z
        
def Mesh_set_rotation(mesh, x, y, z):

    
            if mesh.handle:
                mesh.handle['rx'] = x
                mesh.handle['ry'] = y
                mesh.handle['rz'] = z
        
def Camera_set_z(cam, z):

    
            if cam.handle:
                cam.handle['z'] = z
        
def Renderer_render(ren, scene, cam):

    
            # Python Tkinter Wireframe Renderer
            if 'canvas' in ren.handle:
                canvas = ren.handle['canvas']
                canvas.delete('all')
                
                w = ren.handle['width']
                h = ren.handle['height']
                cx = w / 2
                cy = h / 2
                cam_z = cam.handle['z']
                
                import math
                
                for obj in scene.handle['objects']:
                    # 3D Transform
                    x, y, z = obj['x'], obj['y'], obj['z']
                    rx, ry, rz = obj['rx'], obj['ry'], obj['rz']
                    
                    # Simple rotation (around Y axis for demo)
                    # Ideally we'd do full matrix, but this is a toy renderer
                    
                    # Vertices for Cube (size)
                    # Vertices for Sphere (radius) -> we'll draw a circle or simple points
                    
                    rel_z = cam_z - z
                    if rel_z < 0.1: continue
                    scale = 300 / rel_z
                    
                    sx = cx + x * scale
                    sy = cy - y * scale
                    
                    color = obj['color']
                    
                    if obj['type'] == 'sphere':
                        r_screen = obj['radius'] * scale
                        canvas.create_oval(sx-r_screen, sy-r_screen, sx+r_screen, sy+r_screen, outline=color)
                    
                    elif obj['type'] == 'cube':
                        s = obj['size'] / 2
                        points = [
                            (-s,-s,-s), (s,-s,-s), (s,s,-s), (-s,s,-s),
                            (-s,-s,s), (s,-s,s), (s,s,s), (-s,s,s)
                        ]
                        
                        # Rotate points
                        rot_points = []
                        cos_y = math.cos(ry)
                        sin_y = math.sin(ry)
                        cos_x = math.cos(rx)
                        sin_x = math.sin(rx)
                        
                        projected = []
                        
                        for px, py, pz in points:
                            # Rotate Y
                            nx = px * cos_y - pz * sin_y
                            nz = px * sin_y + pz * cos_y
                            
                            # Rotate X
                            ny = py * cos_x - nz * sin_x
                            nz = py * sin_x + nz * cos_x
                            
                            # Translate
                            tx = nx + x
                            ty = ny + y
                            tz = nz + z
                            
                            # Project
                            trz = cam_z - tz
                            if trz > 0.1:
                                pscale = 300 / trz
                                psx = cx + tx * pscale
                                psy = cy - ty * pscale
                                projected.append((psx, psy))
                            else:
                                projected.append(None)
                                
                        # Draw Edges
                        edges = [
                            (0,1), (1,2), (2,3), (3,0), # Front
                            (4,5), (5,6), (6,7), (7,4), # Back
                            (0,4), (1,5), (2,6), (3,7)  # Connecting
                        ]
                        
                        for i, j in edges:
                            p1 = projected[i]
                            p2 = projected[j]
                            if p1 and p2:
                                canvas.create_line(p1[0], p1[1], p2[0], p2[1], fill=color)
        

omni_tk_root = None
def _register_renderer(ren):
    global omni_tk_root
    if 'root' in ren.handle:
        omni_tk_root = ren.handle['root']

def Renderer_init(ren):
    
            _register_renderer(ren)
        
# ===== END: std/3d.omni =====

# ===== INLINE: std/math.omni =====
def abs(n):
    if n < 0:
            return 0 - n
    return n
def min(a, b):
    if a < b:
            return a
    return b
def max(a, b):
    if a > b:
            return a
    return b
def clamp(value, min_val, max_val):
    if value < min_val:
            return min_val
    if value > max_val:
            return max_val
    return value
def sqrt(n):
    result = 0

    
    import math
    result = math.sqrt(n)
        
    return result
def pow(base, exp):
    result = 0

     result = base ** exp 
    return result
def sin(n):
    result = 0

    
    import math
    result = math.sin(n)
        
    return result
def cos(n):
    result = 0

    
    import math
    result = math.cos(n)
        
    return result
def floor(n):
    result = 0

    
    import math
    result = math.floor(n)
        
    return result
def ceil(n):
    result = 0

    
    import math
    result = math.ceil(n)
        
    return result
def random():
    result = 0

    
    import random as rand_mod
    result = rand_mod.random()
        
    return result
def random_int(min_val, max_val):
    result = 0

    
    import random as rand_mod
    result = rand_mod.randint(min_val, max_val)
        
    return result
# ===== END: std/math.omni =====

scene = new Scene3D({ handle: 0 })
camera = new Camera3D({ handle: 0 })
renderer = new Renderer3D({ handle: 0 })
sun = new Mesh3D({ handle: 0 })
earth = new Mesh3D({ handle: 0 })
moon = new Mesh3D({ handle: 0 })
time = 0
def animate():
    ;
    ex = cos(time) * 7
    ez = sin(time) * 7
    Mesh_set_position(earth, ex, 0, ez);
    mx = ex + cos(time * 5) * 1.5
    mz = ez + sin(time * 5) * 1.5
    Mesh_set_position(moon, mx, 0, mz);
    Renderer_render(renderer, scene, camera);
def init():
    ;
    ;
    ;
    Renderer_init(renderer);
    Camera_set_z(camera, 15);
    ;
    ;
    ;
    AnimationLoop(animate);
def main():
    print("Starting Solar System Animation...");
    print("Note: This example is best viewed with --web flag.");
    ThreeJS_load(init);

if __name__ == '__main__':
    main()
    import sys
    if hasattr(sys, 'omni_root') and sys.omni_root:
        print('â„¹ App running. Close window to exit.')
        try:
            sys.omni_root.mainloop()
        except KeyboardInterrupt:
            pass
