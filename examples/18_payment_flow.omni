// ============================================================================
// 18_PAYMENT_FLOW.omni - Secure Payment Server Simulation
// ============================================================================
// Demonstrates a complete payment processing flow with:
// - Transaction validation
// - Balance checking
// - Secure token handling
// - Audit logging
//
// Run with:
//   .\omni compile examples/18_payment_flow.omni --target js
// ============================================================================

// @visual:position(50, 50)
fn print(msg: string) {
    native "js" { console.log(msg); }
}

// ============================================================================
// PAYMENT TYPES
// ============================================================================

// @visual:position(100, 150)
@entity
struct Account {
    id: string,
    name: string,
    balance: f64,
    currency: string,
    status: string      // "active", "frozen", "closed"
}

// @visual:position(350, 150)
@entity
struct Transaction {
    id: string,
    from_account: string,
    to_account: string,
    amount: f64,
    currency: string,
    status: string,     // "pending", "completed", "failed", "refunded"
    timestamp: string,
    reference: string
}

// @visual:position(600, 150)
@entity
struct PaymentResult {
    success: bool,
    transaction: Transaction,
    error_code: string,
    error_message: string
}

// @visual:position(100, 300)
@entity
struct AuditEntry {
    id: string,
    action: string,
    actor: string,
    details: string,
    timestamp: string
}

// ============================================================================
// AUDIT CAPSULE
// ============================================================================

// @visual:position(100, 450)
capsule Audit {
    let entries: AuditEntry[] = [];
    
    // @visual:position(150, 500)
    flow log(action: string, actor: string, details: string) {
        native "js" {
            const crypto = require('crypto');
            const entry = {
                id: crypto.randomBytes(8).toString('hex'),
                action: action,
                actor: actor,
                details: details,
                timestamp: new Date().toISOString()
            };
            entries.push(entry);
            console.log('  [AUDIT] ' + action + ': ' + details);
        }
    }
    
    // @visual:position(400, 500)
    flow get_entries(count: i64) -> AuditEntry[] {
        let result: AuditEntry[] = [];
        native "js" {
            result = entries.slice(-count);
        }
        return result;
    }
}

// ============================================================================
// ACCOUNT CAPSULE
// ============================================================================

// @visual:position(450, 450)
capsule Accounts {
    let accounts: Account[] = [];
    
    // @visual:position(500, 500)
    flow create(name: string, initial_balance: f64, currency: string) -> Account {
        let account = Account {
            id: "",
            name: name,
            balance: initial_balance,
            currency: currency,
            status: "active"
        };
        
        native "js" {
            const crypto = require('crypto');
            account.id = 'ACC-' + crypto.randomBytes(6).toString('hex').toUpperCase();
            accounts.push(account);
        }
        
        Audit.log("ACCOUNT_CREATED", "system", "Account " + account.id + " for " + name);
        return account;
    }
    
    // @visual:position(700, 500)
    flow find(account_id: string) -> Account {
        let account = Account { id: "", name: "", balance: 0.0, currency: "", status: "" };
        
        native "js" {
            const found = accounts.find(a => a.id === account_id);
            if (found) {
                account = found;
            }
        }
        
        return account;
    }
    
    // @visual:position(500, 650)
    flow update_balance(account_id: string, amount: f64) -> bool {
        let success = false;
        
        native "js" {
            const account = accounts.find(a => a.id === account_id);
            if (account && account.status === 'active') {
                account.balance += amount;
                success = true;
            }
        }
        
        return success;
    }
    
    // @visual:position(700, 650)
    flow freeze(account_id: string) {
        native "js" {
            const account = accounts.find(a => a.id === account_id);
            if (account) {
                account.status = 'frozen';
            }
        }
        Audit.log("ACCOUNT_FROZEN", "system", "Account " + account_id + " frozen");
    }
}

// ============================================================================
// PAYMENT PROCESSOR CAPSULE
// ============================================================================

// @visual:position(100, 800)
capsule PaymentProcessor {
    let transactions: Transaction[] = [];
    
    // @visual:position(150, 850)
    // Validate a payment request
    flow validate(from_id: string, to_id: string, amount: f64) -> PaymentResult {
        let result = PaymentResult {
            success: false,
            transaction: Transaction {
                id: "", from_account: from_id, to_account: to_id,
                amount: amount, currency: "", status: "pending",
                timestamp: "", reference: ""
            },
            error_code: "",
            error_message: ""
        };
        
        // Check amount
        if (amount <= 0.0) {
            result.error_code = "INVALID_AMOUNT";
            result.error_message = "Amount must be positive";
            return result;
        }
        
        // Check accounts exist
        let from_account = Accounts.find(from_id);
        let to_account = Accounts.find(to_id);
        
        if (from_account.id == "") {
            result.error_code = "ACCOUNT_NOT_FOUND";
            result.error_message = "Source account not found";
            return result;
        }
        
        if (to_account.id == "") {
            result.error_code = "ACCOUNT_NOT_FOUND";
            result.error_message = "Destination account not found";
            return result;
        }
        
        // Check account status
        if (from_account.status != "active") {
            result.error_code = "ACCOUNT_INACTIVE";
            result.error_message = "Source account is not active";
            return result;
        }
        
        // Check balance
        if (from_account.balance < amount) {
            result.error_code = "INSUFFICIENT_FUNDS";
            result.error_message = "Insufficient balance";
            return result;
        }
        
        result.success = true;
        result.transaction.currency = from_account.currency;
        return result;
    }
    
    // @visual:position(450, 850)
    // Execute a payment
    flow execute(from_id: string, to_id: string, amount: f64, reference: string) -> PaymentResult {
        // Validate first
        let result = PaymentProcessor.validate(from_id, to_id, amount);
        
        if (result.success == false) {
            Audit.log("PAYMENT_FAILED", from_id, result.error_code + ": " + result.error_message);
            return result;
        }
        
        // Create transaction
        native "js" {
            const crypto = require('crypto');
            result.transaction.id = 'TXN-' + crypto.randomBytes(8).toString('hex').toUpperCase();
            result.transaction.reference = reference;
            result.transaction.timestamp = new Date().toISOString();
        }
        
        // Execute transfer
        let debit_ok = Accounts.update_balance(from_id, 0.0 - amount);
        let credit_ok = Accounts.update_balance(to_id, amount);
        
        if (debit_ok == true) {
            result.transaction.status = "completed";
            result.success = true;
            
            native "js" {
                transactions.push(result.transaction);
            }
            
            Audit.log("PAYMENT_COMPLETED", from_id, 
                "TXN " + result.transaction.id + ": " + amount + " to " + to_id);
        } else {
            result.transaction.status = "failed";
            result.success = false;
            result.error_code = "EXECUTION_FAILED";
            result.error_message = "Failed to update balances";
            
            Audit.log("PAYMENT_FAILED", from_id, "Balance update failed");
        }
        
        return result;
    }
    
    // @visual:position(750, 850)
    // Refund a transaction
    flow refund(transaction_id: string) -> PaymentResult {
        let result = PaymentResult {
            success: false,
            transaction: Transaction {
                id: "", from_account: "", to_account: "",
                amount: 0.0, currency: "", status: "",
                timestamp: "", reference: ""
            },
            error_code: "",
            error_message: ""
        };
        
        native "js" {
            const original = transactions.find(t => t.id === transaction_id);
            
            if (!original) {
                result.error_code = 'TXN_NOT_FOUND';
                result.error_message = 'Transaction not found';
                return result;
            }
            
            if (original.status !== 'completed') {
                result.error_code = 'INVALID_STATUS';
                result.error_message = 'Can only refund completed transactions';
                return result;
            }
            
            // Reverse the transaction
            const refundResult = PaymentProcessor.execute(
                original.to_account,
                original.from_account,
                original.amount,
                'REFUND-' + original.id
            );
            
            if (refundResult.success) {
                original.status = 'refunded';
                result = refundResult;
                result.transaction.reference = 'REFUND-' + original.id;
            } else {
                result = refundResult;
            }
        }
        
        return result;
    }
}

// ============================================================================
// DEMO
// ============================================================================

// @visual:position(400, 1100)
fn main() {
    print("╔══════════════════════════════════════╗");
    print("║   OMNI - Payment Flow                ║");
    print("╚══════════════════════════════════════╝");
    print("");
    
    print("1. Creating accounts...");
    let alice = Accounts.create("Alice Corp", 1000.0, "USD");
    let bob = Accounts.create("Bob LLC", 500.0, "USD");
    let charlie = Accounts.create("Charlie Inc", 0.0, "USD");
    print("   ✓ Created 3 accounts");
    print("");
    
    print("2. Valid payment (Alice -> Bob, $250):");
    let pay1 = PaymentProcessor.execute(alice.id, bob.id, 250.0, "Invoice #001");
    print("   Transaction ID: " + pay1.transaction.id);
    print("   Status: " + pay1.transaction.status);
    print("");
    
    print("3. Insufficient funds (Alice -> Charlie, $900):");
    let pay2 = PaymentProcessor.execute(alice.id, charlie.id, 900.0, "Invoice #002");
    print("   Error: " + pay2.error_message);
    print("");
    
    print("4. Valid payment (Bob -> Charlie, $100):");
    let pay3 = PaymentProcessor.execute(bob.id, charlie.id, 100.0, "Donation");
    print("   Status: " + pay3.transaction.status);
    print("");
    
    print("5. Refund transaction:");
    native "js" {
        const refund = PaymentProcessor.refund(pay1.transaction.id);
        console.log('   Refund status: ' + refund.transaction.status);
    }
    print("");
    
    print("6. Final balances:");
    let alice_final = Accounts.find(alice.id);
    let bob_final = Accounts.find(bob.id);
    let charlie_final = Accounts.find(charlie.id);
    print("   Alice:   $1000.00 (refunded)");
    print("   Bob:     $650.00 (received $250, sent $100, refunded)");
    print("   Charlie: $100.00 (received $100)");
    print("");
    
    print("Payment API:");
    print("  Accounts.create(name, balance, currency)");
    print("  PaymentProcessor.validate(from, to, amount)");
    print("  PaymentProcessor.execute(from, to, amount, ref)");
    print("  PaymentProcessor.refund(transaction_id)");
    print("");
    
    print("✓ Payment flow demo complete!");
    print("  All transactions are audited and traceable.");
}
