// ============================================================================
// 07_JSON_TRANSFORMER - JSON Operations
// ============================================================================
import "std/core.omni";
import "std/json.omni";

fn json_demo() {
    // In pure Omni we construct JSON string because we don't have Dict map literals yet exposed comfortably
    // Or we use native bridge? No, use std functionality.
    // std/json.omni provides json_parse(string) -> any
    
    // Use concatenation to avoid escaping issues in Lexer
    let q = '"';
    let json_str = "{" + q + "name" + q + ": " + q + "Alice" + q + ", " + q + "age" + q + ": 30}";
    print("   Original JSON String: " + json_str);
    
    let obj = json_parse(json_str);
    let name = json_get(obj, "name");
    // age is number (any), cast/convert if needed? 
    // The current json_get returns 'any' which compiles to dynamic access.
    // Concatenation of 'any' might need explicit casting in typed languages, but here JS/Py handle it.
    // Let's use to_string helper if safe, but 'any' might not be typed i64/string in Omni type checker.
    // Assuming simple usage for now.
    
    print("   Parsed Name: " + name); 
    
    let str = json_stringify(obj);
    print("   Stringified back: " + str);
}

fn main() {
    print("╔══════════════════════════════════════╗");
    print("║   OMNI - JSON Transformer            ║");
    print("╚══════════════════════════════════════╝");
    print("");
    
    print("1. JSON Operations:");
    json_demo();
    print("");
    
    print("2. JSON Features:");
    print("   - Parse strings to objects");
    print("   - Stringify objects to strings");
    print("   - Works on JS and Python");
    print("");
    
    print("✓ JSON transformer example completed!");
}
