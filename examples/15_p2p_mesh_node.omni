// ============================================================================
// 15_P2P_MESH_NODE.omni - Peer-to-Peer Communication
// ============================================================================
// Demonstrates P2P mesh networking concepts: peer discovery, message
// routing, and distributed state synchronization.
//
// This is a conceptual demonstration of the Crom-Nodus P2P architecture.
//
// Run with:
//   .\omni compile examples/15_p2p_mesh_node.omni --target js
// ============================================================================

// @visual:position(50, 50)
fn print(msg: string) {
    native "js" { console.log(msg); }
}

// ============================================================================
// P2P TYPES
// ============================================================================

// @visual:position(100, 150)
@entity
struct Peer {
    id: string,
    address: string,
    port: i64,
    last_seen: string,
    is_connected: bool
}

// @visual:position(350, 150)
@entity
struct Message {
    id: string,
    from_peer: string,
    to_peer: string,        // "*" for broadcast
    message_type: string,   // "ping", "pong", "data", "sync"
    payload: string,
    timestamp: string
}

// @visual:position(600, 150)
@entity
struct NodeState {
    node_id: string,
    peers: Peer[],
    message_queue: Message[],
    data_store: any
}

// ============================================================================
// P2P NODE CAPSULE
// ============================================================================

// @visual:position(100, 400)
capsule P2PNode {
    let state: NodeState = NodeState {
        node_id: "",
        peers: [],
        message_queue: [],
        data_store: 0
    };
    
    let running: bool = false;
    
    // @visual:position(150, 450)
    // Initialize the P2P node
    flow init(port: i64) {
        native "js" {
            const crypto = require('crypto');
            P2PNode.state.node_id = crypto.randomBytes(8).toString('hex');
            P2PNode.state.data_store = {};
            
            console.log('  Node ID: ' + P2PNode.state.node_id);
            console.log('  Listening on port: ' + port);
        }
        
        P2PNode.running = true;
    }
    
    // @visual:position(400, 450)
    // Discover peers (simulated)
    flow discover_peers(seed_addresses: string[]) -> Peer[] {
        let discovered: Peer[] = [];
        
        native "js" {
            const crypto = require('crypto');
            
            for (const addr of seed_addresses) {
                const [host, portStr] = addr.split(':');
                const peer = {
                    id: crypto.randomBytes(8).toString('hex'),
                    address: host,
                    port: parseInt(portStr) || 8080,
                    last_seen: new Date().toISOString(),
                    is_connected: true
                };
                discovered.push(peer);
                P2PNode.state.peers.push(peer);
            }
        }
        
        return discovered;
    }
    
    // @visual:position(650, 450)
    // Connect to a specific peer
    flow connect(address: string, port: i64) -> Peer {
        let peer = Peer {
            id: "",
            address: address,
            port: port,
            last_seen: "",
            is_connected: false
        };
        
        native "js" {
            const crypto = require('crypto');
            
            // Simulate connection handshake
            peer.id = crypto.randomBytes(8).toString('hex');
            peer.last_seen = new Date().toISOString();
            peer.is_connected = true;
            
            P2PNode.state.peers.push(peer);
            
            console.log('  Connected to peer: ' + peer.id);
        }
        
        return peer;
    }
    
    // @visual:position(150, 650)
    // Send message to a peer
    flow send(to_peer_id: string, message_type: string, payload: string) -> Message {
        let msg = Message {
            id: "",
            from_peer: P2PNode.state.node_id,
            to_peer: to_peer_id,
            message_type: message_type,
            payload: payload,
            timestamp: ""
        };
        
        native "js" {
            const crypto = require('crypto');
            msg.id = crypto.randomBytes(4).toString('hex');
            msg.timestamp = new Date().toISOString();
            
            // In real implementation, would use WebSocket/TCP
            console.log('  > Sent [' + message_type + '] to ' + to_peer_id.substring(0, 8) + '...');
        }
        
        return msg;
    }
    
    // @visual:position(400, 650)
    // Broadcast message to all peers
    flow broadcast(message_type: string, payload: string) -> i64 {
        let sent_count: i64 = 0;
        
        native "js" {
            for (const peer of P2PNode.state.peers) {
                if (peer.is_connected) {
                    P2PNode.send(peer.id, message_type, payload);
                    sent_count++;
                }
            }
        }
        
        return sent_count;
    }
    
    // @visual:position(650, 650)
    // Handle incoming message
    flow on_message(msg: Message) {
        native "js" {
            console.log('  < Received [' + msg.message_type + '] from ' + msg.from_peer.substring(0, 8) + '...');
            
            // Handle different message types
            switch (msg.message_type) {
                case 'ping':
                    P2PNode.send(msg.from_peer, 'pong', '');
                    break;
                case 'sync':
                    // Sync data with peer
                    const data = JSON.parse(msg.payload);
                    Object.assign(P2PNode.state.data_store, data);
                    break;
                case 'data':
                    P2PNode.state.message_queue.push(msg);
                    break;
            }
        }
    }
    
    // @visual:position(150, 850)
    // Store data (distributed)
    flow store(key: string, value: any) {
        native "js" {
            P2PNode.state.data_store[key] = value;
            
            // Replicate to peers
            const payload = JSON.stringify({ [key]: value });
            P2PNode.broadcast('sync', payload);
        }
    }
    
    // @visual:position(400, 850)
    // Retrieve data
    flow get(key: string) -> any {
        let value: any = 0;
        
        native "js" {
            value = P2PNode.state.data_store[key];
        }
        
        return value;
    }
    
    // @visual:position(650, 850)
    // Get connected peers count
    flow peer_count() -> i64 {
        let count: i64 = 0;
        
        native "js" {
            count = P2PNode.state.peers.filter(p => p.is_connected).length;
        }
        
        return count;
    }
    
    // @visual:position(400, 1000)
    // Ping all peers (heartbeat)
    flow heartbeat() {
        native "js" {
            console.log('  Heartbeat: pinging ' + P2PNode.state.peers.length + ' peers');
            P2PNode.broadcast('ping', '');
        }
    }
}

// ============================================================================
// DEMO
// ============================================================================

// @visual:position(400, 1200)
fn main() {
    print("╔══════════════════════════════════════╗");
    print("║   OMNI - P2P Mesh Node               ║");
    print("╚══════════════════════════════════════╝");
    print("");
    
    print("1. Initializing P2P Node...");
    P2PNode.init(8080);
    print("   ✓ Node started");
    print("");
    
    print("2. Discovering peers...");
    let seeds: string[] = ["192.168.1.10:8080", "192.168.1.11:8080", "192.168.1.12:8080"];
    let peers = P2PNode.discover_peers(seeds);
    print("   ✓ Found 3 peers");
    print("");
    
    print("3. Connecting to additional peer...");
    let new_peer = P2PNode.connect("10.0.0.5", 8080);
    print("   ✓ Connected (total: 4 peers)");
    print("");
    
    print("4. Sending messages...");
    P2PNode.broadcast("ping", "");
    print("   ✓ Broadcast ping to all peers");
    print("");
    
    print("5. Distributed storage...");
    native "js" {
        P2PNode.store('greeting', 'Hello, Mesh!');
        P2PNode.store('counter', 42);
    }
    print("   ✓ Stored and replicated: greeting, counter");
    print("");
    
    print("6. Heartbeat...");
    P2PNode.heartbeat();
    print("");
    
    print("P2P Node API:");
    print("  P2PNode.init(port)              - Start node");
    print("  P2PNode.discover_peers(seeds)   - Find peers");
    print("  P2PNode.connect(addr, port)     - Connect to peer");
    print("  P2PNode.send(peer, type, data)  - Send message");
    print("  P2PNode.broadcast(type, data)   - Broadcast");
    print("  P2PNode.store(key, value)       - Distributed store");
    print("  P2PNode.get(key)                - Retrieve data");
    print("");
    
    print("✓ P2P mesh node demo complete!");
    print("  This demonstrates the Crom-Nodus P2P architecture.");
}
