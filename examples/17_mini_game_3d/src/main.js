// Generated by Omni Compiler
'use strict';

// ===== INLINE: std/core.omni =====
function print_opt(msg, show_ui) {
    
            console.log(msg);
            if (show_ui && typeof document !== 'undefined') {
                let c = document.getElementById('out');
                if (!c) {
                    c = document.createElement('pre');
                    c.id = 'out';
                    c.style.cssText = 'padding:20px;font-family:monospace;font-size:14px;background:#1a1a2e;color:#0f0;max-width:600px;margin:40px auto;border-radius:8px;';
                    document.body.style.background = '#0f0f23';
                    document.body.appendChild(c);
                }
                c.textContent += msg + '\n';
            }
        

}
function print(msg) {
        print_opt(msg, true);
}
function to_string(n) {
            let result = "";
             result = String(n); 

            return result;
}
function to_string_f(n) {
                let result = "";
                 result = String(n); 

                return result;
}
function to_string_b(b) {
                    let result = "";
                     result = b ? 'true' : 'false'; 

                    return result;
}
// ===== END: std/core.omni =====

// ===== INLINE: std/3d.omni =====
class Scene3D {
    constructor(data = {}) {
        this.handle = data.handle;
    }

}
class Camera3D {
    constructor(data = {}) {
        this.handle = data.handle;
    }

}
class Renderer3D {
    constructor(data = {}) {
        this.handle = data.handle;
    }

}
class Mesh3D {
    constructor(data = {}) {
        this.handle = data.handle;
    }

}
function ThreeJS_load(callback) {
    
            if (typeof document !== 'undefined') {
                if (typeof THREE === 'undefined') {
                     const script = document.createElement('script');
                     script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
                     script.onload = callback;
                     document.head.appendChild(script);
                } else {
                     callback();
                }
            } else {
                // Node.js: Immediate callback
                callback();
            }
        

}
function Scene_create() {
        let scene = new Scene3D({ handle: 0 });
        
                if (typeof THREE !== 'undefined') {
                    scene.handle = new THREE.Scene();
                } else {
                    // Headless / Node.js Scene
                    scene.handle = { type: 'scene', objects: [] };
                }
            

        return scene;
}
function Camera_create() {
            let cam = new Camera3D({ handle: 0 });
            
                    if (typeof THREE !== 'undefined') {
                        cam.handle = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                        cam.handle.position.z = 10;
                    } else {
                        cam.handle = { x: 0, y: 0, z: 10, fov: 75 };
                    }
                

            return cam;
}
function Renderer_create() {
                let ren = new Renderer3D({ handle: 0 });
                
                        if (typeof document !== 'undefined') {
                             if (typeof THREE !== 'undefined') {
                                 const r = new THREE.WebGLRenderer({ antialias: true });
                                 r.setSize(window.innerWidth, window.innerHeight);
                                 document.body.appendChild(r.domElement);
                                 ren.handle = r;
                                 ren.type = 'webgl';
                             }
                        } else {
                            ren.handle = { width: 80, height: 24 }; // Terminal size
                            ren.type = 'ascii';
                            ren.frame_count = 0;
                        }
                    

                return ren;
}
function AnimationLoop(callback) {
                    
                            if (typeof requestAnimationFrame !== 'undefined') {
                                function loop() {
                                    callback();
                                    requestAnimationFrame(loop);
                                }
                                requestAnimationFrame(loop);
                            } else {
                                console.log("Animation loop running in terminal (ASCII)... press Ctrl+C to stop");
                                // Simple interval for Node.js
                                setInterval(callback, 100);
                            }
                        

}
function Sphere_create(radius, color, scene) {
                        let mesh = new Mesh3D({ handle: 0 });
                        
                                // Web Mode
                                if (typeof THREE !== 'undefined' && scene.handle && scene.handle.add) {
                                    const g = new THREE.SphereGeometry(radius, 16, 16); // Lower poly for perf
                                    const m = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
                                    const s = new THREE.Mesh(g, m);
                                    scene.handle.add(s);
                                    mesh.handle = s;
                                } 
                                // Terminal Mode
                                else if (scene.handle && scene.handle.objects) {
                                    let obj = { 
                                        type: 'sphere', 
                                        radius: radius, 
                                        color: color,
                                        x: 0, y: 0, z: 0,
                                        rx: 0, ry: 0, rz: 0 
                                    };
                                    scene.handle.objects.push(obj);
                                    mesh.handle = obj;
                                }
                            

                        return mesh;
}
function Cube_create(size, color, scene) {
                            let mesh = new Mesh3D({ handle: 0 });
                            
                                    // Web Mode
                                    if (typeof THREE !== 'undefined' && scene.handle && scene.handle.add) {
                                        const g = new THREE.BoxGeometry(size, size, size);
                                        const m = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
                                        const s = new THREE.Mesh(g, m);
                                        scene.handle.add(s);
                                        mesh.handle = s;
                                    }
                                    // Terminal Mode
                                    else if (scene.handle && scene.handle.objects) {
                                         let obj = { 
                                            type: 'cube', 
                                            size: size, 
                                            color: color,
                                            x: 0, y: 0, z: 0,
                                            rx: 0, ry: 0, rz: 0 
                                        };
                                        scene.handle.objects.push(obj);
                                        mesh.handle = obj;
                                    }
                                

                            return mesh;
}
function Mesh_set_position(mesh, x, y, z) {
                                
                                        if (mesh.handle) {
                                            if (mesh.handle.position) {
                                                mesh.handle.position.set(x, y, z);
                                            } else {
                                                mesh.handle.x = x;
                                                mesh.handle.y = y;
                                                mesh.handle.z = z;
                                            }
                                        }
                                    

}
function Mesh_set_rotation(mesh, x, y, z) {
                                    
                                            if (mesh.handle) {
                                                if (mesh.handle.rotation) {
                                                    mesh.handle.rotation.set(x, y, z);
                                                } else {
                                                    mesh.handle.rx = x;
                                                    mesh.handle.ry = y;
                                                    mesh.handle.rz = z;
                                                }
                                            }
                                        

}
function Camera_set_z(cam, z) {
                                        
                                                if (cam.handle) {
                                                    if (cam.handle.position) cam.handle.position.z = z;
                                                    else cam.handle.z = z;
                                                }
                                            

}
function Camera_set_position(cam, x, y, z) {
                                            
                                                    if (cam.handle) {
                                                        if (cam.handle.position) {
                                                            cam.handle.position.set(x, y, z);
                                                        } else {
                                                            cam.handle.x = x;
                                                            cam.handle.y = y;
                                                            cam.handle.z = z;
                                                        }
                                                    }
                                                

}
function Renderer_render(ren, scene, cam) {
                                                
                                                        // Web Mode
                                                        if (ren.type === 'webgl') {
                                                             ren.handle.render(scene.handle, cam.handle);
                                                        }
                                                        // ASCII Mode (Terminal)
                                                        else if (ren.type === 'ascii') {
                                                            const w = ren.handle.width;
                                                            const h = ren.handle.height;
                                                            const buffer = new Array(h).fill(' ').map(() => new Array(w).fill(' '));
                                                            
                                                            // Simple projection
                                                            const cx = w / 2;
                                                            const cy = h / 2;
                                                            const cam_z = cam.handle.z;
                                                            
                                                            for (const obj of scene.handle.objects) {
                                                                let x = obj.x; 
                                                                let y = obj.y;
                                                                let z = obj.z;
                                                                
                                                                // Relative to camera
                                                                let rel_z = cam_z - z;
                                                                if (rel_z < 0.1) continue; // Behind camera
                                                                
                                                                let scale = 20 / rel_z; // Perspective factor
                                                                
                                                                let screen_x = Math.floor(cx + x * scale * 2); // *2 for char aspect ratio
                                                                let screen_y = Math.floor(cy - y * scale);
                                                                
                                                                // Draw symbol
                                                                if (screen_x >= 0 && screen_x < w && screen_y >= 0 && screen_y < h) {
                                                                    let char = '*';
                                                                    if (obj.type === 'cube') char = '#';
                                                                    if (obj.type === 'sphere') char = 'O';
                                                                    buffer[screen_y][screen_x] = char;
                                                                }
                                                            }
                                                            
                                                            // Output frame
                                                            console.clear();
                                                            console.log("OMNI 3D ASCII RENDERER");
                                                            console.log(buffer.map(row => row.join('')).join('\n'));
                                                        }
                                                    

}
function Renderer_init(ren) {

}
// ===== END: std/3d.omni =====

// ===== INLINE: std/ui.omni =====
let ui_root_ref = 0;
class WindowConfig {
    constructor(data = {}) {
        this.title = data.title;
        this.width = data.width;
        this.height = data.height;
        this.background = data.background;
    }

}
class Window {
    constructor(data = {}) {
        this.handle = data.handle;
        this.id = data.id;
    }

}
class Button {
    constructor(data = {}) {
        this.handle = data.handle;
        this.id = data.id;
        this.text = data.text;
    }

}
class Label {
    constructor(data = {}) {
        this.handle = data.handle;
        this.id = data.id;
        this.text = data.text;
    }

}
class TextInput {
    constructor(data = {}) {
        this.handle = data.handle;
        this.id = data.id;
    }

}
function Window_create(config) {
    let win = new Window({ handle: 0, id: "main" });
    
            if (typeof document !== 'undefined') {
                const div = document.createElement('div');
                div.style.width = config.width + 'px';
                div.style.height = config.height + 'px';
                div.style.backgroundColor = config.background;
                div.style.position = 'relative';
                div.style.border = '1px solid #ccc';
                div.style.margin = '20px auto';
                div.style.fontFamily = 'sans-serif';
                div.id = 'omni-window-main';
                document.body.appendChild(div);
                win.handle = div;
            }
        

    return win;
}
function Button_create(win, text, x, y) {
        let btn = new Button({ handle: 0, id: "btn_" + text, text: text });
        
                if (typeof document !== 'undefined') {
                    const b = document.createElement('button');
                    b.innerText = text;
                    b.style.position = 'absolute';
                    b.style.left = x + 'px';
                    b.style.top = y + 'px';
                    if (win.handle) win.handle.appendChild(b);
                    btn.handle = b;
                }
            

        return btn;
}
function Button_set_click(btn, callback) {
            
                    if (btn.handle) btn.handle.onclick = callback;
                

}
function Label_create(win, text, x, y) {
                let lbl = new Label({ handle: 0, id: "lbl", text: text });
                
                        if (typeof document !== 'undefined') {
                             const l = document.createElement('div');
                             l.innerText = text;
                             l.style.position = 'absolute';
                             l.style.left = x + 'px';
                             l.style.top = y + 'px';
                             if (win.handle) win.handle.appendChild(l);
                             lbl.handle = l;
                        }
                    

                return lbl;
}
function Label_set_text(lbl, text) {
                    
                            if (lbl.handle) lbl.handle.innerText = text;
                        

}
function TextInput_create(win, x, y) {
                        let inp = new TextInput({ handle: 0, id: "input" });
                        
                                if (typeof document !== 'undefined') {
                                    const i = document.createElement('input');
                                    i.type = 'text';
                                    i.style.position = 'absolute';
                                    i.style.left = x + 'px';
                                    i.style.top = y + 'px';
                                    if (win.handle) win.handle.appendChild(i);
                                    inp.handle = i;
                                }
                            

                        return inp;
}
function TextInput_get_value(inp) {
                            let val = "";
                            
                                    if (inp.handle) val = inp.handle.value;
                                

                            return val;
}
function Window_bind_key(win, key, callback) {
                                
                                        if (typeof document !== 'undefined') {
                                            document.addEventListener('keydown', (e) => {
                                                if (e.key === key) callback();
                                            });
                                        }
                                    

}
function UI_run() {
                                    
                                            console.log("UI running (web mode)");
                                        

}
// ===== END: std/ui.omni =====

// ===== INLINE: std/math.omni =====
function abs(n) {
        if (n < 0) {
                return 0 - n;
        }
        return n;
}
function min(a, b) {
                if (a < b) {
                                return a;
                }
                return b;
}
function max(a, b) {
                        if (a > b) {
                                                return a;
                        }
                        return b;
}
function clamp(value, min_val, max_val) {
                                if (value < min_val) {
                                                                return min_val;
                                }
                                    if (value > max_val) {
                                                                        return max_val;
                                    }
                                    return value;
}
function sqrt(n) {
                                        let result = 0;
                                         result = Math.sqrt(n); 

                                        return result;
}
function pow(base, exp) {
                                            let result = 0;
                                             result = Math.pow(base, exp); 

                                            return result;
}
function sin(n) {
                                                let result = 0;
                                                 result = Math.sin(n); 

                                                return result;
}
function cos(n) {
                                                    let result = 0;
                                                     result = Math.cos(n); 

                                                    return result;
}
function floor(n) {
                                                        let result = 0;
                                                         result = Math.floor(n); 

                                                        return result;
}
function ceil(n) {
                                                            let result = 0;
                                                             result = Math.ceil(n); 

                                                            return result;
}
function random() {
                                                                let result = 0;
                                                                 result = Math.random(); 

                                                                return result;
}
function random_int(min_val, max_val) {
                                                                    let result = 0;
                                                                     
                                                                            result = Math.floor(Math.random() * (max_val - min_val + 1)) + min_val; 
                                                                        

                                                                    return result;
}
// ===== END: std/math.omni =====

// ===== INLINE: std/time.omni =====
function Time_now_ms() {
    let t = 0;
    
            t = Date.now();
        

    return t;
}
function Time_schedule(delay_ms, callback) {
        
                setTimeout(callback, delay_ms);
            

}
function Time_iso_string(timestamp) {
            let s = "";
            
                    s = new Date(timestamp).toISOString();
                

            return s;
}
// ===== END: std/time.omni =====

class GameState {
    constructor(data = {}) {
        this.player = data.player;
        this.obstacle = data.obstacle;
        this.playerX = data.playerX;
        this.renderer = data.renderer;
        this.scene = data.scene;
        this.camera = data.camera;
        this.startTime = data.startTime;
    }

}
let game_state_ref = 0;
function on_left_arrow() {
    let s = game_state_ref;
    s.playerX = s.playerX - 0.5;
    Mesh_set_position(s.player, s.playerX, 0, 0);
}
function on_right_arrow() {
        let s = game_state_ref;
        s.playerX = s.playerX + 10.5;
        s.playerX = s.playerX - 10;
        let old = s.playerX;
        let ref = game_state_ref;
        ref.playerX = ref.playerX + 0.5;
        Mesh_set_position(ref.player, ref.playerX, 0, 0);
}
function game_loop() {
            let s = game_state_ref;
            let now = Time_now_ms();
            let elapsed = now - s.startTime;
            let t = elapsed * 0.001;
            let px = s.playerX;
            let ox = 3;
            let dist = px - ox;
                if (dist < 0) {
                                dist = 0 - dist;
                }
                        if (dist < 1) {
                                            Mesh_set_rotation(s.obstacle, 0, t * 5, 0);
                        } else {
                                                Mesh_set_rotation(s.obstacle, 0, 0, 0);
                        }
                        Renderer_render(s.renderer, s.scene, s.camera);
}
function init_game() {
                            console.log("Initializing 3D Game...");
                            let win = Window_create(new WindowConfig({ title: "Omni 3D Game", width: 800, height: 600, background: "#000000" }));
                            let scene = Scene_create();
                            let camera = Camera_create();
                            Camera_set_position(camera, 0, 2, 10);
                            let renderer = Renderer_create();
                            Renderer_init(renderer);
                            let player = Cube_create(1, 65280, scene);
                            Mesh_set_position(player, 0, 0, 0);
                            let obstacle = Cube_create(1, 16711680, scene);
                            Mesh_set_position(obstacle, 3, 0, 0);
                            let state = new GameState({ player: player, obstacle: obstacle, playerX: 0, renderer: renderer, scene: scene, camera: camera, startTime: Time_now_ms() });
                            game_state_ref = state;
                            Window_bind_key(win, "ArrowLeft", on_left_arrow);
                            Window_bind_key(win, "ArrowRight", on_right_arrow);
                            console.log("Use Left/Right arrows to move.");
                            AnimationLoop(game_loop);
                            UI_run();
}
function main() {
                                init_game();
}

module.exports = { on_left_arrow, on_right_arrow, game_loop, init_game, main };

if (typeof main === 'function') { main(); }
