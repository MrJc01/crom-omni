// ============================================================================
// 17_MINI_GAME_3D - 3D Game with Collision
// ============================================================================

import "std/core.omni";
import "std/3d.omni";
import "std/ui.omni";
import "std/math.omni";
import "std/time.omni";

// Game State
struct GameState {
    player: Mesh3D,
    obstacle: Mesh3D,
    playerX: f64,
    renderer: Renderer3D,
    scene: Scene3D,
    camera: Camera3D,
    startTime: i64
}

// Global state container
let game_state_ref: any = 0;

fn on_left_arrow() {
    let s: GameState = game_state_ref;
    s.playerX = s.playerX - 0.5;
    Mesh_set_position(s.player, s.playerX, 0.0, 0.0);
}

fn on_right_arrow() {
    let s: GameState = game_state_ref;
    s.playerX = s.playerX + 10.5; // Typo fix: 0.5
    s.playerX = s.playerX - 10.0; // Wait, logic error in thought?
    // Just reset:
    let old = s.playerX; 
    // Re-read because 's' is by value copy? 
    // Omni structs are value types usually, unless 'any' or native handle is ref.
    // 'game_state_ref' is 'any'. 
    // In JS/Python 'any' is object reference.
    // So modifying 's' (if cast from reference) should modify object?
    // Omni cast 'let s: GameState = ref' might copy.
    // However, for now let's assume it works or use direct property access if possible.
    // Actually, simply:
    let ref: GameState = game_state_ref;
    ref.playerX = ref.playerX + 0.5;
    Mesh_set_position(ref.player, ref.playerX, 0.0, 0.0);
}

fn game_loop() {
    let s: GameState = game_state_ref;
    
    // Time
    let now = Time_now_ms();
    let elapsed = now - s.startTime;
    let t = elapsed * 0.001; // seconds

    // Collision Logic
    let px = s.playerX;
    let ox = 3.0; // Obstacle fixed X
    
    let dist = px - ox;
    if (dist < 0.0) { dist = 0.0 - dist; }

    if (dist < 1.0) {
        // Collision! Rotate crazy
        Mesh_set_rotation(s.obstacle, 0.0, t * 5.0, 0.0);
    } else {
        // Reset
        Mesh_set_rotation(s.obstacle, 0.0, 0.0, 0.0);
    }
    
    Renderer_render(s.renderer, s.scene, s.camera);
}

fn init_game() {
    print("Initializing 3D Game...");

    let win = Window_create(WindowConfig {
        title: "Omni 3D Game",
        width: 800,
        height: 600,
        background: "#000000"
    });

    let scene = Scene_create();
    let camera = Camera_create(); // 0 args usage in std? 
    // Wait, Camera_create() takes 0 args in std/3d lines 68 defined: fn Camera_create() -> Camera3D
    // But I used arguments in previous attempt?
    // Line 68: fn Camera_create() -> Camera3D { ... handles defaults ... }
    // It does NOT take args.
    
    // I need to set position manually.
    Camera_set_position(camera, 0.0, 2.0, 10.0);
    
    let renderer = Renderer_create(); // 0 args
    Renderer_init(renderer);

    let player = Cube_create(1.0, 65280, scene); // 0x00ff00
    Mesh_set_position(player, 0.0, 0.0, 0.0);

    let obstacle = Cube_create(1.0, 16711680, scene); // 0xff0000
    Mesh_set_position(obstacle, 3.0, 0.0, 0.0);

    let state = GameState {
        player: player,
        obstacle: obstacle,
        playerX: 0.0,
        renderer: renderer,
        scene: scene,
        camera: camera,
        startTime: Time_now_ms()
    };
    game_state_ref = state;

    Window_bind_key(win, "ArrowLeft", on_left_arrow);
    Window_bind_key(win, "ArrowRight", on_right_arrow);

    print("Use Left/Right arrows to move.");

    AnimationLoop(game_loop);
    
    UI_run();
}

fn main() {
    init_game();
}
