// ============================================================================
// 16_BACKGROUND_WORKER.omni - Parallel Processing & Workers
// ============================================================================
// Demonstrates Omni's approach to concurrent computation:
// - Worker pools for CPU-intensive tasks
// - Message passing between workers
// - Async task queues
//
// Run with:
//   .\omni compile examples/16_background_worker.omni --target js
// ============================================================================

// @visual:position(50, 50)
fn print(msg: string) {
    native "js" { console.log(msg); }
}

// ============================================================================
// WORKER TYPES
// ============================================================================

// @visual:position(100, 150)
@entity
struct Task {
    id: string,
    name: string,
    payload: any,
    status: string,     // "pending", "running", "completed", "failed"
    result: any,
    error: string
}

// @visual:position(350, 150)
@entity
struct Worker {
    id: string,
    status: string,     // "idle", "busy", "stopped"
    current_task: Task,
    tasks_completed: i64
}

// @visual:position(600, 150)
@entity
struct WorkerPool {
    workers: Worker[],
    task_queue: Task[],
    max_workers: i64,
    total_completed: i64
}

// ============================================================================
// TASK QUEUE CAPSULE
// ============================================================================

// @visual:position(100, 400)
capsule TaskQueue {
    let queue: Task[] = [];
    let processing: bool = false;
    
    // @visual:position(150, 450)
    // Add task to queue
    flow enqueue(name: string, payload: any) -> Task {
        let task = Task {
            id: "",
            name: name,
            payload: payload,
            status: "pending",
            result: 0,
            error: ""
        };
        
        native "js" {
            const crypto = require('crypto');
            task.id = crypto.randomBytes(4).toString('hex');
            TaskQueue.queue.push(task);
        }
        
        return task;
    }
    
    // @visual:position(400, 450)
    // Get next pending task
    flow dequeue() -> Task {
        let task = Task {
            id: "",
            name: "",
            payload: 0,
            status: "",
            result: 0,
            error: ""
        };
        
        native "js" {
            const pending = TaskQueue.queue.find(t => t.status === 'pending');
            if (pending) {
                pending.status = 'running';
                task = pending;
            }
        }
        
        return task;
    }
    
    // @visual:position(650, 450)
    // Mark task as completed
    flow complete(task_id: string, result: any) {
        native "js" {
            const task = TaskQueue.queue.find(t => t.id === task_id);
            if (task) {
                task.status = 'completed';
                task.result = result;
            }
        }
    }
    
    // @visual:position(150, 600)
    // Mark task as failed
    flow fail(task_id: string, error: string) {
        native "js" {
            const task = TaskQueue.queue.find(t => t.id === task_id);
            if (task) {
                task.status = 'failed';
                task.error = error;
            }
        }
    }
    
    // @visual:position(400, 600)
    // Get queue length
    flow length() -> i64 {
        let len: i64 = 0;
        native "js" {
            len = TaskQueue.queue.filter(t => t.status === 'pending').length;
        }
        return len;
    }
}

// ============================================================================
// WORKER POOL CAPSULE
// ============================================================================

// @visual:position(100, 800)
capsule Workers {
    let pool: WorkerPool = WorkerPool {
        workers: [],
        task_queue: [],
        max_workers: 4,
        total_completed: 0
    };
    
    // @visual:position(150, 850)
    // Initialize worker pool
    flow init(num_workers: i64) {
        Workers.pool.max_workers = num_workers;
        
        native "js" {
            const crypto = require('crypto');
            
            for (let i = 0; i < num_workers; i++) {
                const worker = {
                    id: 'worker-' + crypto.randomBytes(2).toString('hex'),
                    status: 'idle',
                    current_task: null,
                    tasks_completed: 0
                };
                Workers.pool.workers.push(worker);
            }
        }
    }
    
    // @visual:position(400, 850)
    // Submit task to pool
    flow submit(name: string, handler: any, payload: any) -> Task {
        let task = TaskQueue.enqueue(name, payload);
        
        native "js" {
            // Find idle worker
            const worker = Workers.pool.workers.find(w => w.status === 'idle');
            
            if (worker) {
                worker.status = 'busy';
                worker.current_task = task;
                
                // Simulate async execution
                setTimeout(() => {
                    try {
                        const result = handler(payload);
                        task.status = 'completed';
                        task.result = result;
                    } catch (e) {
                        task.status = 'failed';
                        task.error = e.message;
                    }
                    
                    worker.status = 'idle';
                    worker.current_task = null;
                    worker.tasks_completed++;
                    Workers.pool.total_completed++;
                }, 100);
            }
        }
        
        return task;
    }
    
    // @visual:position(650, 850)
    // Submit async task (returns Promise in JS)
    flow submit_async(name: string, handler: any, payload: any) -> any {
        let promise: any = 0;
        
        native "js" {
            promise = new Promise((resolve, reject) => {
                const task = TaskQueue.enqueue(name, payload);
                
                const worker = Workers.pool.workers.find(w => w.status === 'idle');
                
                if (worker) {
                    worker.status = 'busy';
                    
                    setTimeout(() => {
                        try {
                            const result = handler(payload);
                            task.status = 'completed';
                            task.result = result;
                            worker.status = 'idle';
                            worker.tasks_completed++;
                            Workers.pool.total_completed++;
                            resolve(result);
                        } catch (e) {
                            task.status = 'failed';
                            task.error = e.message;
                            worker.status = 'idle';
                            reject(e);
                        }
                    }, 100);
                } else {
                    reject(new Error('No idle workers'));
                }
            });
        }
        
        return promise;
    }
    
    // @visual:position(150, 1050)
    // Get worker status
    flow status() {
        native "js" {
            console.log('  Worker Pool Status:');
            console.log('    Total workers: ' + Workers.pool.workers.length);
            console.log('    Idle: ' + Workers.pool.workers.filter(w => w.status === 'idle').length);
            console.log('    Busy: ' + Workers.pool.workers.filter(w => w.status === 'busy').length);
            console.log('    Tasks completed: ' + Workers.pool.total_completed);
        }
    }
    
    // @visual:position(400, 1050)
    // Wait for all tasks to complete
    flow wait_all() {
        native "js" {
            return new Promise(resolve => {
                const check = () => {
                    const busy = Workers.pool.workers.filter(w => w.status === 'busy').length;
                    if (busy === 0) {
                        resolve();
                    } else {
                        setTimeout(check, 50);
                    }
                };
                check();
            });
        }
    }
    
    // @visual:position(650, 1050)
    // Shutdown pool
    flow shutdown() {
        native "js" {
            for (const worker of Workers.pool.workers) {
                worker.status = 'stopped';
            }
            Workers.pool.workers = [];
            console.log('  Worker pool shutdown complete');
        }
    }
}

// ============================================================================
// DEMO
// ============================================================================

// @visual:position(400, 1300)
fn main() {
    print("╔══════════════════════════════════════╗");
    print("║   OMNI - Background Workers          ║");
    print("╚══════════════════════════════════════╝");
    print("");
    
    print("1. Initializing worker pool...");
    Workers.init(4);
    print("   ✓ Created 4 workers");
    print("");
    
    Workers.status();
    print("");
    
    print("2. Submitting tasks...");
    native "js" {
        // Define task handlers
        const fibonacci = (n) => {
            if (n <= 1) return n;
            return fibonacci(n - 1) + fibonacci(n - 2);
        };
        
        const factorial = (n) => {
            let result = 1;
            for (let i = 2; i <= n; i++) result *= i;
            return result;
        };
        
        // Submit multiple tasks
        Workers.submit('fib(30)', fibonacci, 30);
        Workers.submit('fib(32)', fibonacci, 32);
        Workers.submit('factorial(10)', factorial, 10);
        Workers.submit('factorial(12)', factorial, 12);
    }
    print("   ✓ Submitted 4 CPU-intensive tasks");
    print("");
    
    print("3. Worker status while processing...");
    Workers.status();
    print("");
    
    print("4. Waiting for completion...");
    native "js" {
        Workers.wait_all().then(() => {
            console.log('   ✓ All tasks completed');
            console.log('');
            
            console.log('5. Final status:');
            Workers.status();
            console.log('');
            
            console.log('6. Shutting down...');
            Workers.shutdown();
            console.log('');
            
            console.log('Worker Pool API:');
            console.log('  Workers.init(n)              - Create n workers');
            console.log('  Workers.submit(name, fn, p)  - Submit task');
            console.log('  Workers.submit_async(...)    - Submit async task');
            console.log('  Workers.status()             - Show pool status');
            console.log('  Workers.wait_all()           - Wait for completion');
            console.log('  Workers.shutdown()           - Stop all workers');
            console.log('');
            
            console.log('✓ Background worker demo complete!');
        });
    }
}
