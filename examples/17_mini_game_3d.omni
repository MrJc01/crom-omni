// ============================================================================
// 17_MINI_GAME_3D.omni - A Complete 3D Game
// ============================================================================
// A simple 3D game demonstrating:
// - Game loop with delta time
// - Collision detection
// - Score tracking
// - Player input handling
//
// Run with:
//   .\omni compile examples/17_mini_game_3d.omni --target js
// ============================================================================

// @visual:position(50, 50)
fn print(msg: string) {
    native "js" { console.log(msg); }
}

// ============================================================================
// GAME TYPES
// ============================================================================

// @visual:position(100, 150)
struct Vec3 {
    x: f64,
    y: f64,
    z: f64
}

// @visual:position(250, 150)
@entity
struct Player {
    position: Vec3,
    velocity: Vec3,
    size: f64,
    color: string,
    mesh: any
}

// @visual:position(400, 150)
@entity
struct Collectible {
    position: Vec3,
    size: f64,
    color: string,
    collected: bool,
    mesh: any
}

// @visual:position(550, 150)
@entity
struct GameState {
    score: i64,
    time_remaining: f64,
    game_over: bool,
    player: Player,
    collectibles: Collectible[]
}

// ============================================================================
// INPUT CAPSULE
// ============================================================================

// @visual:position(100, 350)
capsule Input {
    let keys: any = 0;
    
    // @visual:position(150, 400)
    flow init() {
        native "js" {
            Input.keys = {};
            document.addEventListener('keydown', e => Input.keys[e.key] = true);
            document.addEventListener('keyup', e => Input.keys[e.key] = false);
        }
    }
    
    // @visual:position(350, 400)
    flow is_pressed(key: string) -> bool {
        let pressed = false;
        native "js" {
            pressed = Input.keys[key] === true;
        }
        return pressed;
    }
}

// ============================================================================
// GAME ENGINE CAPSULE
// ============================================================================

// @visual:position(100, 550)
capsule Game {
    let state: GameState = GameState {
        score: 0,
        time_remaining: 60.0,
        game_over: false,
        player: Player {
            position: Vec3 { x: 0.0, y: 0.0, z: 0.0 },
            velocity: Vec3 { x: 0.0, y: 0.0, z: 0.0 },
            size: 1.0,
            color: "#58a6ff",
            mesh: 0
        },
        collectibles: []
    };
    
    let scene: any = 0;
    let camera: any = 0;
    let renderer: any = 0;
    let ui_score: any = 0;
    let ui_time: any = 0;
    
    // @visual:position(150, 600)
    // Initialize the game
    flow init(width: i64, height: i64) {
        native "js" {
            const THREE = window.THREE;
            
            // Create container
            const container = document.createElement('div');
            container.id = 'game-container';
            container.style.cssText = 'width:' + width + 'px;height:' + height + 'px;margin:auto;position:relative;';
            document.body.appendChild(container);
            
            // Scene
            Game.scene = new THREE.Scene();
            Game.scene.background = new THREE.Color('#1a1a2e');
            
            // Camera
            Game.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            Game.camera.position.set(0, 10, 15);
            Game.camera.lookAt(0, 0, 0);
            
            // Renderer
            Game.renderer = new THREE.WebGLRenderer({ antialias: true });
            Game.renderer.setSize(width, height);
            container.appendChild(Game.renderer.domElement);
            
            // Lights
            const ambient = new THREE.AmbientLight(0x404040, 0.5);
            Game.scene.add(ambient);
            const directional = new THREE.DirectionalLight(0xffffff, 1);
            directional.position.set(5, 10, 7.5);
            Game.scene.add(directional);
            
            // Ground plane
            const groundGeom = new THREE.PlaneGeometry(20, 20);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x333344 });
            const ground = new THREE.Mesh(groundGeom, groundMat);
            ground.rotation.x = -Math.PI / 2;
            Game.scene.add(ground);
            
            // Player cube
            const playerGeom = new THREE.BoxGeometry(1, 1, 1);
            const playerMat = new THREE.MeshStandardMaterial({ color: Game.state.player.color });
            Game.state.player.mesh = new THREE.Mesh(playerGeom, playerMat);
            Game.state.player.mesh.position.y = 0.5;
            Game.scene.add(Game.state.player.mesh);
            
            // UI overlay
            const ui = document.createElement('div');
            ui.style.cssText = 'position:absolute;top:10px;left:10px;color:#fff;font-family:monospace;font-size:16px;';
            ui.innerHTML = '<div id="score">Score: 0</div><div id="time">Time: 60.0</div>';
            container.appendChild(ui);
            Game.ui_score = document.getElementById('score');
            Game.ui_time = document.getElementById('time');
        }
        
        Input.init();
    }
    
    // @visual:position(450, 600)
    // Spawn collectibles
    flow spawn_collectibles(count: i64) {
        native "js" {
            const THREE = window.THREE;
            
            for (let i = 0; i < count; i++) {
                const x = (Math.random() - 0.5) * 16;
                const z = (Math.random() - 0.5) * 16;
                
                const collectible = {
                    position: { x: x, y: 0.5, z: z },
                    size: 0.5,
                    color: '#7ee787',
                    collected: false,
                    mesh: null
                };
                
                const geom = new THREE.SphereGeometry(0.4, 16, 16);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: collectible.color,
                    emissive: 0x224422
                });
                collectible.mesh = new THREE.Mesh(geom, mat);
                collectible.mesh.position.set(x, 0.5, z);
                Game.scene.add(collectible.mesh);
                
                Game.state.collectibles.push(collectible);
            }
        }
    }
    
    // @visual:position(750, 600)
    // Check collision between player and collectible
    flow check_collision(c: Collectible) -> bool {
        let collided = false;
        
        native "js" {
            const dx = Game.state.player.position.x - c.position.x;
            const dz = Game.state.player.position.z - c.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            collided = dist < (Game.state.player.size / 2 + c.size);
        }
        
        return collided;
    }
    
    // @visual:position(150, 800)
    // Update game logic
    flow update(delta: f64) {
        if (Game.state.game_over) {
            return 0;
        }
        
        // Update timer
        Game.state.time_remaining = Game.state.time_remaining - delta;
        if (Game.state.time_remaining <= 0.0) {
            Game.state.game_over = true;
            return 0;
        }
        
        // Player movement
        let speed = 8.0;
        native "js" {
            Game.state.player.velocity.x = 0;
            Game.state.player.velocity.z = 0;
            
            if (Input.is_pressed('ArrowUp') || Input.is_pressed('w')) {
                Game.state.player.velocity.z = -speed;
            }
            if (Input.is_pressed('ArrowDown') || Input.is_pressed('s')) {
                Game.state.player.velocity.z = speed;
            }
            if (Input.is_pressed('ArrowLeft') || Input.is_pressed('a')) {
                Game.state.player.velocity.x = -speed;
            }
            if (Input.is_pressed('ArrowRight') || Input.is_pressed('d')) {
                Game.state.player.velocity.x = speed;
            }
            
            // Apply velocity
            Game.state.player.position.x += Game.state.player.velocity.x * delta;
            Game.state.player.position.z += Game.state.player.velocity.z * delta;
            
            // Clamp to bounds
            Game.state.player.position.x = Math.max(-9, Math.min(9, Game.state.player.position.x));
            Game.state.player.position.z = Math.max(-9, Math.min(9, Game.state.player.position.z));
            
            // Update mesh
            Game.state.player.mesh.position.x = Game.state.player.position.x;
            Game.state.player.mesh.position.z = Game.state.player.position.z;
            
            // Check collectibles
            for (const c of Game.state.collectibles) {
                if (!c.collected && Game.check_collision(c)) {
                    c.collected = true;
                    c.mesh.visible = false;
                    Game.state.score += 10;
                }
            }
            
            // Update UI
            Game.ui_score.textContent = 'Score: ' + Game.state.score;
            Game.ui_time.textContent = 'Time: ' + Game.state.time_remaining.toFixed(1);
        }
        
        return 0;
    }
    
    // @visual:position(450, 800)
    // Render frame
    flow render() {
        native "js" {
            Game.renderer.render(Game.scene, Game.camera);
        }
    }
    
    // @visual:position(750, 800)
    // Main game loop
    flow run() {
        native "js" {
            let lastTime = 0;
            
            function gameLoop(time) {
                requestAnimationFrame(gameLoop);
                
                const delta = Math.min((time - lastTime) / 1000, 0.1);
                lastTime = time;
                
                Game.update(delta);
                Game.render();
                
                if (Game.state.game_over) {
                    const gameOver = document.createElement('div');
                    gameOver.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;font-size:32px;font-family:sans-serif;text-align:center;';
                    gameOver.innerHTML = 'GAME OVER<br>Score: ' + Game.state.score;
                    document.getElementById('game-container').appendChild(gameOver);
                    return; // Stop loop
                }
            }
            
            gameLoop(0);
        }
    }
}

// ============================================================================
// MAIN
// ============================================================================

// @visual:position(400, 1050)
fn main() {
    print("╔══════════════════════════════════════╗");
    print("║   OMNI - Mini 3D Game                ║");
    print("╚══════════════════════════════════════╝");
    print("");
    
    print("Initializing game...");
    Game.init(800, 600);
    print("  ✓ Scene created");
    
    Game.spawn_collectibles(15);
    print("  ✓ Spawned 15 collectibles");
    print("");
    
    print("Controls:");
    print("  Arrow keys or WASD - Move player");
    print("  Collect green spheres for points!");
    print("  60 seconds to get the highest score");
    print("");
    
    print("Starting game...");
    Game.run();
    
    print("");
    print("Game Features:");
    print("  - Delta time game loop");
    print("  - Collision detection");
    print("  - Score tracking");
    print("  - Time limit");
    print("  - Keyboard input");
    print("");
    
    print("✓ Game running!");
}
