// ============================================================================
// 3D SCENE EXAMPLE - Omni Visual 3D Programming
// This example demonstrates the std.3d interface with visual nodes
// ============================================================================

// Import the standard 3D library
import "lib/std.omni";

// ============================================================================
// SCENE CONFIGURATION ENTITY
// ============================================================================

@entity
struct SceneConfig {
    width: i64,
    height: i64,
    background_color: string,
    camera_x: f64,
    camera_y: f64,
    camera_z: f64
}

// ============================================================================
// 3D OBJECTS
// ============================================================================

@entity
struct Cube3D {
    x: f64,
    y: f64,
    z: f64,
    size: f64,
    color: string,
    rotation_speed: f64
}

@entity
struct Light3D {
    type: string,        // "directional", "point", "ambient"
    intensity: f64,
    color: string
}

// ============================================================================
// SCENE CAPSULE - Visual Node Graph Maps to This
// ============================================================================

capsule Scene3D {
    // @visual:position(100, 100)
    // Initialize the 3D scene
    flow init(config: SceneConfig) -> any {
        native "js" {
            // Create HTML container
            const container = document.createElement('div');
            container.id = 'scene-container';
            container.style.cssText = 'width:' + config.width + 'px;height:' + config.height + 'px;';
            document.body.appendChild(container);
            
            // Three.js scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(config.background_color);
            
            // Camera
            const camera = new THREE.PerspectiveCamera(75, config.width / config.height, 0.1, 1000);
            camera.position.set(config.camera_x, config.camera_y, config.camera_z);
            
            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(config.width, config.height);
            container.appendChild(renderer.domElement);
            
            return { scene, camera, renderer };
        }
    }
    
    // @visual:position(300, 100)
    // Add a cube to the scene
    flow add_cube(scene_obj: any, cube: Cube3D) -> any {
        native "js" {
            const geometry = new THREE.BoxGeometry(cube.size, cube.size, cube.size);
            const material = new THREE.MeshStandardMaterial({ 
                color: cube.color,
                metalness: 0.3,
                roughness: 0.7
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(cube.x, cube.y, cube.z);
            mesh.userData.rotationSpeed = cube.rotation_speed;
            scene_obj.scene.add(mesh);
            return mesh;
        }
    }
    
    // @visual:position(300, 200)
    // Add a sphere to the scene
    flow add_sphere(scene_obj: any, x: f64, y: f64, z: f64, radius: f64, color: string) -> any {
        native "js" {
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                metalness: 0.5,
                roughness: 0.5
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            scene_obj.scene.add(mesh);
            return mesh;
        }
    }
    
    // @visual:position(300, 300)
    // Add lighting to the scene
    flow add_light(scene_obj: any, light: Light3D) {
        native "js" {
            let lightObj;
            
            if (light.type === 'directional') {
                lightObj = new THREE.DirectionalLight(light.color, light.intensity);
                lightObj.position.set(5, 10, 7.5);
            } else if (light.type === 'point') {
                lightObj = new THREE.PointLight(light.color, light.intensity);
                lightObj.position.set(0, 5, 0);
            } else {
                lightObj = new THREE.AmbientLight(light.color, light.intensity);
            }
            
            scene_obj.scene.add(lightObj);
        }
    }
    
    // @visual:position(500, 100)
    // Animation loop
    flow animate(scene_obj: any, objects: any) {
        native "js" {
            function loop() {
                requestAnimationFrame(loop);
                
                // Rotate objects with rotation speed
                for (const obj of objects) {
                    if (obj.userData && obj.userData.rotationSpeed) {
                        obj.rotation.x += obj.userData.rotationSpeed;
                        obj.rotation.y += obj.userData.rotationSpeed * 0.7;
                    }
                }
                
                scene_obj.renderer.render(scene_obj.scene, scene_obj.camera);
            }
            
            loop();
        }
    }
}

// ============================================================================
// MAIN - Entry Point
// ============================================================================

fn main() {
    print("ğŸ® Omni 3D Scene Example");
    print("========================");
    
    // Scene configuration
    let config = SceneConfig {
        width: 800,
        height: 600,
        background_color: "#1a1a2e",
        camera_x: 0.0,
        camera_y: 2.0,
        camera_z: 5.0
    };
    
    // Initialize scene
    let scene = Scene3D.init(config);
    
    // Add a rotating cube
    let cube = Cube3D {
        x: -1.5,
        y: 0.0,
        z: 0.0,
        size: 1.0,
        color: "#58a6ff",
        rotation_speed: 0.01
    };
    let cube_mesh = Scene3D.add_cube(scene, cube);
    
    // Add a second cube
    let cube2 = Cube3D {
        x: 1.5,
        y: 0.0,
        z: 0.0,
        size: 0.8,
        color: "#7ee787",
        rotation_speed: 0.015
    };
    let cube_mesh2 = Scene3D.add_cube(scene, cube2);
    
    // Add a sphere
    let sphere = Scene3D.add_sphere(scene, 0.0, 0.0, 0.0, 0.5, "#a371f7");
    
    // Add lighting
    let main_light = Light3D {
        type: "directional",
        intensity: 1.0,
        color: "#ffffff"
    };
    Scene3D.add_light(scene, main_light);
    
    let ambient = Light3D {
        type: "ambient",
        intensity: 0.4,
        color: "#404040"
    };
    Scene3D.add_light(scene, ambient);
    
    // Start animation loop
    let objects = [cube_mesh, cube_mesh2, sphere];
    Scene3D.animate(scene, objects);
    
    print("âœ“ Scene initialized with 3 objects");
    print("âœ“ Animation running");
}

// ============================================================================
// VISUAL NODE MAPPING
// ============================================================================
// 
// This code maps to the following visual graph in Omni Studio:
//
//  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
//  â”‚                         Scene3D                              â”‚
//  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
//  â”‚  â”‚                                                         â”‚ â”‚
//  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚ â”‚
//  â”‚  â”‚  â”‚  init    â”‚â”€â”€â”€â”€â–ºâ”‚ add_cube â”‚â”€â”€â”€â”€â–ºâ”‚ add_cube â”‚         â”‚ â”‚
//  â”‚  â”‚  â”‚ (config) â”‚     â”‚  (blue)  â”‚     â”‚  (green) â”‚         â”‚ â”‚
//  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚ â”‚
//  â”‚  â”‚       â”‚                                 â”‚               â”‚ â”‚
//  â”‚  â”‚       â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚               â”‚ â”‚
//  â”‚  â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚add_sphereâ”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚ â”‚
//  â”‚  â”‚                   â”‚ (purple) â”‚                          â”‚ â”‚
//  â”‚  â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚ â”‚
//  â”‚  â”‚                        â”‚                                â”‚ â”‚
//  â”‚  â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚ â”‚
//  â”‚  â”‚       â”‚add_light â”‚â—„â”€â”€â”€â”€â”´â”€â”€â”€â”€â–ºâ”‚add_light â”‚               â”‚ â”‚
//  â”‚  â”‚       â”‚ (direct) â”‚           â”‚(ambient) â”‚               â”‚ â”‚
//  â”‚  â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚ â”‚
//  â”‚  â”‚            â”‚                      â”‚                     â”‚ â”‚
//  â”‚  â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚ â”‚
//  â”‚  â”‚                       â–¼                                 â”‚ â”‚
//  â”‚  â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”‚ â”‚
//  â”‚  â”‚               â”‚ animate  â”‚                              â”‚ â”‚
//  â”‚  â”‚               â”‚ (loop)   â”‚                              â”‚ â”‚
//  â”‚  â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â”‚ â”‚
//  â”‚  â”‚                                                         â”‚ â”‚
//  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
//  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
// Each flow in the capsule is represented as a node in the visual editor.
// Connections between nodes represent the data flow and execution order.
// ============================================================================
