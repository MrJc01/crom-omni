// ============================================================================
// OMNI PACKAGE MANAGER - Install and manage .omni-pkg packages
// ============================================================================

import "lib/cli.omni";

// ============================================================================
// PACKAGE REGISTRY
// ============================================================================

struct Package {
    name: string,
    version: string,
    type: string,        // "target", "adapter", "pattern", "library"
    path: string,
    installed: bool
}

struct PackageRegistry {
    packages: any,
    local_path: string,
    remote_url: string
}

fn PackageRegistry_new() -> PackageRegistry {
    let registry = PackageRegistry {
        packages: {},
        local_path: "",
        remote_url: "https://registry.omni-lang.org/packages"  // Future remote registry
    };
    
    native "js" {
        const path = require('path');
        const fs = require('fs');
        
        // Local package directories
        registry.local_path = path.join(__dirname, '..', 'packages');
        
        // Ensure directories exist
        const dirs = [
            registry.local_path,
            path.join(__dirname, '..', 'targets'),
            path.join(__dirname, '..', 'adapters'),
            path.join(__dirname, '..', 'patterns')
        ];
        
        for (const dir of dirs) {
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
        }
        
        // Load installed packages
        const registryFile = path.join(registry.local_path, 'registry.json');
        if (fs.existsSync(registryFile)) {
            registry.packages = JSON.parse(fs.readFileSync(registryFile, 'utf-8'));
        }
    }
    
    return registry;
}

fn PackageRegistry_save(self: PackageRegistry) {
    native "js" {
        const path = require('path');
        const fs = require('fs');
        
        const registryFile = path.join(self.local_path, 'registry.json');
        fs.writeFileSync(registryFile, JSON.stringify(self.packages, null, 2));
    }
}

fn PackageRegistry_list(self: PackageRegistry) {
    CLI_header("Installed Packages");
    
    native "js" {
        const packages = Object.values(self.packages);
        
        if (packages.length === 0) {
            CLI_info("No packages installed.");
            console.log("");
            CLI_info("Install packages with: omni install <package>");
            return;
        }
        
        const headers = ["Name", "Version", "Type", "Path"];
        const rows = packages.map(p => [p.name, p.version, p.type, p.path]);
        CLI_table(headers, rows);
    }
}

// ============================================================================
// PACKAGE INSTALLER
// ============================================================================

fn cmd_install(package_path: string) {
    CLI_header("Omni Package Installer");
    
    let registry = PackageRegistry_new();
    
    native "js" {
        const fs = require('fs');
        const path = require('path');
        
        // Check if it's a URL or local path
        const isUrl = package_path.startsWith('http://') || package_path.startsWith('https://');
        const isLocal = fs.existsSync(package_path);
        
        if (!isUrl && !isLocal) {
            // Check built-in packages
            const builtinPath = path.join(__dirname, '..', 'packages', package_path);
            if (fs.existsSync(builtinPath)) {
                package_path = builtinPath;
            } else {
                CLI_error("Package not found: " + package_path);
                CLI_info("Provide a local path or URL to an .omni-pkg");
                return;
            }
        }
        
        CLI_step(1, 4, "Reading package...");
        
        // Load package manifest
        let manifest;
        let packageDir;
        
        if (fs.statSync(package_path).isDirectory()) {
            packageDir = package_path;
            const manifestPath = path.join(packageDir, 'manifest.json');
            if (fs.existsSync(manifestPath)) {
                manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf-8'));
            } else {
                // Try grammar.json for target packages
                const grammarPath = path.join(packageDir, 'grammar.json');
                if (fs.existsSync(grammarPath)) {
                    const grammar = JSON.parse(fs.readFileSync(grammarPath, 'utf-8'));
                    manifest = {
                        name: grammar.name || path.basename(packageDir),
                        version: grammar.version || '1.0.0',
                        type: 'target',
                        files: ['grammar.json']
                    };
                }
            }
        } else if (package_path.endsWith('.json')) {
            // Single JSON file (target profile)
            const content = JSON.parse(fs.readFileSync(package_path, 'utf-8'));
            manifest = {
                name: content.name || path.basename(package_path, '.json'),
                version: content.version || '1.0.0',
                type: 'target'
            };
            packageDir = path.dirname(package_path);
        }
        
        if (!manifest) {
            CLI_error("Invalid package: missing manifest.json or grammar.json");
            return;
        }
        
        CLI_info("Package: " + manifest.name + " v" + manifest.version);
        CLI_info("Type: " + manifest.type);
        
        CLI_step(2, 4, "Installing files...");
        
        // Determine target directory based on package type
        let targetDir;
        switch (manifest.type) {
            case 'target':
                targetDir = path.join(__dirname, '..', 'targets');
                break;
            case 'adapter':
                targetDir = path.join(__dirname, '..', 'adapters');
                break;
            case 'pattern':
                targetDir = path.join(__dirname, '..', 'patterns');
                break;
            default:
                targetDir = path.join(__dirname, '..', 'packages', manifest.name);
        }
        
        if (!fs.existsSync(targetDir)) {
            fs.mkdirSync(targetDir, { recursive: true });
        }
        
        // Copy files
        if (manifest.type === 'target') {
            // Copy grammar.json to targets/
            const grammarPath = path.join(packageDir, 'grammar.json');
            if (fs.existsSync(grammarPath)) {
                const destPath = path.join(targetDir, manifest.name + '.json');
                fs.copyFileSync(grammarPath, destPath);
                CLI_success("Installed: targets/" + manifest.name + ".json");
            } else if (package_path.endsWith('.json')) {
                // Direct JSON file
                const destPath = path.join(targetDir, manifest.name + '.json');
                fs.copyFileSync(package_path, destPath);
                CLI_success("Installed: targets/" + manifest.name + ".json");
            }
        } else if (manifest.type === 'adapter') {
            // Copy adapter files
            const adapterPath = path.join(packageDir, 'adapter.json');
            if (fs.existsSync(adapterPath)) {
                const destPath = path.join(targetDir, manifest.name + '.json');
                fs.copyFileSync(adapterPath, destPath);
                CLI_success("Installed: adapters/" + manifest.name + ".json");
            }
        } else if (manifest.type === 'pattern') {
            // Copy pattern files to patterns/
            const patternPath = path.join(packageDir, 'patterns.json');
            if (fs.existsSync(patternPath)) {
                const destPath = path.join(targetDir, manifest.name + '.json');
                fs.copyFileSync(patternPath, destPath);
                CLI_success("Installed: patterns/" + manifest.name + ".json");
            }
        }
        
        CLI_step(3, 4, "Registering package...");
        
        // Register in local registry
        registry.packages[manifest.name] = {
            name: manifest.name,
            version: manifest.version,
            type: manifest.type,
            path: targetDir,
            installed: true,
            installedAt: new Date().toISOString()
        };
        
        PackageRegistry_save(registry);
        
        CLI_step(4, 4, "Done!");
        console.log("");
        CLI_success("Package '" + manifest.name + "' installed successfully!");
        
        // Show usage
        console.log("");
        CLI_info("Usage:");
        if (manifest.type === 'target') {
            console.log(CLI_COLORS.dim + "  omni compile app.omni output --target " + manifest.name + CLI_COLORS.reset);
        } else if (manifest.type === 'adapter') {
            console.log(CLI_COLORS.dim + "  omni compile app.omni output --framework " + manifest.name + CLI_COLORS.reset);
        } else if (manifest.type === 'pattern') {
            console.log(CLI_COLORS.dim + "  omni ingest legacy.php output.omni  # Patterns auto-loaded" + CLI_COLORS.reset);
        }
    }
}

fn cmd_uninstall(package_name: string) {
    CLI_header("Omni Package Uninstaller");
    
    let registry = PackageRegistry_new();
    
    native "js" {
        const fs = require('fs');
        const path = require('path');
        
        if (!registry.packages[package_name]) {
            CLI_error("Package not found: " + package_name);
            return;
        }
        
        const pkg = registry.packages[package_name];
        
        CLI_info("Uninstalling: " + pkg.name + " v" + pkg.version);
        
        // Remove files based on type
        let filePath;
        switch (pkg.type) {
            case 'target':
                filePath = path.join(__dirname, '..', 'targets', pkg.name + '.json');
                break;
            case 'adapter':
                filePath = path.join(__dirname, '..', 'adapters', pkg.name + '.json');
                break;
            case 'pattern':
                filePath = path.join(__dirname, '..', 'patterns', pkg.name + '.json');
                break;
        }
        
        if (filePath && fs.existsSync(filePath)) {
            fs.unlinkSync(filePath);
            CLI_success("Removed: " + filePath);
        }
        
        // Remove from registry
        delete registry.packages[package_name];
        PackageRegistry_save(registry);
        
        CLI_success("Package '" + package_name + "' uninstalled.");
    }
}

fn cmd_list_packages() {
    let registry = PackageRegistry_new();
    PackageRegistry_list(registry);
}

// ============================================================================
// DOCTOR COMMAND - System Health Check
// ============================================================================

fn cmd_doctor() {
    CLI_header("Omni Doctor - System Health Check");
    
    let all_healthy = true;
    let checks_passed = 0;
    let checks_total = 0;
    
    native "js" {
        const fs = require('fs');
        const path = require('path');
        
        const check = (name, condition) => {
            checks_total++;
            if (condition) {
                checks_passed++;
                CLI_success(name);
                return true;
            } else {
                CLI_error(name);
                all_healthy = false;
                return false;
            }
        };
        
        console.log("");
        console.log(CLI_COLORS.bold + "Core Components" + CLI_COLORS.reset);
        console.log("");
        
        // Check core directories
        const omniDir = path.join(__dirname, '..');
        check("Omni directory exists", fs.existsSync(omniDir));
        check("targets/ directory exists", fs.existsSync(path.join(omniDir, 'targets')));
        check("adapters/ directory exists", fs.existsSync(path.join(omniDir, 'adapters')));
        check("packages/ directory exists", fs.existsSync(path.join(omniDir, 'packages')));
        
        console.log("");
        console.log(CLI_COLORS.bold + "Target Profiles" + CLI_COLORS.reset);
        console.log("");
        
        // Check built-in targets
        const targetsDir = path.join(omniDir, 'targets');
        const requiredTargets = ['js.json', 'python.json', 'lua.json'];
        
        for (const target of requiredTargets) {
            const exists = fs.existsSync(path.join(targetsDir, target));
            check("Target: " + target, exists);
        }
        
        // Check optional targets
        const optionalTargets = ['c.json', 'c_native.json', 'rust.json'];
        for (const target of optionalTargets) {
            const targetPath = path.join(targetsDir, target);
            if (fs.existsSync(targetPath)) {
                checks_total++;
                checks_passed++;
                CLI_info("Optional: " + target + " (installed)");
            }
        }
        
        console.log("");
        console.log(CLI_COLORS.bold + "Contract Registry" + CLI_COLORS.reset);
        console.log("");
        
        // Check contract implementations
        const contracts = ['std.io', 'std.fs', 'std.http', 'std.json', 'std.time'];
        for (const contract of contracts) {
            check("Contract: " + contract, true); // Built-in contracts always available
        }
        
        console.log("");
        console.log(CLI_COLORS.bold + "Installed Packages" + CLI_COLORS.reset);
        console.log("");
        
        // Check installed packages
        const registryFile = path.join(omniDir, 'packages', 'registry.json');
        if (fs.existsSync(registryFile)) {
            const registry = JSON.parse(fs.readFileSync(registryFile, 'utf-8'));
            const pkgCount = Object.keys(registry).length;
            check("Package registry exists", true);
            CLI_info("Installed packages: " + pkgCount);
            
            // Validate each package
            for (const [name, pkg] of Object.entries(registry)) {
                let pkgFile;
                switch (pkg.type) {
                    case 'target':
                        pkgFile = path.join(omniDir, 'targets', name + '.json');
                        break;
                    case 'adapter':
                        pkgFile = path.join(omniDir, 'adapters', name + '.json');
                        break;
                    case 'pattern':
                        pkgFile = path.join(omniDir, 'patterns', name + '.json');
                        break;
                }
                
                if (pkgFile && fs.existsSync(pkgFile)) {
                    checks_total++;
                    checks_passed++;
                    CLI_info("Package: " + name + " v" + pkg.version + " ✓");
                } else if (pkgFile) {
                    checks_total++;
                    CLI_warning("Package: " + name + " (file missing)");
                    all_healthy = false;
                }
            }
        } else {
            CLI_info("No packages installed");
        }
        
        // Summary
        console.log("");
        console.log("─".repeat(50));
        console.log("");
        
        const healthPercent = Math.round((checks_passed / checks_total) * 100);
        
        if (all_healthy) {
            CLI_success("All systems operational! (" + checks_passed + "/" + checks_total + " checks passed)");
            console.log("");
            console.log(CLI_COLORS.green + "  █████████████████████████████████████████████████" + CLI_COLORS.reset);
            console.log(CLI_COLORS.green + "  ██                                             ██" + CLI_COLORS.reset);
            console.log(CLI_COLORS.green + "  ██   OMNI COMPILER - ALL SYSTEMS HEALTHY       ██" + CLI_COLORS.reset);
            console.log(CLI_COLORS.green + "  ██                                             ██" + CLI_COLORS.reset);
            console.log(CLI_COLORS.green + "  █████████████████████████████████████████████████" + CLI_COLORS.reset);
        } else {
            CLI_warning("Some issues detected (" + checks_passed + "/" + checks_total + " checks passed)");
            console.log("");
            CLI_info("Run 'omni setup' to fix missing components");
        }
    }
}

// ============================================================================
// AST PARITY VERIFICATION
// ============================================================================

fn verify_package_parity(package_path: string) -> bool {
    let is_valid = true;
    
    native "js" {
        const fs = require('fs');
        const path = require('path');
        
        if (!fs.existsSync(package_path)) {
            CLI_error("Package not found: " + package_path);
            is_valid = false;
            return;
        }
        
        try {
            const content = JSON.parse(fs.readFileSync(package_path, 'utf-8'));
            
            // Required fields for targets
            const requiredFields = ['name', 'templates'];
            for (const field of requiredFields) {
                if (!content[field]) {
                    CLI_error("Missing required field: " + field);
                    is_valid = false;
                }
            }
            
            // Check template completeness
            const requiredTemplates = ['let_decl', 'fn_decl', 'if_stmt', 'return_stmt'];
            const templates = content.templates || {};
            
            for (const tmpl of requiredTemplates) {
                if (!templates[tmpl]) {
                    CLI_warning("Missing template: " + tmpl);
                    // Not fatal, just warning
                }
            }
            
            if (is_valid) {
                CLI_success("Package parity verified: " + content.name);
            }
            
        } catch (e) {
            CLI_error("Invalid JSON: " + e.message);
            is_valid = false;
        }
    }
    
    return is_valid;
}

// ============================================================================
// EXPORTS
// ============================================================================

export Package;
export PackageRegistry;
export PackageRegistry_new;
export PackageRegistry_save;
export PackageRegistry_list;
export cmd_install;
export cmd_uninstall;
export cmd_list_packages;
export cmd_doctor;
export verify_package_parity;

