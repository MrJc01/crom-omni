// Token Types
let TOKEN_EOF = 0;
let TOKEN_ILLEGAL = 1;

// Identifiers + Literals
let TOKEN_IDENTIFIER = 10;
let TOKEN_INT = 11;
let TOKEN_STRING = 12;

// Operators
let TOKEN_ASSIGN = 20;
let TOKEN_PLUS = 21;
let TOKEN_MINUS = 22;
let TOKEN_BANG = 23;
let TOKEN_ASTERISK = 24;
let TOKEN_SLASH = 25;
let TOKEN_LT = 26;
let TOKEN_GT = 27;
let TOKEN_EQ = 28;
let TOKEN_NOT_EQ = 29;

// Delimiters
let TOKEN_COLON = 30;
let TOKEN_DOT = 31;
let TOKEN_AND = 32;
let TOKEN_OR = 33;
let TOKEN_LE = 34; // <=
let TOKEN_GE = 35; // >=
let TOKEN_COMMA = 40;
let TOKEN_SEMICOLON = 41;
let TOKEN_LPAREN = 42;
let TOKEN_RPAREN = 43;
let TOKEN_LBRACE = 44;
let TOKEN_RBRACE = 45;
let TOKEN_LBRACKET = 46;
let TOKEN_RBRACKET = 47;

// Keywords
let TOKEN_FN = 60;
let TOKEN_LET = 61;
let TOKEN_TRUE = 62;
let TOKEN_FALSE = 63;
let TOKEN_IF = 64;
let TOKEN_ELSE = 65;
let TOKEN_RETURN = 66;
let TOKEN_WHILE = 67;
let TOKEN_STRUCT = 70;
let TOKEN_NATIVE = 80;
let TOKEN_IMPORT = 90;
let TOKEN_PACKAGE = 91;
let TOKEN_EXPORT = 92;
let TOKEN_AT = 95; // @

struct Token {
    kind: i64,
    lexeme: string,
    line: i64,
    start: i64,
    end: i64
}

fn new_token(kind: i64, lexeme: string, line: i64) -> Token {
    return Token {
        kind: kind,
        lexeme: lexeme,
        line: line,
        start: 0,
        end: 0
    };
}
