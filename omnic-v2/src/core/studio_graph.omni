// ============================================================================
// OMNI STUDIO GRAPH - Visual Programming Core
// Bidirectional AST <-> VisualGraph conversion engine
// ============================================================================

import "core/ast.omni";
import "lib/cli.omni";

// ============================================================================
// VISUAL NODE STRUCTURES
// ============================================================================

struct VisualNode {
    id: string,
    type: string,           // "capsule", "flow", "function", "entity", "let", "if", "while", "call"
    name: string,
    x: f64,
    y: f64,
    width: f64,
    height: f64,
    ports_in: any,
    ports_out: any,
    attributes: any,
    properties: any,
    parent_id: string,      // For nested nodes (flows inside capsules)
    ast_kind: i64,
    ast_line: i64
}

struct VisualEdge {
    id: string,
    source_node: string,
    source_port: string,
    target_node: string,
    target_port: string,
    edge_type: string       // "execution", "data", "dependency"
}

struct VisualGraph {
    nodes: any,
    edges: any,
    viewport: any,
    metadata: any
}

// ============================================================================
// AST -> VISUAL GRAPH CONVERTER
// ============================================================================

fn VisualGraph_new() -> VisualGraph {
    return VisualGraph {
        nodes: [],
        edges: [],
        viewport: { x: 0, y: 0, zoom: 1.0 },
        metadata: { version: "1.0", generated: "" }
    };
}

fn ast_to_graph(program: any) -> VisualGraph {
    let graph = VisualGraph_new();
    
    native "js" {
        if (!program || !program.statements) {
            console.error("[graph] Invalid program AST");
            return;
        }
        
        graph.metadata.generated = new Date().toISOString();
        
        let nodeId = 0;
        let edgeId = 0;
        let y = 50;
        const NODE_HEIGHT = 80;
        const NODE_WIDTH = 200;
        const CAPSULE_PADDING = 40;
        
        // Helper to create node
        const createNode = (type, name, x, y, astKind, astLine, parentId = null) => {
            return {
                id: 'node_' + (++nodeId),
                type: type,
                name: name,
                x: x,
                y: y,
                width: NODE_WIDTH,
                height: NODE_HEIGHT,
                ports_in: [],
                ports_out: [],
                attributes: [],
                properties: {},
                parent_id: parentId,
                ast_kind: astKind,
                ast_line: astLine || 0
            };
        };
        
        // Helper to create edge
        const createEdge = (srcNode, srcPort, tgtNode, tgtPort, type) => {
            return {
                id: 'edge_' + (++edgeId),
                source_node: srcNode,
                source_port: srcPort,
                target_node: tgtNode,
                target_port: tgtPort,
                edge_type: type
            };
        };
        
        // Process each statement
        for (const stmt of program.statements) {
            // Import
            if (stmt.kind === 10) { // NODE_IMPORT
                const node = createNode('import', stmt.path || stmt.value, 50, y, 10, stmt.line);
                node.width = 150;
                node.height = 40;
                graph.nodes.push(node);
                y += 60;
                continue;
            }
            
            // Struct / Entity
            if (stmt.kind === 70) { // NODE_STRUCT
                const isEntity = (stmt.attributes || []).some(a => a.name === 'entity');
                const node = createNode(isEntity ? 'entity' : 'struct', stmt.name, 400, y, 70, stmt.line);
                
                // Add fields as ports
                for (const field of (stmt.fields || [])) {
                    const fieldName = typeof field === 'string' ? field : field.name;
                    const fieldType = typeof field === 'object' ? field.type : 'any';
                    node.ports_out.push({
                        id: 'port_' + (++nodeId),
                        name: fieldName,
                        type: fieldType
                    });
                }
                
                node.attributes = stmt.attributes || [];
                node.height = Math.max(NODE_HEIGHT, 40 + node.ports_out.length * 25);
                graph.nodes.push(node);
                y += node.height + 30;
                continue;
            }
            
            // Capsule
            if (stmt.kind === 93) { // NODE_CAPSULE
                const capsuleNode = createNode('capsule', stmt.name, 50, y, 93, stmt.line);
                capsuleNode.width = 350;
                
                let innerY = y + CAPSULE_PADDING;
                const flowNodes = [];
                
                // Process flows inside capsule
                for (const flow of (stmt.flows || [])) {
                    const flowNode = createNode('flow', flow.name, 70, innerY, 94, flow.line, capsuleNode.id);
                    flowNode.width = 280;
                    
                    // Input ports (params)
                    for (const param of (flow.params || [])) {
                        const paramName = typeof param === 'string' ? param : param.name;
                        const paramType = typeof param === 'object' ? param.type : 'any';
                        flowNode.ports_in.push({
                            id: 'port_' + (++nodeId),
                            name: paramName,
                            type: paramType
                        });
                    }
                    
                    // Output port (return)
                    flowNode.ports_out.push({
                        id: 'port_' + (++nodeId),
                        name: 'return',
                        type: flow.return_type || 'void'
                    });
                    
                    flowNode.attributes = flow.attributes || [];
                    flowNode.height = Math.max(60, 30 + Math.max(flowNode.ports_in.length, 1) * 25);
                    
                    graph.nodes.push(flowNode);
                    flowNodes.push(flowNode);
                    innerY += flowNode.height + 20;
                }
                
                // Set capsule height to contain all flows
                capsuleNode.height = innerY - y + CAPSULE_PADDING;
                graph.nodes.push(capsuleNode);
                
                // Create execution edges between flows
                for (let i = 0; i < flowNodes.length - 1; i++) {
                    const edge = createEdge(
                        flowNodes[i].id, 'exec_out',
                        flowNodes[i + 1].id, 'exec_in',
                        'execution'
                    );
                    graph.edges.push(edge);
                }
                
                y += capsuleNode.height + 50;
                continue;
            }
            
            // Function
            if (stmt.kind === 4) { // NODE_FUNCTION
                const node = createNode('function', stmt.name, 50, y, 4, stmt.line);
                
                // Input ports (params)
                for (const param of (stmt.params || [])) {
                    const paramName = typeof param === 'string' ? param : param.name;
                    const paramType = typeof param === 'object' ? param.type : 'any';
                    node.ports_in.push({
                        id: 'port_' + (++nodeId),
                        name: paramName,
                        type: paramType
                    });
                }
                
                // Output port (return)
                node.ports_out.push({
                    id: 'port_' + (++nodeId),
                    name: 'return',
                    type: stmt.return_type || 'void'
                });
                
                node.height = Math.max(NODE_HEIGHT, 40 + Math.max(node.ports_in.length, 1) * 25);
                graph.nodes.push(node);
                y += node.height + 30;
                continue;
            }
        }
    }
    
    return graph;
}

// ============================================================================
// VISUAL GRAPH -> AST CONVERTER
// ============================================================================

fn graph_to_ast(graph: VisualGraph) -> any {
    let program = {};
    
    native "js" {
        program = {
            kind: 1, // NODE_PROGRAM
            statements: []
        };
        
        // Sort nodes by y position for correct order
        const sortedNodes = [...graph.nodes].sort((a, b) => a.y - b.y);
        
        // Group child nodes by parent
        const childrenMap = {};
        for (const node of sortedNodes) {
            if (node.parent_id) {
                if (!childrenMap[node.parent_id]) {
                    childrenMap[node.parent_id] = [];
                }
                childrenMap[node.parent_id].push(node);
            }
        }
        
        // Process top-level nodes only
        for (const node of sortedNodes) {
            if (node.parent_id) continue; // Skip children, processed with parent
            
            // Import
            if (node.type === 'import') {
                program.statements.push({
                    kind: 10,
                    path: node.name,
                    line: node.ast_line
                });
                continue;
            }
            
            // Struct / Entity
            if (node.type === 'struct' || node.type === 'entity') {
                const stmt = {
                    kind: 70,
                    name: node.name,
                    fields: node.ports_out.map(p => ({ name: p.name, type: p.type })),
                    attributes: node.type === 'entity' ? [{ name: 'entity' }] : [],
                    line: node.ast_line
                };
                program.statements.push(stmt);
                continue;
            }
            
            // Capsule
            if (node.type === 'capsule') {
                const flows = (childrenMap[node.id] || [])
                    .filter(n => n.type === 'flow')
                    .sort((a, b) => a.y - b.y)
                    .map(flowNode => ({
                        kind: 94,
                        name: flowNode.name,
                        params: flowNode.ports_in.map(p => ({ name: p.name, type: p.type })),
                        return_type: flowNode.ports_out[0]?.type || 'void',
                        attributes: flowNode.attributes,
                        body: { statements: [] },
                        line: flowNode.ast_line
                    }));
                
                program.statements.push({
                    kind: 93,
                    name: node.name,
                    flows: flows,
                    attributes: node.attributes,
                    line: node.ast_line
                });
                continue;
            }
            
            // Function
            if (node.type === 'function') {
                program.statements.push({
                    kind: 4,
                    name: node.name,
                    params: node.ports_in.map(p => ({ name: p.name, type: p.type })),
                    return_type: node.ports_out[0]?.type || 'void',
                    body: { statements: [] },
                    line: node.ast_line
                });
                continue;
            }
        }
    }
    
    return program;
}

// ============================================================================
// CODE GENERATION FROM GRAPH
// ============================================================================

fn graph_to_code(graph: VisualGraph) -> string {
    let code = "";
    
    native "js" {
        const lines = [];
        lines.push("// Generated by Omni Studio Visual Editor");
        lines.push("// " + new Date().toISOString());
        lines.push("");
        
        // Sort nodes by y position
        const sortedNodes = [...graph.nodes].sort((a, b) => a.y - b.y);
        
        // Group children by parent
        const childrenMap = {};
        for (const node of sortedNodes) {
            if (node.parent_id) {
                if (!childrenMap[node.parent_id]) {
                    childrenMap[node.parent_id] = [];
                }
                childrenMap[node.parent_id].push(node);
            }
        }
        
        // Generate code for each top-level node
        for (const node of sortedNodes) {
            if (node.parent_id) continue;
            
            // Position comment (for round-trip)
            lines.push(`// @visual:position(${Math.round(node.x)}, ${Math.round(node.y)})`);
            
            // Import
            if (node.type === 'import') {
                lines.push(`import "${node.name}";`);
                lines.push("");
                continue;
            }
            
            // Entity / Struct
            if (node.type === 'entity' || node.type === 'struct') {
                if (node.type === 'entity') {
                    lines.push('@entity');
                }
                lines.push(`struct ${node.name} {`);
                for (const port of node.ports_out) {
                    lines.push(`    ${port.name}: ${port.type},`);
                }
                lines.push('}');
                lines.push("");
                continue;
            }
            
            // Capsule
            if (node.type === 'capsule') {
                lines.push(`capsule ${node.name} {`);
                
                const children = (childrenMap[node.id] || []).sort((a, b) => a.y - b.y);
                for (const child of children) {
                    if (child.type === 'flow') {
                        // Position comment
                        lines.push(`    // @visual:position(${Math.round(child.x)}, ${Math.round(child.y)})`);
                        
                        // Attributes
                        for (const attr of (child.attributes || [])) {
                            if (attr.name) {
                                const args = (attr.args || []).map(a => `"${a}"`).join(', ');
                                lines.push(`    @${attr.name}${args ? '(' + args + ')' : ''}`);
                            }
                        }
                        
                        // Flow signature
                        const params = child.ports_in.map(p => `${p.name}: ${p.type}`).join(', ');
                        const returnType = child.ports_out[0]?.type || 'void';
                        const returnStr = returnType !== 'void' ? ` -> ${returnType}` : '';
                        
                        lines.push(`    flow ${child.name}(${params})${returnStr} {`);
                        lines.push(`        // TODO: Implement`);
                        lines.push(`    }`);
                        lines.push("");
                    }
                }
                
                lines.push('}');
                lines.push("");
                continue;
            }
            
            // Function
            if (node.type === 'function') {
                const params = node.ports_in.map(p => `${p.name}: ${p.type}`).join(', ');
                const returnType = node.ports_out[0]?.type || 'void';
                const returnStr = returnType !== 'void' ? ` -> ${returnType}` : '';
                
                lines.push(`fn ${node.name}(${params})${returnStr} {`);
                lines.push(`    // TODO: Implement`);
                lines.push(`}`);
                lines.push("");
                continue;
            }
        }
        
        code = lines.join('\n');
    }
    
    return code;
}

// ============================================================================
// GRAPH JSON SERIALIZATION
// ============================================================================

fn graph_to_json(graph: VisualGraph) -> string {
    let json = "";
    native "js" {
        json = JSON.stringify(graph, null, 2);
    }
    return json;
}

fn json_to_graph(json: string) -> VisualGraph {
    let graph = VisualGraph_new();
    native "js" {
        try {
            const parsed = JSON.parse(json);
            graph.nodes = parsed.nodes || [];
            graph.edges = parsed.edges || [];
            graph.viewport = parsed.viewport || { x: 0, y: 0, zoom: 1.0 };
            graph.metadata = parsed.metadata || {};
        } catch (e) {
            console.error("[graph] Failed to parse JSON: " + e.message);
        }
    }
    return graph;
}

// ============================================================================
// GRAPH MANIPULATION
// ============================================================================

fn graph_add_node(graph: VisualGraph, node_type: string, name: string, x: f64, y: f64) -> string {
    let new_id = "";
    
    native "js" {
        new_id = 'node_' + Date.now();
        
        const node = {
            id: new_id,
            type: node_type,
            name: name,
            x: x,
            y: y,
            width: 200,
            height: 80,
            ports_in: [],
            ports_out: [],
            attributes: [],
            properties: {},
            parent_id: null,
            ast_kind: 0,
            ast_line: 0
        };
        
        // Default ports based on type
        if (node_type === 'function' || node_type === 'flow') {
            node.ports_out.push({ id: 'port_ret_' + new_id, name: 'return', type: 'void' });
        }
        
        graph.nodes.push(node);
    }
    
    return new_id;
}

fn graph_remove_node(graph: VisualGraph, node_id: string) {
    native "js" {
        // Remove node
        graph.nodes = graph.nodes.filter(n => n.id !== node_id);
        
        // Remove connected edges
        graph.edges = graph.edges.filter(e => 
            e.source_node !== node_id && e.target_node !== node_id
        );
        
        // Remove children
        graph.nodes = graph.nodes.filter(n => n.parent_id !== node_id);
    }
}

fn graph_move_node(graph: VisualGraph, node_id: string, x: f64, y: f64) {
    native "js" {
        const node = graph.nodes.find(n => n.id === node_id);
        if (node) {
            const dx = x - node.x;
            const dy = y - node.y;
            node.x = x;
            node.y = y;
            
            // Move children too
            for (const child of graph.nodes) {
                if (child.parent_id === node_id) {
                    child.x += dx;
                    child.y += dy;
                }
            }
        }
    }
}

fn graph_add_edge(graph: VisualGraph, src_node: string, src_port: string, tgt_node: string, tgt_port: string) -> string {
    let new_id = "";
    
    native "js" {
        new_id = 'edge_' + Date.now();
        
        graph.edges.push({
            id: new_id,
            source_node: src_node,
            source_port: src_port,
            target_node: tgt_node,
            target_port: tgt_port,
            edge_type: 'data'
        });
    }
    
    return new_id;
}

fn graph_remove_edge(graph: VisualGraph, edge_id: string) {
    native "js" {
        graph.edges = graph.edges.filter(e => e.id !== edge_id);
    }
}

// ============================================================================
// EXPORTS
// ============================================================================

export VisualNode;
export VisualEdge;
export VisualGraph;
export VisualGraph_new;
export ast_to_graph;
export graph_to_ast;
export graph_to_code;
export graph_to_json;
export json_to_graph;
export graph_add_node;
export graph_remove_node;
export graph_move_node;
export graph_add_edge;
export graph_remove_edge;
