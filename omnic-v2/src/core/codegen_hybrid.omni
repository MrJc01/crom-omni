// ============================================================================
// HYBRID METAMORPHOSIS CODE GENERATOR
// Uses LanguageProfile templates for atomic syntax + Omni logic for structures
// ============================================================================

import "ast.omni";
import "token.omni";

// ============================================================================
// LANGUAGE PROFILE - Loads templates from targets/*.json
// ============================================================================

struct LanguageProfile {
    name: string,
    extension: string,
    templates: any,
    type_map: any,
    operators: any,
    indent_str: string,
    statement_end: string,
    loaded: bool
}

fn new_map() -> any {
    native "js" { return {}; }
    return 0;
}

fn LanguageProfile_new(name: string) -> LanguageProfile {
    return LanguageProfile {
        name: name,
        extension: ".txt",
        templates: new_map(),
        type_map: new_map(),
        operators: new_map(),
        indent_str: "    ",
        statement_end: ";",
        loaded: false
    };
}

fn LanguageProfile_load(self: LanguageProfile) -> LanguageProfile {
    native "js" {
        const impl = require ('./codegen_hybrid_impl.js');
        return impl.LanguageProfile_load_impl(self);
    }
    return self;
}

fn LanguageProfile_render(self: LanguageProfile, template_name: string, data: any) -> string {
    let result = "";
    native "js" {
        const impl = require ('./codegen_hybrid_impl.js');
        result = impl.LanguageProfile_render_impl(self, template_name, data);
    }
    return result;
}

fn LanguageProfile_map_type(self: LanguageProfile, omni_type: string) -> string {
    let result = omni_type;
    native "js" {
        result = self.type_map[omni_type] || omni_type;
    }
    return result;
}

fn LanguageProfile_map_operator(self: LanguageProfile, op: string) -> string {
    let result = op;
    native "js" {
        const impl = require ('./codegen_hybrid_impl.js');
        result = impl.LanguageProfile_map_operator_impl(self, op);
    }
    return result;
}

// ============================================================================
// HYBRID CODE GENERATOR
// ============================================================================

struct HybridCodeGenerator {
    profile: LanguageProfile,
    indent_level: i64,
    exports: any,
    ast_node_count: i64,
    generated_count: i64
}

fn HybridCodeGenerator_new(target: string) -> HybridCodeGenerator {
    let profile = LanguageProfile_new(target);
    profile = LanguageProfile_load(profile);
    
    return HybridCodeGenerator {
        profile: profile,
        indent_level: 0,
        exports: [],
        ast_node_count: 0,
        generated_count: 0
    };
}

fn HybridCodeGenerator_indent(self: HybridCodeGenerator, code: string) -> string {
    let result = "";
    native "js" {
        const impl = require ('./codegen_hybrid_impl.js');
        result = impl.HybridCodeGenerator_indent_impl(self, code);
    }
    return result;
}

fn HybridCodeGenerator_generate(self: HybridCodeGenerator, program: Program) -> string {
    let output = "";
    
    // Add program header
    output = LanguageProfile_render(self.profile, "program_header", {});
    
    native "js" {
        self.exports = [];
        self.ast_node_count = 0;
        self.generated_count = 0;
        
        if (program && program.statements) {
            for (const stmt of program.statements) {
                self.ast_node_count++;
                const code = HybridCodeGenerator_gen_statement(self, stmt);
                if (code) {
                    output += code + "\n";
                    self.generated_count++;
                }
            }
        }
        
        // Auto-exports
        if (self.exports.length > 0) {
            if (self.profile.name === "python") {
                output += "\n__all__ = [" + self.exports.map(e => '"' + e + '"').join(', ') + "]\n";
            } else {
                output += "\nmodule.exports = { " + self.exports.join(", ") + " };\n";
            }
        }

        // Auto-main execution
        var nl = String.fromCharCode(10);
        if (self.profile.name === "python") {
                output += nl + "if __name__ == '__main__':" + nl + "    if 'main' in globals():" + nl + "        main()" + nl;
        } else {
                output += nl + "if (typeof main === 'function') { main(); }" + nl;
        }
        
        // AST Parity Validation
        const coverage = self.ast_node_count > 0 ? 
            (self.generated_count / self.ast_node_count * 100).toFixed(1) : 100;
        if (coverage < 100) {
            console.warn("[codegen] AST coverage: " + coverage + "% (" + 
                self.generated_count + "/" + self.ast_node_count + " nodes)");
        }
    }
    
    return output;
}

fn HybridCodeGenerator_gen_statement(self: HybridCodeGenerator, stmt: any) -> string {
    // Import
    if (stmt.kind == NODE_IMPORT) {
        return HybridCodeGenerator_gen_import(self, stmt);
    }
    

    
    // Native block - emit only if matches target or is universal
    if (stmt.kind == NODE_NATIVE) {
        let result = "";
        native "js" {
            const impl = require ('./codegen_hybrid_impl.js');
            result = impl.check_native_lang(self, stmt);
        }
        return result;
    }
    
    // Let declaration - TEMPLATE BASED
    if (stmt.kind == NODE_LET) {
        let value = HybridCodeGenerator_gen_expression(self, stmt.value);
        let result = "";
        native "js" {
            const impl = require ('./codegen_hybrid_impl.js');
            result = impl.LanguageProfile_render_impl(self.profile, "let_decl", {
                name: stmt.name,
                value: value
            });
        }
        return result;
    }
    
    // Return statement - TEMPLATE BASED
    if (stmt.kind == NODE_RETURN) {
        let value = HybridCodeGenerator_gen_expression(self, stmt.value);
        let result = "";
        native "js" {
            const impl = require ('./codegen_hybrid_impl.js');
            result = impl.LanguageProfile_render_impl(self.profile, "return_stmt", {
                value: value
            });
        }
        return result;
    }
    
    // Function declaration - TEMPLATE BASED
    if (stmt.kind == NODE_FUNCTION) {
        let params = "";
        native "js" { params = stmt.params ? stmt.params.join(", ") : ""; }
        
        let saved_indent = self.indent_level;
        self.indent_level = 1;
        let body = HybridCodeGenerator_gen_block(self, stmt.body);
        self.indent_level = saved_indent;
        
        native "js" {
            self.exports.push(stmt.name);
        }
        
        let result = "";
        native "js" {
            const impl = require ('./codegen_hybrid_impl.js');
            result = impl.LanguageProfile_render_impl(self.profile, "fn_decl", {
                name: stmt.name,
                params: params,
                body: body
            });
        }
        return result;
    }
    
    // Struct/Class - HYBRID (Template + Omni Logic)
    if (stmt.kind == NODE_STRUCT) {
        return HybridCodeGenerator_gen_struct(self, stmt);
    }
    
    // If statement - TEMPLATE BASED
    if (stmt.kind == NODE_IF) {
        return HybridCodeGenerator_gen_if(self, stmt);
    }
    
    // While statement - TEMPLATE BASED
    if (stmt.kind == NODE_WHILE) {
        let cond = HybridCodeGenerator_gen_expression(self, stmt.condition);
        
        let saved_indent = self.indent_level;
        self.indent_level = 1;
        let body = HybridCodeGenerator_gen_block(self, stmt.body);
        self.indent_level = saved_indent;
        
        let result = "";
        native "js" {
            const impl = require ('./codegen_hybrid_impl.js');
            result = impl.LanguageProfile_render_impl(self.profile, "while_stmt", {
                condition: cond,
                body: body
            });
        }
        return result;
    }

    // For statement - Explicit Handling (No template in profile yet)
    if (stmt.kind == 19) {
         let iter = stmt.iterator;
         let col = HybridCodeGenerator_gen_expression(self, stmt.collection);
         
         let saved_indent = self.indent_level;
         self.indent_level = 1;
         let body = HybridCodeGenerator_gen_block(self, stmt.body);
         self.indent_level = saved_indent;
         
         let code = "";
         native "js" {
             if (self.profile.name === "python") {
                 code = "for " + iter + " in " + col + ":\n" + body;
             } else {
                 code = "for (const " + iter + " of " + col + ") {\n" + body + "}";
             }
         }
         return code;
    }
    
    // Capsule - HYBRID (Complex Omni Logic)
    if (stmt.kind == NODE_CAPSULE) {
        return HybridCodeGenerator_gen_capsule(self, stmt);
    }
    
    // Spawn - HYBRID
    if (stmt.kind == NODE_SPAWN) {
        return HybridCodeGenerator_gen_spawn(self, stmt);
    }
    
    // Interface
    if (stmt.kind == NODE_INTERFACE) {
        return HybridCodeGenerator_gen_interface(self, stmt);
    }
    
    // Assignment
    if (stmt.kind == NODE_ASSIGNMENT) {
        let left = HybridCodeGenerator_gen_expression(self, stmt.left);
        let right = HybridCodeGenerator_gen_expression(self, stmt.right);
        return left + " = " + right + self.profile.statement_end;
    }
    
    // Call as statement
    // Call as statement
    if (stmt.kind == NODE_CALL) {
        let callee = "";
        let function_node = 0;
        native "js" { function_node = stmt.function || stmt.callee || stmt.name; } // legacy check
        
        // If stmt.name is string (legacy), we handle it? 
        // Best to use recursive gen if node.
        
        if (function_node) {
             // Check if its a node (object) or string
             let is_node = false;
             native "js" { is_node = typeof function_node === "object"; }
             if (is_node) {
                callee = HybridCodeGenerator_gen_expression(self, function_node);
             } else {
                native "js" { callee = String(function_node); }
             }
        }

        let args = "";
        native "js" {
            if (stmt.args && stmt.args.length > 0) {
                args = stmt.args.map(a => HybridCodeGenerator_gen_expression(self, a)).join(', ');
            }
        }

        let result = "";
        native "js" {
            const impl = require ('./codegen_hybrid_impl.js');
            result = impl.LanguageProfile_render_impl(self.profile, "call_expr", {
                callee: callee,
                args: args
            });
        }
        return result + self.profile.statement_end;
    }

    // Expression Statement
    if (stmt.kind == 20) { // NODE_EXPRESSION_STMT
        // Hack: Force statement_end empty for Python
        native "js" {
            if (self.profile.name === 'python') self.profile.statement_end = '';
        }
    
        let expr = HybridCodeGenerator_gen_expression(self, stmt.expr);
        // Suppress empty statements (e.g. filtered native blocks or ghost nodes)
        if (expr == "") { return ""; }
        
        return expr + self.profile.statement_end;
    }
    
    let result = "";
    native "js" { result = "// Unknown stmt kind: " + stmt.kind; }
    return result;
}

fn HybridCodeGenerator_gen_expression(self: HybridCodeGenerator, expr: any) -> string {
    let is_null = false;
    native "js" { is_null = !expr; }
    if (is_null) return "";
    
    if (expr.kind == NODE_NATIVE) {
        let result = "";
        native "js" {
            const impl = require ('./codegen_hybrid_impl.js');
            // Check if lang matches
            let code = impl.check_native_lang(self, expr);
            if (code) {
                // Wrap in IIFE for expression context
                result = "(() => { " + code + " })()";
            } else {
                result = "null"; // Fallback for wrong target
            }
        }
        return result;
    }

    // Literal number
    if (expr.kind == NODE_LITERAL) {
        let val = "";
        native "js" { 
            val = String(expr.value);
            // Map booleans
            if (val === "true") val = self.profile.templates.bool_true || "true";
            if (val === "false") val = self.profile.templates.bool_false || "false";
            if (val === "null") val = self.profile.templates.null || "null";
        }
        return val;
    }
    
    // Unary Expression
    if (expr.kind == NODE_UNARY) {
        let op = expr.op;
        let operand = HybridCodeGenerator_gen_expression(self, expr.operand);
        // Special mapping for NOT
        if (op == "!") {
             native "js" { 
                 if (self.profile.operators && self.profile.operators.not) op = self.profile.operators.not;
                 else op = "!";
             }
        }
        return op + operand;
    }

    // Assignment Expression
    if (expr.kind == NODE_ASSIGNMENT) {
        let left = HybridCodeGenerator_gen_expression(self, expr.left);
        let right = HybridCodeGenerator_gen_expression(self, expr.right);
        return left + " = " + right;
    }
    
    // String
    if (expr.kind == NODE_STRING) {
        let result = "";
        native "js" { result = JSON.stringify(expr.value); }
        return result;
    }
    
    // Boolean
    if (expr.kind == NODE_BOOL) {
        let result = "";
        native "js" {
            const impl = require ('./codegen_hybrid_impl.js');
            result = impl.gen_expression_bool(self, expr);
        }
        return result;
    }
    
    // Identifier
    if (expr.kind == NODE_IDENTIFIER) {
        let result = "";
        native "js" { result = expr.value || expr.name || ''; }
        if (result == "print") {
             let is_js = false;
             native "js" { is_js = self.profile.name !== "python"; }
             if (is_js) return "console.log";
        }
        return result;
    }
    
    // Binary expression - TEMPLATE BASED
    if (expr.kind == NODE_BINARY) {
        let left = HybridCodeGenerator_gen_expression(self, expr.left);
        let right = HybridCodeGenerator_gen_expression(self, expr.right);
        let op = LanguageProfile_map_operator(self.profile, expr.op);
        
        let result = "";
        native "js" {
            const impl = require ('./codegen_hybrid_impl.js');
            result = impl.LanguageProfile_render_impl(self.profile, "binary_expr", {
                left: left,
                op: op,
                right: right
            });
        }
        return result;
    }
    
    // Call expression - TEMPLATE BASED
    if (expr.kind == NODE_CALL) {
        let callee = "";
        let function_node = 0;
        
        native "js" {
             function_node = expr.function || expr.callee;
        }
        
        if (function_node) {
             callee = HybridCodeGenerator_gen_expression(self, function_node);
        }
        
        let args = "";
        native "js" {
            if (expr.args) {
                args = expr.args.map(a => HybridCodeGenerator_gen_expression(self, a)).join(', ');
            }
        }
        
        let result = "";
        native "js" {
            const impl = require ('./codegen_hybrid_impl.js');
            result = impl.LanguageProfile_render_impl(self.profile, "call_expr", {
                callee: callee,
                args: args
            });
        }
        return result;
    }
    
    // Member access
    if (expr.kind == NODE_MEMBER) { // 9
        let obj = HybridCodeGenerator_gen_expression(self, expr.target);
        return obj + "." + expr.property;
    }
    
    // Array literal
    if (expr.kind == NODE_ARRAY) {
        let elements = "";
        native "js" {
            if (expr.elements) {
                elements = expr.elements.map(e => HybridCodeGenerator_gen_expression(self, e)).join(', ');
            }
        }
        return "[" + elements + "]";
    }
    
    // Struct initialization
    if (expr.kind == NODE_STRUCT_INIT) {
        let fields = "";
        let is_python = false;
        native "js" { is_python = self.profile.name === "python"; }
        
        native "js" {
            if (expr.fields && Array.isArray(expr.fields)) {
                if (is_python) {
                    fields = expr.fields.map(f => "'" + f.name + "': " + HybridCodeGenerator_gen_expression(self, f.value)).join(', ');
                } else {
                    fields = expr.fields.map(f => f.name + ": " + HybridCodeGenerator_gen_expression(self, f.value)).join(', ');
                }
            }
        }
        
        if (is_python) {
             return expr.name + "({ " + fields + " })";
        } else {
             return "new " + expr.name + "({ " + fields + " })";
        }
    }
    
    let result = "";
    native "js" { result = String(expr.value || expr.name || ''); }
    return result;
}

fn HybridCodeGenerator_gen_block(self: HybridCodeGenerator, body: any) -> string {
    let result = "";
    native "js" {
        if (!body) return '';
        const statements = Array.isArray(body) ? body : (body.statements || []);
        if (!Array.isArray(statements)) return '';
        result = statements.map(s => {
            const code = HybridCodeGenerator_gen_statement(self, s);
            return HybridCodeGenerator_indent(self, code);
        }).join('\n');
        
        // Python requires 'pass' for empty blocks
        if (self.profile.name === 'python' && (!result || result.trim() === '')) {
            result = HybridCodeGenerator_indent(self, 'pass');
        }
    }
    return result;
    return result;
}

fn HybridCodeGenerator_gen_if(self: HybridCodeGenerator, stmt: any) -> string {
    let cond = HybridCodeGenerator_gen_expression(self, stmt.condition);
    
    let saved_indent = self.indent_level;
    self.indent_level = 1;
    let consequence = HybridCodeGenerator_gen_block(self, stmt.consequence);
    self.indent_level = saved_indent;
    
    let has_alt = false;
    native "js" { 
        // Check for both array and Block object formats
        has_alt = stmt.alternative && (
            (Array.isArray(stmt.alternative) && stmt.alternative.length > 0) ||
            (stmt.alternative.statements && stmt.alternative.statements.length > 0) ||
            (stmt.alternative.kind) // Any AST node (e.g., Block, IfStmt)
        ); 
    }
    
    if (has_alt) {
        let saved_alt_indent = self.indent_level;
        self.indent_level = 1;
        let alternative = HybridCodeGenerator_gen_block(self, stmt.alternative);
        self.indent_level = saved_alt_indent;
        
        let result = "";
        native "js" {
            const impl = require ('./codegen_hybrid_impl.js');
            result = impl.LanguageProfile_render_impl(self.profile, "if_else_stmt", {
                condition: cond,
                consequence: consequence,
                alternative: alternative
            });
        }
        return result;
    }
    
    let result = "";
    native "js" {
        const impl = require ('./codegen_hybrid_impl.js');
        result = impl.LanguageProfile_render_impl(self.profile, "if_stmt", {
            condition: cond,
            consequence: consequence
        });
    }
    return result;
}

// ============================================================================
// HYBRID ARCHITECTURE GENERATORS (Complex Omni Logic)
// ============================================================================

fn HybridCodeGenerator_gen_struct(self: HybridCodeGenerator, stmt: any) -> string {
    // Check for @entity attribute
    let is_entity = false;
    native "js" {
        is_entity = stmt.attributes && stmt.attributes.some(a => a.name === 'entity');
    }
    
    // Generate class body
    let constructor_body = "";
    native "js" { {
        const impl = require ('./codegen_hybrid_impl.js');
        constructor_body = impl.gen_struct_body(stmt);
    } }
    
    let class_body = "";
    native "js" {
        if (self.profile.name === "python") {
            class_body = "    def __init__(self, data={}):\n" + constructor_body;
        } else {
            class_body = "    constructor(data = {}) {\n" + constructor_body + "    }\n";
        }
    }
    
    let out = "";
    native "js" { {
        const impl = require ('./codegen_hybrid_impl.js');
        out = impl.LanguageProfile_render_impl(self.profile, "class_decl", {
            name: stmt.name,
            body: class_body
        });
    } }
    
    // If @entity, add repository methods (HYBRID - Omni controls logic)
    if (is_entity) {
        out = out + HybridCodeGenerator_gen_entity_repo(self, stmt);
    }
    
    return out;
}

fn HybridCodeGenerator_gen_entity_repo(self: HybridCodeGenerator, stmt: any) -> string {
    let result = "";
    native "js" {
        const impl = require ('./codegen_hybrid_impl.js');
        result = impl.gen_entity_repo(stmt);
    }
    return result;
}

fn HybridCodeGenerator_gen_capsule(self: HybridCodeGenerator, stmt: any) -> string {
    let name = stmt.name;
    let result = "";
    
    native "js" {
        const is_python = self.profile.name === "python";
        
        if (is_python) {
            result = "class " + name + ":\n";
            if (!stmt.body || !stmt.body.statements || stmt.body.statements.length === 0) {
                result += "    pass\n";
            } else {
                for (const s of stmt.body.statements) {
                    // Let/Var -> Class Attribute
                    if (s.kind == 2 || s.kind == 61) {
                         let val = HybridCodeGenerator_gen_expression(self, s.value);
                         result += "    " + s.name + " = " + val + "\n";
                    }
                    // Function -> Static Method
                    if (s.kind == 4 || s.kind == 94) {
                        let params = s.params ? s.params.join(", ") : "";
                        
                        let saved_indent = self.indent_level;
                        self.indent_level = 2; // Methods inside Class need 2 levels (8 spaces)
                        let body = HybridCodeGenerator_gen_block(self, s.body);
                        self.indent_level = saved_indent;
                        
                        let method = "    @staticmethod\n    def " + s.name + "(" + params + "):\n" + body + "\n";
                        result += method;
                    }
                }
            }
        } else {
            // JavaScript Object
            let props = "";
            if (stmt.body && stmt.body.statements) {
                for (const s of stmt.body.statements) {
                    if (s.kind == 2 || s.kind == 61) { 
                        let val = HybridCodeGenerator_gen_expression(self, s.value);
                        props += "    " + s.name + ": " + val + ",\n";
                    }
                    if (s.kind == 4 || s.kind == 94) { 
                        let params = s.params ? s.params.join(", ") : "";
                        self.indent_level++;
                        let body = HybridCodeGenerator_gen_block(self, s.body);
                        self.indent_level--;
                        props += "    " + s.name + "(" + params + ") {\n" + body + "    },\n";
                    }
                }
            }
            result = "// Capsule: " + name + "\nconst " + name + " = {\n" + props + "\n};\n";
        }
    }
    return result;
}

fn HybridCodeGenerator_gen_spawn(self: HybridCodeGenerator, stmt: any) -> string {
    let fn_name = "";
    let args = "";
    
    native "js" {
        const call = stmt.call;
        fn_name = call?.name || call?.callee?.value || 'unknown';
        if (call?.args) {
            args = call.args.map(a => HybridCodeGenerator_gen_expression(self, a)).join(', ');
        }
    }
    
    let out = "";
    native "js" {
        const impl = require ('./codegen_hybrid_impl.js');
        out = impl.gen_spawn_code(fn_name, args);
    }
    
    return out;
}

fn HybridCodeGenerator_gen_import(self: HybridCodeGenerator, stmt: any) -> string {
    let result = "";
    native "js" {
        const impl = require ('./codegen_hybrid_impl.js');
        result = impl.gen_import(stmt);
    }
    return result;
}

fn HybridCodeGenerator_gen_interface(self: HybridCodeGenerator, stmt: any) -> string {
    let is_service = false;
    native "js" {
        is_service = stmt.attributes && stmt.attributes.some(a => a.name === 'service');
    }
    
    if (is_service) {
        return HybridCodeGenerator_gen_service_client(self, stmt);
    }
    
    return "// Interface: " + stmt.name;
}

fn HybridCodeGenerator_gen_service_client(self: HybridCodeGenerator, stmt: any) -> string {
    let result = "";
    native "js" {
        const impl = require ('./codegen_hybrid_impl.js');
        result = impl.gen_service_client(stmt);
    }
    return result;
}

// ============================================================================
// BACKWARD COMPATIBILITY - Legacy interface
// ============================================================================

fn new_code_generator(target: string) -> HybridCodeGenerator {
    return HybridCodeGenerator_new(target);
}

fn CodeGenerator_generate(self: HybridCodeGenerator, program: Program) -> string {
    return HybridCodeGenerator_generate(self, program);
}


