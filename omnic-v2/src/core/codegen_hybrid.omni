// ============================================================================
// HYBRID METAMORPHOSIS CODE GENERATOR
// Uses LanguageProfile templates for atomic syntax + Omni logic for structures
// ============================================================================

import "ast.omni";
import "token.omni";

// ============================================================================
// LANGUAGE PROFILE - Loads templates from targets/*.json
// ============================================================================

struct LanguageProfile {
    name: string,
    extension: string,
    templates: any,
    type_map: any,
    operators: any,
    indent_str: string,
    statement_end: string,
    loaded: bool
}

fn LanguageProfile_new(name: string) -> LanguageProfile {
    return LanguageProfile {
        name: name,
        extension: ".txt",
        templates: {},
        type_map: {},
        operators: {},
        indent_str: "    ",
        statement_end: ";",
        loaded: false
    };
}

fn LanguageProfile_load(self: LanguageProfile) -> LanguageProfile {
    native "js" {
        const fs = require('fs');
        const path = require('path');
        
        // Try multiple paths for profile
        const paths = [
            path.join(__dirname, '..', 'targets', self.name + '.json'),
            path.join(__dirname, '..', '..', 'targets', self.name + '.json'),
            path.join(process.cwd(), 'targets', self.name + '.json')
        ];
        
        let profile = null;
        for (const p of paths) {
            if (fs.existsSync(p)) {
                profile = JSON.parse(fs.readFileSync(p, 'utf-8'));
                break;
            }
        }
        
        if (profile) {
            self.extension = profile.extension || '.txt';
            self.templates = profile.templates || {};
            self.type_map = profile.type_map || {};
            self.operators = profile.operators || {};
            self.indent_str = profile.indent || '    ';
            self.statement_end = profile.statement_end || ';';
            self.loaded = true;
        } else {
            // Fallback defaults for JavaScript
            self.extension = '.js';
            self.templates = {
                program_header: "// Generated by Omni Compiler\n'use strict';\n\n",
                fn_decl: "function {name}({params}) {\n{body}\n}",
                let_decl: "let {name} = {value};",
                return_stmt: "return {value};",
                if_stmt: "if ({condition}) {\n{consequence}\n}",
                if_else_stmt: "if ({condition}) {\n{consequence}\n} else {\n{alternative}\n}",
                while_stmt: "while ({condition}) {\n{body}\n}",
                class_decl: "class {name} {\n{body}\n}",
                call_expr: "{callee}({args})",
                binary_expr: "{left} {op} {right}",
                bool_true: "true",
                bool_false: "false",
                null: "null"
            };
            self.type_map = { i64: "number", string: "string", bool: "boolean" };
            self.operators = { eq: "===", neq: "!==", and: "&&", or: "||" };
            self.loaded = true;
        }
    }
    return self;
}

fn LanguageProfile_render(self: LanguageProfile, template_name: string, data: any) -> string {
    let result = "";
    native "js" {
        const template = self.templates[template_name];
        if (!template) {
            result = "/* Template '" + template_name + "' not found */";
        } else {
            result = template.replace(/\{(\w+)\}/g, (_, key) => {
                return data.hasOwnProperty(key) ? data[key] : '';
            });
        }
    }
    return result;
}

fn LanguageProfile_map_type(self: LanguageProfile, omni_type: string) -> string {
    let result = omni_type;
    native "js" {
        result = self.type_map[omni_type] || omni_type;
    }
    return result;
}

fn LanguageProfile_map_operator(self: LanguageProfile, op: string) -> string {
    let result = op;
    native "js" {
        const opMap = { '==': 'eq', '!=': 'neq', '&&': 'and', '||': 'or', '<': 'lt', '>': 'gt' };
        const key = opMap[op];
        if (key && self.operators[key]) {
            result = self.operators[key];
        } else {
            result = op;
        }
    }
    return result;
}

// ============================================================================
// HYBRID CODE GENERATOR
// ============================================================================

struct HybridCodeGenerator {
    profile: LanguageProfile,
    indent_level: i64,
    exports: any,
    ast_node_count: i64,
    generated_count: i64
}

fn HybridCodeGenerator_new(target: string) -> HybridCodeGenerator {
    let profile = LanguageProfile_new(target);
    profile = LanguageProfile_load(profile);
    
    return HybridCodeGenerator {
        profile: profile,
        indent_level: 0,
        exports: [],
        ast_node_count: 0,
        generated_count: 0
    };
}

fn HybridCodeGenerator_indent(self: HybridCodeGenerator, code: string) -> string {
    let result = "";
    native "js" {
        const prefix = self.profile.indent_str.repeat(self.indent_level);
        result = code.split('\n').map(line => line ? prefix + line : line).join('\n');
    }
    return result;
}

fn HybridCodeGenerator_generate(self: HybridCodeGenerator, program: Program) -> string {
    let output = "";
    
    // Add program header
    output = LanguageProfile_render(self.profile, "program_header", {});
    
    native "js" {
        self.exports = [];
        self.ast_node_count = 0;
        self.generated_count = 0;
        
        if (program && program.statements) {
            for (const stmt of program.statements) {
                self.ast_node_count++;
                const code = HybridCodeGenerator_gen_statement(self, stmt);
                if (code) {
                    output += code + "\n";
                    self.generated_count++;
                }
            }
        }
        
        // Auto-exports
        if (self.exports.length > 0) {
            output += "\nmodule.exports = { " + self.exports.join(", ") + " };\n";
        }
        
        // AST Parity Validation
        const coverage = self.ast_node_count > 0 ? 
            (self.generated_count / self.ast_node_count * 100).toFixed(1) : 100;
        if (coverage < 100) {
            console.warn("[codegen] AST coverage: " + coverage + "% (" + 
                self.generated_count + "/" + self.ast_node_count + " nodes)");
        }
    }
    
    return output;
}

fn HybridCodeGenerator_gen_statement(self: HybridCodeGenerator, stmt: any) -> string {
    // Import
    if (stmt.kind == NODE_IMPORT) {
        return HybridCodeGenerator_gen_import(self, stmt);
    }
    
    // Native block - emit only if matches target or is universal
    if (stmt.kind == NODE_NATIVE) {
        let result = "";
        native "js" {
            const targetLang = self.profile.name;
            if (stmt.lang === 'js' || stmt.lang === 'javascript') {
                if (targetLang === 'js' || targetLang === 'javascript') {
                    result = stmt.code;
                }
            } else if (stmt.lang === 'py' || stmt.lang === 'python') {
                if (targetLang === 'python') {
                    result = stmt.code;
                }
            } else if (stmt.lang === targetLang) {
                result = stmt.code;
            }
        }
        return result;
    }
    
    // Let declaration - TEMPLATE BASED
    if (stmt.kind == NODE_LET) {
        let value = HybridCodeGenerator_gen_expression(self, stmt.value);
        return LanguageProfile_render(self.profile, "let_decl", {
            name: stmt.name,
            value: value
        });
    }
    
    // Return statement - TEMPLATE BASED
    if (stmt.kind == NODE_RETURN) {
        let value = HybridCodeGenerator_gen_expression(self, stmt.value);
        return LanguageProfile_render(self.profile, "return_stmt", {
            value: value
        });
    }
    
    // Function declaration - TEMPLATE BASED
    if (stmt.kind == NODE_FUNCTION) {
        let params = "";
        native "js" { params = stmt.params ? stmt.params.join(", ") : ""; }
        
        self.indent_level = self.indent_level + 1;
        let body = HybridCodeGenerator_gen_block(self, stmt.body);
        self.indent_level = self.indent_level - 1;
        
        native "js" {
            if (stmt.is_exported) self.exports.push(stmt.name);
        }
        
        return LanguageProfile_render(self.profile, "fn_decl", {
            name: stmt.name,
            params: params,
            body: body
        });
    }
    
    // Struct/Class - HYBRID (Template + Omni Logic)
    if (stmt.kind == NODE_STRUCT) {
        return HybridCodeGenerator_gen_struct(self, stmt);
    }
    
    // If statement - TEMPLATE BASED
    if (stmt.kind == NODE_IF) {
        return HybridCodeGenerator_gen_if(self, stmt);
    }
    
    // While statement - TEMPLATE BASED
    if (stmt.kind == NODE_WHILE) {
        let cond = HybridCodeGenerator_gen_expression(self, stmt.condition);
        
        self.indent_level = self.indent_level + 1;
        let body = HybridCodeGenerator_gen_block(self, stmt.body);
        self.indent_level = self.indent_level - 1;
        
        return LanguageProfile_render(self.profile, "while_stmt", {
            condition: cond,
            body: body
        });
    }
    
    // Capsule - HYBRID (Complex Omni Logic)
    if (stmt.kind == NODE_CAPSULE) {
        return HybridCodeGenerator_gen_capsule(self, stmt);
    }
    
    // Spawn - HYBRID
    if (stmt.kind == NODE_SPAWN) {
        return HybridCodeGenerator_gen_spawn(self, stmt);
    }
    
    // Interface
    if (stmt.kind == NODE_INTERFACE) {
        return HybridCodeGenerator_gen_interface(self, stmt);
    }
    
    // Assignment
    if (stmt.kind == NODE_ASSIGNMENT) {
        let value = HybridCodeGenerator_gen_expression(self, stmt.value);
        return stmt.name + " = " + value + self.profile.statement_end;
    }
    
    // Call as statement
    if (stmt.kind == NODE_CALL) {
        return HybridCodeGenerator_gen_expression(self, stmt) + self.profile.statement_end;
    }
    
    let result = "";
    native "js" { result = "// Unknown stmt kind: " + stmt.kind; }
    return result;
}

fn HybridCodeGenerator_gen_expression(self: HybridCodeGenerator, expr: any) -> string {
    if (expr == 0) return "";
    
    // Literal number
    if (expr.kind == NODE_LITERAL) {
        let val = "";
        native "js" { 
            val = String(expr.value);
            // Map booleans
            if (val === 'true') val = self.profile.templates.bool_true || 'true';
            if (val === 'false') val = self.profile.templates.bool_false || 'false';
            if (val === 'null') val = self.profile.templates.null || 'null';
        }
        return val;
    }
    
    // String
    if (expr.kind == NODE_STRING) {
        let result = "";
        native "js" { result = '"' + expr.value + '"'; }
        return result;
    }
    
    // Boolean
    if (expr.kind == NODE_BOOL) {
        let result = "";
        native "js" {
            result = expr.value ? 
                (self.profile.templates.bool_true || 'true') : 
                (self.profile.templates.bool_false || 'false');
        }
        return result;
    }
    
    // Identifier
    if (expr.kind == NODE_IDENTIFIER) {
        let result = "";
        native "js" { result = expr.value || expr.name || ''; }
        return result;
    }
    
    // Binary expression - TEMPLATE BASED
    if (expr.kind == NODE_BINARY) {
        let left = HybridCodeGenerator_gen_expression(self, expr.left);
        let right = HybridCodeGenerator_gen_expression(self, expr.right);
        let op = LanguageProfile_map_operator(self.profile, expr.op);
        
        return LanguageProfile_render(self.profile, "binary_expr", {
            left: left,
            op: op,
            right: right
        });
    }
    
    // Call expression - TEMPLATE BASED
    if (expr.kind == NODE_CALL) {
        let callee = "";
        let args = "";
        native "js" {
            callee = expr.name || (expr.callee ? expr.callee.value : '');
            if (expr.args) {
                args = expr.args.map(a => HybridCodeGenerator_gen_expression(self, a)).join(', ');
            }
        }
        
        return LanguageProfile_render(self.profile, "call_expr", {
            callee: callee,
            args: args
        });
    }
    
    // Member access
    if (expr.kind == NODE_MEMBER) {
        let obj = HybridCodeGenerator_gen_expression(self, expr.object);
        return obj + "." + expr.member;
    }
    
    // Array literal
    if (expr.kind == NODE_ARRAY) {
        let elements = "";
        native "js" {
            if (expr.elements) {
                elements = expr.elements.map(e => HybridCodeGenerator_gen_expression(self, e)).join(', ');
            }
        }
        return "[" + elements + "]";
    }
    
    // Struct initialization
    if (expr.kind == NODE_STRUCT_INIT) {
        let fields = "";
        native "js" {
            if (expr.fields) {
                fields = Object.entries(expr.fields)
                    .map(([k, v]) => k + ": " + HybridCodeGenerator_gen_expression(self, v))
                    .join(', ');
            }
        }
        return "new " + expr.name + "({ " + fields + " })";
    }
    
    let result = "";
    native "js" { result = String(expr.value || expr.name || ''); }
    return result;
}

fn HybridCodeGenerator_gen_block(self: HybridCodeGenerator, body: any) -> string {
    let result = "";
    native "js" {
        if (!body) return '';
        const statements = Array.isArray(body) ? body : (body.statements || []);
        if (!Array.isArray(statements)) return '';
        result = statements.map(s => {
            const code = HybridCodeGenerator_gen_statement(self, s);
            return HybridCodeGenerator_indent(self, code);
        }).join('\n');
    }
    return result;
}

fn HybridCodeGenerator_gen_if(self: HybridCodeGenerator, stmt: any) -> string {
    let cond = HybridCodeGenerator_gen_expression(self, stmt.condition);
    
    self.indent_level = self.indent_level + 1;
    let consequence = HybridCodeGenerator_gen_block(self, stmt.consequence);
    self.indent_level = self.indent_level - 1;
    
    let has_alt = false;
    native "js" { has_alt = stmt.alternative && stmt.alternative.length > 0; }
    
    if (has_alt) {
        self.indent_level = self.indent_level + 1;
        let alternative = HybridCodeGenerator_gen_block(self, stmt.alternative);
        self.indent_level = self.indent_level - 1;
        
        return LanguageProfile_render(self.profile, "if_else_stmt", {
            condition: cond,
            consequence: consequence,
            alternative: alternative
        });
    }
    
    return LanguageProfile_render(self.profile, "if_stmt", {
        condition: cond,
        consequence: consequence
    });
}

// ============================================================================
// HYBRID ARCHITECTURE GENERATORS (Complex Omni Logic)
// ============================================================================

fn HybridCodeGenerator_gen_struct(self: HybridCodeGenerator, stmt: any) -> string {
    // Check for @entity attribute
    let is_entity = false;
    native "js" {
        is_entity = stmt.attributes && stmt.attributes.some(a => a.name === 'entity');
    }
    
    // Generate class body
    let constructor_body = "";
    native "js" {
        for (const field of stmt.fields || []) {
            constructor_body += "        this." + field.name + " = data." + field.name + ";\n";
        }
    }
    
    let class_body = "    constructor(data = {}) {\n" + constructor_body + "    }\n";
    
    let out = LanguageProfile_render(self.profile, "class_decl", {
        name: stmt.name,
        body: class_body
    });
    
    // If @entity, add repository methods (HYBRID - Omni controls logic)
    if (is_entity) {
        out = out + HybridCodeGenerator_gen_entity_repo(self, stmt);
    }
    
    return out;
}

fn HybridCodeGenerator_gen_entity_repo(self: HybridCodeGenerator, stmt: any) -> string {
    let name = stmt.name;
    let field_names = "";
    
    native "js" {
        const fields = (stmt.fields || []).filter(f => f.name !== 'id').map(f => f.name);
        field_names = fields.join(', ');
    }
    
    let out = "\n// @entity Repository: " + name + "\n";
    out = out + name + ".find = async (id) => {\n";
    out = out + "    const db = await Database.get('main_db');\n";
    out = out + "    const row = await db.get('SELECT * FROM " + name + " WHERE id = ?', [id]);\n";
    out = out + "    return row ? new " + name + "(row) : null;\n";
    out = out + "};\n\n";
    
    out = out + name + ".all = async () => {\n";
    out = out + "    const db = await Database.get('main_db');\n";
    out = out + "    return (await db.all('SELECT * FROM " + name + "')).map(r => new " + name + "(r));\n";
    out = out + "};\n";
    
    return out;
}

fn HybridCodeGenerator_gen_capsule(self: HybridCodeGenerator, stmt: any) -> string {
    let name = stmt.name;
    let flows = "";
    let flow_list = "";
    
    native "js" {
        const flowDefs = stmt.flows || [];
        flow_list = flowDefs.map(f => "'" + f.name + "'").join(', ');
        
        for (const flow of flowDefs) {
            const params = flow.params.map(p => p.name).join(', ');
            const paramJson = flow.params.map(p => p.name + ": " + p.name).join(', ');
            
            flows += "    async " + flow.name + "(" + params + ") {\n";
            flows += "        const route = TopologyResolver.resolve('" + name + "');\n";
            flows += "        if (route.local) {\n";
            flows += "            return this._impl_" + flow.name + "(" + params + ");\n";
            flows += "        } else {\n";
            flows += "            const response = await fetch(route.url + '/" + name + "/" + flow.name + "', {\n";
            flows += "                method: 'POST',\n";
            flows += "                headers: { 'Content-Type': 'application/json' },\n";
            flows += "                body: JSON.stringify({ " + paramJson + " })\n";
            flows += "            });\n";
            flows += "            return await response.json();\n";
            flows += "        }\n";
            flows += "    },\n\n";
            
            flows += "    _impl_" + flow.name + "(" + params + ") {\n";
            flows += "        throw new Error('" + name + "." + flow.name + " not implemented');\n";
            flows += "    },\n\n";
        }
    }
    
    let out = "// Capsule: " + name + "\n";
    out = out + "const " + name + " = {\n";
    out = out + "    _name: '" + name + "',\n";
    out = out + "    _flows: [" + flow_list + "],\n\n";
    out = out + flows;
    out = out + "};\n";
    
    return out;
}

fn HybridCodeGenerator_gen_spawn(self: HybridCodeGenerator, stmt: any) -> string {
    let fn_name = "";
    let args = "";
    
    native "js" {
        const call = stmt.call;
        fn_name = call?.name || call?.callee?.value || 'unknown';
        if (call?.args) {
            args = call.args.map(a => HybridCodeGenerator_gen_expression(self, a)).join(', ');
        }
    }
    
    let out = "(() => {\n";
    out = out + "    const { Worker } = require('worker_threads');\n";
    out = out + "    const worker = new Worker(__filename, {\n";
    out = out + "        workerData: { fn: '" + fn_name + "', args: [" + args + "] }\n";
    out = out + "    });\n";
    out = out + "    worker.on('message', r => console.log('[spawn] " + fn_name + " done:', r));\n";
    out = out + "    worker.on('error', e => console.error('[spawn] " + fn_name + " error:', e));\n";
    out = out + "})()";
    
    return out;
}

fn HybridCodeGenerator_gen_import(self: HybridCodeGenerator, stmt: any) -> string {
    let module_path = "";
    let alias = "";
    
    native "js" {
        module_path = stmt.path || stmt.module || '';
        module_path = module_path.replace(/^['"]|['"]$/g, '');
        alias = stmt.alias || module_path.split('/').pop().replace('.omni', '');
    }
    
    return "const " + alias + " = require(\"" + module_path + "\");\n" +
           "if (typeof global !== 'undefined') Object.assign(global, " + alias + ");";
}

fn HybridCodeGenerator_gen_interface(self: HybridCodeGenerator, stmt: any) -> string {
    let is_service = false;
    native "js" {
        is_service = stmt.attributes && stmt.attributes.some(a => a.name === 'service');
    }
    
    if (is_service) {
        return HybridCodeGenerator_gen_service_client(self, stmt);
    }
    
    return "// Interface: " + stmt.name;
}

fn HybridCodeGenerator_gen_service_client(self: HybridCodeGenerator, stmt: any) -> string {
    let name = stmt.name;
    let methods = "";
    
    native "js" {
        for (const method of stmt.methods || []) {
            const params = method.params ? method.params.map(p => p.name).join(', ') : '';
            methods += "    async " + method.name + "(" + params + ") {\n";
            methods += "        const url = Discovery.resolve('" + name + "');\n";
            methods += "        const response = await fetch(url + '/" + name + "/" + method.name + "', {\n";
            methods += "            method: 'POST',\n";
            methods += "            headers: { 'Content-Type': 'application/json' },\n";
            methods += "            body: JSON.stringify({ " + params + " })\n";
            methods += "        });\n";
            methods += "        return await response.json();\n";
            methods += "    },\n";
        }
    }
    
    return "// @service RPC Client: " + name + "\n" +
           "const " + name + " = {\n" + methods + "};\n";
}

// ============================================================================
// BACKWARD COMPATIBILITY - Legacy interface
// ============================================================================

fn new_code_generator(target: string) -> HybridCodeGenerator {
    return HybridCodeGenerator_new(target);
}

fn CodeGenerator_generate(self: HybridCodeGenerator, program: Program) -> string {
    return HybridCodeGenerator_generate(self, program);
}

export HybridCodeGenerator;
export HybridCodeGenerator_new;
export HybridCodeGenerator_generate;
export LanguageProfile;
export new_code_generator;
export CodeGenerator_generate;
