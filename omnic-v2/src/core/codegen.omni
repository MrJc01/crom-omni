import "ast.omni";
import "token.omni";

struct CodeGenerator {
    target: string,
    indent: i64
}

fn new_code_generator(target: string) -> CodeGenerator {
    return CodeGenerator { target: target, indent: 0 };
}

fn CodeGenerator_generate(self: CodeGenerator, program: Program) -> string {
    if (self.target == "python") {
        return CodeGenerator_generate_python(self, program);
    }

    let output = "";
    native "js" {
        if (program && program.statements) {
            for (const stmt of program.statements) {
                output = output + CodeGenerator_gen_statement(self, stmt) + "\n";
            }
        }
    }
    
    // Auto-Export (JS)
    let exports = [];
    native "js" {
        if (program && program.statements) {
             for (const stmt of program.statements) {
                 if (stmt.kind == 60) exports.push(stmt.name); // FN
                 if (stmt.kind == 70) exports.push(stmt.name); // STRUCT
                 if (stmt.kind == 61) exports.push(stmt.name); // LET
             }
        }
        if (exports.length > 0) {
            output += "\nmodule.exports = { " + exports.join(", ") + " };\n";
        }
    }
    return output;
}

fn CodeGenerator_generate_python(self: CodeGenerator, program: Program) -> string {
    let output = "";
    native "js" {
        if (program && program.statements) {
            for (const stmt of program.statements) {
                output = output + CodeGenerator_gen_stmt_py(self, stmt) + "\n";
            }
        }
    }
    return output;
}

fn CodeGenerator_gen_stmt_py(self: CodeGenerator, stmt: any) -> string {
    let indent_str = "";
    native "js" { indent_str = "    ".repeat(self.indent); }

    if (stmt.kind == 91) { // PACKAGE
        return ""; // Ignored in simple python script or mapped?
    }
    if (stmt.kind == NODE_IMPORT) { // IMPORT
        let path = stmt.path;
        let name = "";
        native "js" {
             path = path.replace(".omni", "");
             path = path.replace(/\//g, "."); // core/token -> core.token
             if (path.startsWith(".")) path = path.substring(1); // ./core -> /core -> core (fix logic later if needed)
             if (path.startsWith(".")) path = path.substring(1);
             name = path.split(".").pop();
        }
        // "import core.token as token" or "from core.token import *" ?
        // User requirements: "Implemente a lógica básica"
        // Let's use simple import: "from path import *" if we want to mimic JS require behaving like flattening exports?
        // JS: const token = require(...) -> token.TOKEN_EOF
        // If we import * everything is global.
        // If we want usage like token.TOKEN_EOF, we need: "import core.token as token"
        // BUT path might be relative.
        // Let's try: "import path as name"
        return indent_str + "import " + path + " as " + name;
    }
    if (stmt.kind == 80) { // NATIVE
       if (stmt.lang == "py" || stmt.lang == "python") {
           return stmt.code;
       }
       return ""; 
    }
    if (stmt.kind == NODE_LET) {
        return indent_str + stmt.name + " = " + CodeGenerator_gen_expr_py(self, stmt.value);
    }
    if (stmt.kind == NODE_RETURN) {
        return indent_str + "return " + CodeGenerator_gen_expr_py(self, stmt.value);
    }
    if (stmt.kind == NODE_FUNCTION) {
        let params = "";
        native "js" { params = stmt.params.join(", "); }
        // Handle self for methods? No, free functions.
        let decl = indent_str + "def " + stmt.name + "(" + params + "):\n";
        
        self.indent = self.indent + 1;
        let body = CodeGenerator_gen_block_py(self, stmt.body);
        self.indent = self.indent - 1;
        
        return decl + body;
    }
    if (stmt.kind == NODE_STRUCT) {
        let decl = indent_str + "class " + stmt.name + ":\n";
        self.indent = self.indent + 1;
        let init_indent = "";
        native "js" { init_indent = "    ".repeat(self.indent); }
        
        let assignments = "";
        native "js" {
             if (stmt.fields.length == 0) {
                 assignments = init_indent + "    pass";
             } else {
                 for(let f of stmt.fields) {
                     assignments += init_indent + "    self." + f.name + " = data.get('" + f.name + "')\n";
                 }
             }
        }
        
        let init_fn = init_indent + "def __init__(self, data=None):\n";
        init_fn = init_fn + init_indent + "    if data is None: data = {}\n";
        init_fn = init_fn + assignments + "\n";
        
        self.indent = self.indent - 1;
        return decl + init_fn;
    }
    if (stmt.kind == NODE_IF) {
        let cond = CodeGenerator_gen_expr_py(self, stmt.condition);
        let out = indent_str + "if " + cond + ":\n";
        
        self.indent = self.indent + 1;
        out = out + CodeGenerator_gen_block_py(self, stmt.consequence);
        self.indent = self.indent - 1;
        
        if (stmt.alternative) {
            out = out + "\n" + indent_str + "else:\n";
            self.indent = self.indent + 1;
            out = out + CodeGenerator_gen_block_py(self, stmt.alternative);
            self.indent = self.indent - 1;
        }
        return out;
    }
    if (stmt.kind == NODE_WHILE) {
        let cond = CodeGenerator_gen_expr_py(self, stmt.condition);
        let out = indent_str + "while " + cond + ":\n";
        self.indent = self.indent + 1;
        out = out + CodeGenerator_gen_block_py(self, stmt.body);
        self.indent = self.indent - 1;
        return out;
    }
    if (stmt.expr) {
        return indent_str + CodeGenerator_gen_expr_py(self, stmt.expr);
    }
    return indent_str + "# Unknown stmt: " + stmt.kind;
}

fn CodeGenerator_gen_block_py(self: CodeGenerator, block: Block) -> string {
    let out = "";
    native "js" {
        if (!block.statements || block.statements.length == 0) {
             out = "    ".repeat(self.indent) + "pass";
        } else {
             for (const s of block.statements) {
                  out = out + CodeGenerator_gen_stmt_py(self, s) + "\n";
             }
        }
    }
    // Trim last newline?
    return out;
}

fn CodeGenerator_gen_expr_py(self: CodeGenerator, expr: any) -> string {
    if (expr == 0) return "None";
    if (expr.kind == NODE_LITERAL) {
         if (expr.value == "true") return "True";
         if (expr.value == "false") return "False";
         if (expr.value == "null") return "None";
         return expr.value;
    }
    if (expr.kind == NODE_BINARY) {
        let op = expr.op;
        if (op == "&&") op = "and";
        if (op == "||") op = "or";
        if (op == "!") op = "not ";
        return CodeGenerator_gen_expr_py(self, expr.left) + " " + op + " " + CodeGenerator_gen_expr_py(self, expr.right);
    }
    if (expr.kind == NODE_CALL) {
        let callee = CodeGenerator_gen_expr_py(self, expr.function);
        let args = "";
        native "js" {
            let list = [];
            for(let a of expr.args) list.push(CodeGenerator_gen_expr_py(self, a));
            args = list.join(", ");
        }
        // Handle class instantiation (e.g. new_parser -> Parser(l) ?)
        // Omni uses free functions usually, but structs used to use `new Class()`.
        // If Python uses class `Parser`, simple instantiation `Parser()` works.
        // `call` handles it generally.
        return callee + "(" + args + ")";
    }
    if (expr.kind == NODE_MEMBER) {
         return CodeGenerator_gen_expr_py(self, expr.target) + "." + expr.property;
    }
    if (expr.kind == NODE_STRUCT_INIT) {
         // new Struct({ a: 1 }) -> Struct({'a': 1})
         let fields = "";
         native "js" {
              let list = [];
              for(let f of expr.fields) {
                   list.push("'" + f.name + "': " + CodeGenerator_gen_expr_py(self, f.value));
              }
              fields = list.join(", ");
         }
         return expr.name + "({ " + fields + " })";
    }
    if (expr.kind == NODE_ARRAY) {
         let elems = "";
         native "js" {
             let list = [];
             for (let e of expr.elements) list.push(CodeGenerator_gen_expr_py(self, e));
             elems = list.join(", ");
         }
         return "[" + elems + "]";
    }
    if (expr.kind == NODE_IDENTIFIER) return expr.value;
    
    // Assignment
    if (expr.kind == NODE_ASSIGNMENT) {
         // Assignments in Python are statements, except := (walrus)
         // Omni AST has Assignment as Expression?
         // parser line 250: AssignmentExpr.
         // If used in expression stmt, fine. If used as value... Python doesn't support `x = y` as expr until 3.8 generally, but Omni usage:
         // `p.cur_token = ...` is statement usually.
         // `let x = y = z` supported?
         // Assuming simple assignment statements for now.
         return CodeGenerator_gen_expr_py(self, expr.left) + " = " + CodeGenerator_gen_expr_py(self, expr.right);
    }
    
    native "js" { if (typeof(expr) == "string") return expr; }
    return "None";
}

fn CodeGenerator_gen_statement(self: CodeGenerator, stmt: any) -> string {
    if (stmt.kind == NODE_IMPORT) { // IMPORT
        return CodeGenerator_gen_import(self, stmt);
    }

    if (stmt.kind == 80) { // NATIVE
        return stmt.code;
    }
    if (stmt.kind == NODE_LET) { // LET
        return "let " + stmt.name + " = " + CodeGenerator_gen_expression(self, stmt.value) + ";";
    }
    if (stmt.kind == NODE_RETURN) { // RETURN
        return "return " + CodeGenerator_gen_expression(self, stmt.value) + ";";
    }
    if (stmt.kind == NODE_FUNCTION) { // FN
        let params = "";
        native "js" { params = stmt.params.join(", "); }
        let body = CodeGenerator_gen_block(self, stmt.body);
        return "function " + stmt.name + "(" + params + ") " + body;
    }
    if (stmt.kind == NODE_STRUCT) { // STRUCT
        return CodeGenerator_gen_struct(self, stmt);
    }
    if (stmt.kind == NODE_IF) { // IF
        let cond = CodeGenerator_gen_expression(self, stmt.condition);
        let cons = CodeGenerator_gen_block(self, stmt.consequence);
        let alt = "";
        if (stmt.alternative) {
            alt = " else " + CodeGenerator_gen_block(self, stmt.alternative);
        }
        return "if (" + cond + ") " + cons + alt;
    }
    if (stmt.kind == NODE_WHILE) { // WHILE
         let cond = CodeGenerator_gen_expression(self, stmt.condition);
         let body = CodeGenerator_gen_block(self, stmt.body);
         return "while (" + cond + ") " + body;
    }
    // Expression Stmt (default)
    if (stmt.expr) {
         return CodeGenerator_gen_expression(self, stmt.expr) + ";";
    }
    return "// Unknown stmt kind: " + stmt.kind;
}

fn CodeGenerator_gen_import(self: CodeGenerator, stmt: ImportStmt) -> string {
    let path = stmt.path;
    // Transforma "token.omni" em "./token.js"
    native "js" {
        path = path.replace(".omni", ".js");
        if (path.startsWith(".") == false) path = "./" + path;
        // Extrai nome do arquivo para variável: "./core/token.js" -> "token"
        let name = path.split("/").pop().replace(".js", "");
        // Gera: const token = require("./token.js");
        return "const " + name + " = require(\"" + path + "\");\n" +
               "if (typeof global !== 'undefined') Object.assign(global, " + name + ");";
    }
    return "";
}

fn CodeGenerator_gen_struct(self: CodeGenerator, stmt: StructDecl) -> string {
    let name = stmt.name;
    let assignments = "";
    native "js" {
        for (const field of stmt.fields) {
             assignments = assignments + "        this." + field.name + " = data." + field.name + ";\n";
        }
    }
    return "class " + name + " {\n    constructor(data = {}) {\n" + assignments + "    }\n}";
}

fn CodeGenerator_gen_block(self: CodeGenerator, block: Block) -> string {
    let out = "{\n";
    native "js" {
        if (block && block.statements) {
            for (const s of block.statements) {
                out = out + "    " + CodeGenerator_gen_statement(self, s) + "\n";
            }
        }
    }
    out = out + "}";
    return out;
}

fn CodeGenerator_gen_expression(self: CodeGenerator, expr: any) -> string {
    if (expr == 0) return "null";

    if (expr.kind == NODE_LITERAL) return expr.value;

    if (expr.kind == NODE_BINARY) {
        return CodeGenerator_gen_expression(self, expr.left) + " " + expr.op + " " + CodeGenerator_gen_expression(self, expr.right);
    }

    if (expr.kind == NODE_CALL) {
         let args = "";
         native "js" {
             let list = [];
             for(let a of expr.args) list.push(CodeGenerator_gen_expression(self, a));
             args = list.join(", ");
         }
         
         // Generate callee code first
         let callee = CodeGenerator_gen_expression(self, expr.function);
         
         // Heuristic for Class Instantiation (New): 
         // Check if callee starts with Uppercase letter (only if simple identifier)
         let is_class = false;
         native "js" {
             if (typeof expr.function.value === 'string') {
                 let val = expr.function.value;
                 let first = val.charAt(0);
                 is_class = (first >= "A" && first <= "Z") && (val.indexOf("_") == -1);
             }
         }
         if (is_class) return "new " + callee + "(" + args + ")";
         return callee + "(" + args + ")";
    }

    if (expr.kind == NODE_MEMBER) {
        return CodeGenerator_gen_expression(self, expr.target) + "." + expr.property;
    }

    if (expr.kind == NODE_STRUCT_INIT) {
        let fields = "";
        native "js" {
            let list = [];
            for(let f of expr.fields) {
                list.push(f.name + ": " + CodeGenerator_gen_expression(self, f.value));
            }
            fields = list.join(", ");
        }
        return "new " + expr.name + "({ " + fields + " })";
    }

    if (expr.kind == NODE_ARRAY) {
        let elems = "";
        native "js" {
            let list = [];
            for (let e of expr.elements) {
                list.push(CodeGenerator_gen_expression(self, e));
            }
            elems = list.join(", ");
        }
        return "[" + elems + "]";
    }
    
    if (expr.kind == NODE_IDENTIFIER) {
         return expr.value;
    }

    if (expr.kind == NODE_ASSIGNMENT) {
        let left = CodeGenerator_gen_expression(self, expr.left);
        let right = CodeGenerator_gen_expression(self, expr.right);
        let code = "";
        native "js" { code = left + " = " + right; }
        return code;
    }

    // Identifier (string)
    native "js" { if (typeof(expr) == "string") return expr; }

    return expr; // Fallback
}