import "ast.omni";

struct CodeGenerator {
}

fn new_code_generator() -> CodeGenerator {
    return CodeGenerator {};
}

fn CodeGenerator_generate(self: CodeGenerator, program: Program) -> string {
    let output = "";
    // Native loop over statements
    native "js" {
        for (const stmt of program.statements) {
            output += CodeGenerator_gen_statement(self, stmt) + "\n";
        }
    }
    return output;
}

fn CodeGenerator_gen_statement(self: CodeGenerator, stmt: any) -> string {
    if (stmt.kind == NODE_LET) {
        return "let " + stmt.name + " = " + CodeGenerator_gen_expression(self, stmt.value) + ";";
    }
    if (stmt.kind == NODE_RETURN) {
        return "return " + CodeGenerator_gen_expression(self, stmt.value) + ";";
    }
    if (stmt.kind == NODE_FUNCTION) {
        let params = "";
        native "js" { params = stmt.params.join(", "); }
        let body = CodeGenerator_gen_block(self, stmt.body);
        return "function " + stmt.name + "(" + params + ") " + body;
    }
    if (stmt.kind == NODE_STRUCT) {
        return CodeGenerator_gen_struct(self, stmt);
    }
    if (stmt.kind == NODE_NATIVE) {
        return stmt.code;
    }
    if (stmt.kind == NODE_IMPORT) {
        // import "path/to/file.omni"; -> const file = require("./path/to/file.js");
        let path = stmt.path;
        let name = "";
        native "js" {
            path = path.replace(".omni", ".js");
            if (!path.startsWith(".") && !path.startsWith("/")) {
                 path = "./" + path;
            }
            // Extract basename
            const parts = path.split('/');
            const filename = parts[parts.length - 1];
            name = filename.split('.')[0];
        }
        return "const " + name + " = require(\"" + path + "\");";
    }
    // Expression Statement
    return CodeGenerator_gen_expression(self, stmt.expr) + ";";
}

fn CodeGenerator_gen_struct(self: CodeGenerator, stmt: StructDecl) -> string {
    let name = stmt.name;
    let assignments = "";
    
    // Gera: this.field = data.field;
    native "js" {
        for (const field of stmt.fields) {
            assignments += `        this.${field.name} = data.${field.name};\n`;
        }
    }

    return "class " + name + " {\n" +
           "    constructor(data = {}) {\n" +
           assignments +
           "    }\n" +
           "}";
}

fn CodeGenerator_gen_block(self: CodeGenerator, block: Block) -> string {
    let out = "{\n";
    native "js" {
        for (const s of block.statements) {
            out += "    " + CodeGenerator_gen_statement(self, s) + "\n";
        }
    }
    out += "}";
    return out;
}

fn CodeGenerator_gen_expression(self: CodeGenerator, expr: any) -> string {
    if (expr.kind == NODE_LITERAL) {
        return expr.value; // JS auto-converts int to string
    }
    if (expr.kind == NODE_CALL) {
        let args = "";
        native "js" { 
            let argList = [];
            for(let a of expr.args) argList.push(CodeGenerator_gen_expression(self, a));
            args = argList.join(", ");
        }
        
        let is_class = false;
        native "js" { is_class = /^[A-Z]/.test(expr.function); }
        
        if (is_class) {
            return "new " + expr.function + "(" + args + ")";
        }
        return expr.function + "(" + args + ")";
    }
    if (expr.kind == NODE_BINARY) {
         let left = CodeGenerator_gen_expression(self, expr.left);
         let right = CodeGenerator_gen_expression(self, expr.right);
         return "(" + left + " " + expr.op + " " + right + ")";
    }
    if (expr.kind == NODE_MEMBER) {
         let target = CodeGenerator_gen_expression(self, expr.target);
         return target + "." + expr.property;
    }
    
    return expr; // Identifier string
}