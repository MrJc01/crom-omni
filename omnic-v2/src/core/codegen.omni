import "ast.omni";
import "token.omni";

struct CodeGenerator {
}

fn new_code_generator() -> CodeGenerator {
    return CodeGenerator {};
}

fn CodeGenerator_generate(self: CodeGenerator, program: Program) -> string {
    let output = "";
    native "js" {
        if (program && program.statements) {
            for (const stmt of program.statements) {
                output = output + CodeGenerator_gen_statement(self, stmt) + "\n";
            }
        }
    }
    return output;
}

fn CodeGenerator_gen_statement(self: CodeGenerator, stmt: any) -> string {
    if (stmt.kind == NODE_IMPORT) { // IMPORT
        return CodeGenerator_gen_import(self, stmt);
    }

    if (stmt.kind == 80) { // NATIVE
        return stmt.code;
    }
    if (stmt.kind == NODE_LET) { // LET
        return "const " + stmt.name + " = " + CodeGenerator_gen_expression(self, stmt.value) + ";";
    }
    if (stmt.kind == NODE_RETURN) { // RETURN
        return "return " + CodeGenerator_gen_expression(self, stmt.value) + ";";
    }
    if (stmt.kind == NODE_FUNCTION) { // FN
        let params = "";
        native "js" { params = stmt.params.join(", "); }
        let body = CodeGenerator_gen_block(self, stmt.body);
        return "function " + stmt.name + "(" + params + ") " + body;
    }
    if (stmt.kind == NODE_STRUCT) { // STRUCT
        return CodeGenerator_gen_struct(self, stmt);
    }
    if (stmt.kind == NODE_IF) { // IF
        let cond = CodeGenerator_gen_expression(self, stmt.condition);
        let cons = CodeGenerator_gen_block(self, stmt.consequence);
        let alt = "";
        if (stmt.alternative) {
            alt = " else " + CodeGenerator_gen_block(self, stmt.alternative);
        }
        return "if (" + cond + ") " + cons + alt;
    }
    if (stmt.kind == NODE_WHILE) { // WHILE
         let cond = CodeGenerator_gen_expression(self, stmt.condition);
         let body = CodeGenerator_gen_block(self, stmt.body);
         return "while (" + cond + ") " + body;
    }
    // Expression Stmt (default)
    if (stmt.expr) {
         return CodeGenerator_gen_expression(self, stmt.expr) + ";";
    }
    return "// Unknown stmt kind: " + stmt.kind;
}

fn CodeGenerator_gen_import(self: CodeGenerator, stmt: ImportStmt) -> string {
    let path = stmt.path;
    // Transforma "token.omni" em "./token.js"
    native "js" {
        path = path.replace(".omni", ".js");
        if (path.startsWith(".") == false) path = "./" + path;
        // Extrai nome do arquivo para variÃ¡vel: "./core/token.js" -> "token"
        let name = path.split("/").pop().replace(".js", "");
        // Gera: const token = require("./token.js");
        return "const " + name + " = require(\"" + path + "\");";
    }
    return "";
}

fn CodeGenerator_gen_struct(self: CodeGenerator, stmt: StructDecl) -> string {
    let name = stmt.name;
    let assignments = "";
    native "js" {
        for (const field of stmt.fields) {
             assignments = assignments + "        this." + field.name + " = data." + field.name + ";\n";
        }
    }
    return "class " + name + " {\n    constructor(data = {}) {\n" + assignments + "    }\n}";
}

fn CodeGenerator_gen_block(self: CodeGenerator, block: Block) -> string {
    let out = "{\n";
    native "js" {
        if (block && block.statements) {
            for (const s of block.statements) {
                out = out + "    " + CodeGenerator_gen_statement(self, s) + "\n";
            }
        }
    }
    out = out + "}";
    return out;
}

fn CodeGenerator_gen_expression(self: CodeGenerator, expr: any) -> string {
    if (expr == 0) return "null";

    if (expr.kind == NODE_LITERAL) return expr.value;

    if (expr.kind == NODE_BINARY) {
        return CodeGenerator_gen_expression(self, expr.left) + " " + expr.op + " " + CodeGenerator_gen_expression(self, expr.right);
    }

    if (expr.kind == NODE_CALL) {
         let args = "";
         native "js" {
             let list = [];
             for(let a of expr.args) list.push(CodeGenerator_gen_expression(self, a));
             args = list.join(", ");
         }
         
         // Generate callee code first
         let callee = CodeGenerator_gen_expression(self, expr.function);
         
         // Heuristic for Class Instantiation (New): 
         // Check if callee starts with Uppercase letter (only if simple identifier)
         let is_class = false;
         native "js" {
             if (typeof expr.function.value === 'string') {
                 let val = expr.function.value;
                 let first = val.charAt(0);
                 is_class = (first >= "A" && first <= "Z") && (val.indexOf("_") == -1);
             }
         }
         if (is_class) return "new " + callee + "(" + args + ")";
         return callee + "(" + args + ")";
    }

    if (expr.kind == NODE_MEMBER) {
        return CodeGenerator_gen_expression(self, expr.target) + "." + expr.property;
    }

    if (expr.kind == NODE_STRUCT_INIT) {
        let fields = "";
        native "js" {
            let list = [];
            for(let f of expr.fields) {
                list.push(f.name + ": " + CodeGenerator_gen_expression(self, f.value));
            }
            fields = list.join(", ");
        }
        return "new " + expr.name + "({ " + fields + " })";
    }

    if (expr.kind == NODE_ARRAY) {
        let elems = "";
        native "js" {
            let list = [];
            for (let e of expr.elements) {
                list.push(CodeGenerator_gen_expression(self, e));
            }
            elems = list.join(", ");
        }
        return "[" + elems + "]";
    }
    
    if (expr.kind == NODE_IDENTIFIER) {
         return expr.value;
    }

    if (expr.kind == NODE_ASSIGNMENT) {
        let left = CodeGenerator_gen_expression(self, expr.left);
        let right = CodeGenerator_gen_expression(self, expr.right);
        let code = "";
        native "js" { code = left + " = " + right; }
        return code;
    }

    // Identifier (string)
    native "js" { if (typeof(expr) == "string") return expr; }

    return expr; // Fallback
}