// Node Constants
let NODE_PROGRAM = 1;
let NODE_LET = 2;
let NODE_LITERAL = 3;
let NODE_FUNCTION = 4;
let NODE_BLOCK = 5;
let NODE_CALL = 6;
let NODE_RETURN = 7;
let NODE_BINARY = 8;
let NODE_MEMBER = 9;
let NODE_IMPORT = 10;
let NODE_ARRAY = 11;
let NODE_STRUCT_INIT = 12;
let NODE_IF = 13;
let NODE_WHILE = 14;
let NODE_IDENTIFIER = 15;
let NODE_ASSIGNMENT = 16;
let NODE_STRING = 17;
let NODE_BOOL = 18;
let NODE_FOR = 19;
let NODE_EXPRESSION_STMT = 20;
let NODE_UNARY = 21; // ADDED

let NODE_STRUCT = 70;
let NODE_NATIVE = 80;
let NODE_CAPSULE = 90;
let NODE_SPAWN = 100;
let NODE_INTERFACE = 110;


// Structures
struct Program {
    statements: any // List<Statement>
}

struct AssignmentExpr {
    kind: i64,
    left: any,
    right: any
}

struct UnaryExpr { // ADDED
    kind: i64,
    op: string,
    operand: any
}

struct NativeStmt {
    kind: i64,
    lang: string,
    code: string
}

struct LetStmt {
    kind: i64,
    name: string,
    value: any,
    is_exported: bool
}

struct ImportDecl {
    kind: i64,
    path: string
}

struct ExpressionStmt {
    kind: i64,
    expr: any // Expression
}

struct IntegerLiteral {
    kind: i64,
    value: i64
}

struct StringLiteral {
    kind: i64,
    value: string
}

struct BoolLiteral {
    kind: i64,
    value: bool
}

struct StructInitExpr {
    kind: i64,
    name: string,
    fields: any
}

struct StructInitField {
    name: string,
    value: any
}

struct BinaryExpr {
    kind: i64,
    left: any,
    op: string,
    right: any
}

struct MemberExpr {
    kind: i64,
    target: any,
    property: string
}

// Function Support
struct FunctionDecl {
    kind: i64,
    name: string,
    params: any,
    body: any,
    is_exported: bool,
    decorators: any // List<Decorator>
}

struct Block {
    kind: i64,
    statements: any
}

struct CallExpr {
    kind: i64,
    function: any, // Expression (Identifier)
    args: any // List<Expression>
}

struct ReturnStmt {
    kind: i64,
    value: any
}

struct IfStmt {
    kind: i64,
    condition: any,
    consequence: any,
    alternative: any
}

struct WhileStmt {
    kind: i64,
    condition: any,
    body: any
}

struct ForStmt {
    kind: i64,
    iterator: string,
    collection: any,
    body: any
}


// Struct Support
struct StructDecl {
    kind: i64,
    name: string,
    fields: any,
    is_exported: bool,
    decorators: any // List<Decorator>
}

struct CapsuleDecl {
    kind: i64,
    name: string,
    body: any
}

struct StructField {
    name: string,
    typename: string
}

struct Decorator {
    name: string,
    args: any // List<KeyValue> or List<Expr>? For now keeping it simple: List<StructInitField>
}

// Helper para instanciar struct field
fn new_struct_field(name: string, typename: string) -> StructField {
    return StructField {
        name: name,
        typename: typename
    };
}

struct Identifier {
    kind: i64,
    value: string
}