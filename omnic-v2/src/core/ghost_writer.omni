// ============================================================================
// OMNI GHOST WRITER - Automatic Documentation Generator
// Generates Mermaid diagrams and technical documentation from AST
// ============================================================================

import "ast.omni";
import "../lib/terminal.omni";

// ============================================================================
// GRAPH STRUCTURES
// ============================================================================

struct CapsuleGraph {
    name: string,
    flows: any,
    entities: any,
    dependencies: any,
    attributes: any
}

struct EntityGraph {
    name: string,
    fields: any,
    relations: any
}

struct FlowGraph {
    name: string,
    params: any,
    return_type: string,
    calls: any,
    attributes: any
}

// ============================================================================
// GHOST WRITER ENGINE
// ============================================================================

struct GhostWriter {
    capsules: any,
    entities: any,
    functions: any,
    imports: any,
    call_graph: any
}

fn GhostWriter_new() -> GhostWriter {
    return GhostWriter {
        capsules: [],
        entities: [],
        functions: [],
        imports: [],
        call_graph: {}
    };
}

fn GhostWriter_analyze(self: GhostWriter, program: any) {
    native "js" {
        if (!program || !program.statements) {
            console.error("[ghost] Invalid program");
            return;
        }
        
        for (const stmt of program.statements) {
            // Capsule
            if (stmt.kind === 93) { // NODE_CAPSULE
                const capsule = {
                    name: stmt.name,
                    flows: [],
                    entities: [],
                    dependencies: [],
                    attributes: stmt.attributes || []
                };
                
                for (const flow of (stmt.flows || [])) {
                    capsule.flows.push({
                        name: flow.name,
                        params: flow.params || [],
                        return_type: flow.return_type || 'void',
                        attributes: flow.attributes || []
                    });
                }
                
                self.capsules.push(capsule);
            }
            
            // Struct / Entity
            if (stmt.kind === 70) { // NODE_STRUCT
                const entity = {
                    name: stmt.name,
                    fields: stmt.fields || [],
                    isEntity: (stmt.attributes || []).some(a => a.name === 'entity')
                };
                self.entities.push(entity);
            }
            
            // Function
            if (stmt.kind === 4) { // NODE_FUNCTION
                const fn = {
                    name: stmt.name,
                    params: stmt.params || [],
                    return_type: stmt.return_type || 'void',
                    calls: []
                };
                
                // Extract function calls from body
                const extractCalls = (node) => {
                    if (!node) return;
                    if (node.kind === 6) { // NODE_CALL
                        fn.calls.push(node.name || (node.callee && node.callee.value));
                    }
                    if (Array.isArray(node)) {
                        node.forEach(extractCalls);
                    }
                    if (node.statements) extractCalls(node.statements);
                    if (node.body) extractCalls(node.body);
                    if (node.consequence) extractCalls(node.consequence);
                    if (node.alternative) extractCalls(node.alternative);
                };
                
                extractCalls(stmt.body);
                self.functions.push(fn);
            }
            
            // Import
            if (stmt.kind === 10) { // NODE_IMPORT
                self.imports.push(stmt.path || stmt.value);
            }
        }
        
        // Build call graph
        for (const fn of self.functions) {
            self.call_graph[fn.name] = fn.calls.filter(c => c);
        }
    }
}

// ============================================================================
// MERMAID DIAGRAM GENERATORS
// ============================================================================

fn GhostWriter_gen_class_diagram(self: GhostWriter) -> string {
    let diagram = "";
    
    native "js" {
        diagram = "```mermaid\nclassDiagram\n";
        
        // Entities
        for (const entity of self.entities) {
            diagram += "    class " + entity.name + " {\n";
            
            for (const field of entity.fields) {
                const fieldName = field.name || field;
                const fieldType = field.type || 'any';
                diagram += "        +" + fieldType + " " + fieldName + "\n";
            }
            
            diagram += "    }\n\n";
        }
        
        // Capsules as classes
        for (const capsule of self.capsules) {
            diagram += "    class " + capsule.name + " {\n";
            diagram += "        <<capsule>>\n";
            
            for (const flow of capsule.flows) {
                const params = (flow.params || []).map(p => 
                    typeof p === 'string' ? p : p.name
                ).join(', ');
                diagram += "        +" + flow.name + "(" + params + ") " + flow.return_type + "\n";
            }
            
            diagram += "    }\n\n";
        }
        
        // Relations (capsules using entities)
        for (const capsule of self.capsules) {
            for (const entity of self.entities) {
                // Check if capsule references entity
                const capsuleStr = JSON.stringify(capsule);
                if (capsuleStr.includes(entity.name)) {
                    diagram += "    " + capsule.name + " --> " + entity.name + " : uses\n";
                }
            }
        }
        
        diagram += "```\n";
    }
    
    return diagram;
}

fn GhostWriter_gen_flowchart(self: GhostWriter) -> string {
    let diagram = "";
    
    native "js" {
        diagram = "```mermaid\nflowchart TD\n";
        
        // Subgraphs for capsules
        for (const capsule of self.capsules) {
            diagram += "    subgraph " + capsule.name + "\n";
            
            for (const flow of capsule.flows) {
                const nodeId = capsule.name + "_" + flow.name;
                
                // Check for server attribute
                const serverAttr = flow.attributes.find(a => 
                    a.name && a.name.startsWith('server.')
                );
                
                if (serverAttr) {
                    const method = serverAttr.name.split('.')[1].toUpperCase();
                    diagram += "        " + nodeId + "[(" + method + " " + flow.name + ")]\n";
                } else {
                    diagram += "        " + nodeId + "[" + flow.name + "]\n";
                }
            }
            
            diagram += "    end\n\n";
        }
        
        // Connect capsule flows
        for (const capsule of self.capsules) {
            for (let i = 0; i < capsule.flows.length - 1; i++) {
                const from = capsule.name + "_" + capsule.flows[i].name;
                const to = capsule.name + "_" + capsule.flows[i + 1].name;
                // diagram += "    " + from + " --> " + to + "\n";
            }
        }
        
        // External connections
        for (const entity of self.entities.filter(e => e.isEntity)) {
            diagram += "    DB[(" + entity.name + " DB)]\n";
            
            for (const capsule of self.capsules) {
                const capsuleStr = JSON.stringify(capsule);
                if (capsuleStr.includes(entity.name)) {
                    diagram += "    " + capsule.name + "_" + capsule.flows[0].name + " --> DB\n";
                }
            }
        }
        
        diagram += "```\n";
    }
    
    return diagram;
}

fn GhostWriter_gen_sequence_diagram(self: GhostWriter) -> string {
    let diagram = "";
    
    native "js" {
        diagram = "```mermaid\nsequenceDiagram\n";
        
        // Participants
        diagram += "    participant Client\n";
        
        for (const capsule of self.capsules) {
            diagram += "    participant " + capsule.name + "\n";
        }
        
        for (const entity of self.entities.filter(e => e.isEntity)) {
            diagram += "    participant " + entity.name + "DB as " + entity.name + " DB\n";
        }
        
        diagram += "\n";
        
        // Sequence for each flow
        for (const capsule of self.capsules) {
            for (const flow of capsule.flows) {
                const serverAttr = flow.attributes.find(a => 
                    a.name && a.name.startsWith('server.')
                );
                
                if (serverAttr) {
                    const method = serverAttr.name.split('.')[1].toUpperCase();
                    diagram += "    Client->>+" + capsule.name + ": " + method + " /" + flow.name + "\n";
                    
                    // Check for entity access
                    for (const entity of self.entities.filter(e => e.isEntity)) {
                        const flowStr = JSON.stringify(flow);
                        if (flowStr.includes(entity.name) || flow.return_type === entity.name) {
                            diagram += "    " + capsule.name + "->>+" + entity.name + "DB: Query\n";
                            diagram += "    " + entity.name + "DB-->>-" + capsule.name + ": Results\n";
                        }
                    }
                    
                    diagram += "    " + capsule.name + "-->>-Client: Response\n\n";
                }
            }
        }
        
        diagram += "```\n";
    }
    
    return diagram;
}

fn GhostWriter_gen_call_graph(self: GhostWriter) -> string {
    let diagram = "";
    
    native "js" {
        diagram = "```mermaid\ngraph LR\n";
        
        // Function nodes
        for (const fn of self.functions) {
            diagram += "    " + fn.name + "[" + fn.name + "()]\n";
        }
        
        // Capsule flow nodes
        for (const capsule of self.capsules) {
            for (const flow of capsule.flows) {
                diagram += "    " + capsule.name + "_" + flow.name + "[" + capsule.name + "." + flow.name + "]\n";
            }
        }
        
        diagram += "\n";
        
        // Call edges
        for (const [caller, callees] of Object.entries(self.call_graph)) {
            for (const callee of callees) {
                if (callee) {
                    diagram += "    " + caller + " --> " + callee + "\n";
                }
            }
        }
        
        diagram += "```\n";
    }
    
    return diagram;
}

// ============================================================================
// DOCUMENTATION GENERATOR
// ============================================================================

fn GhostWriter_generate_docs(self: GhostWriter, project_name: string) -> string {
    let doc = "";
    
    native "js" {
        doc = "# " + project_name + " - Architecture Documentation\n\n";
        doc += "> Auto-generated by Omni Ghost Writer\n\n";
        doc += "---\n\n";
        
        // Overview
        doc += "## Overview\n\n";
        doc += "| Component | Count |\n";
        doc += "|-----------|-------|\n";
        doc += "| Capsules | " + self.capsules.length + " |\n";
        doc += "| Entities | " + self.entities.length + " |\n";
        doc += "| Functions | " + self.functions.length + " |\n";
        doc += "| Imports | " + self.imports.length + " |\n\n";
        
        // Class Diagram
        doc += "## Class Diagram\n\n";
        doc += GhostWriter_gen_class_diagram(self) + "\n";
        
        // Flowchart
        doc += "## System Flowchart\n\n";
        doc += GhostWriter_gen_flowchart(self) + "\n";
        
        // Sequence Diagram
        doc += "## Sequence Diagram\n\n";
        doc += GhostWriter_gen_sequence_diagram(self) + "\n";
        
        // Call Graph
        doc += "## Call Graph\n\n";
        doc += GhostWriter_gen_call_graph(self) + "\n";
        
        // API Reference
        doc += "## API Reference\n\n";
        
        for (const capsule of self.capsules) {
            doc += "### Capsule: " + capsule.name + "\n\n";
            
            for (const flow of capsule.flows) {
                const params = (flow.params || []).map(p => 
                    typeof p === 'string' ? p : (p.name + ': ' + (p.type || 'any'))
                ).join(', ');
                
                doc += "#### `" + flow.name + "(" + params + ") -> " + flow.return_type + "`\n\n";
                
                // Attributes
                for (const attr of flow.attributes) {
                    if (attr.name && attr.name.startsWith('server.')) {
                        const method = attr.name.split('.')[1].toUpperCase();
                        const path = attr.args && attr.args[0] ? attr.args[0] : '/' + flow.name;
                        doc += "- **Endpoint:** `" + method + " " + path + "`\n";
                    }
                }
                
                doc += "\n";
            }
        }
        
        // Entities
        doc += "## Data Entities\n\n";
        
        for (const entity of self.entities) {
            doc += "### " + (entity.isEntity ? "@entity " : "") + entity.name + "\n\n";
            doc += "| Field | Type |\n";
            doc += "|-------|------|\n";
            
            for (const field of entity.fields) {
                const name = field.name || field;
                const type = field.type || 'any';
                doc += "| " + name + " | " + type + " |\n";
            }
            
            doc += "\n";
        }
        
        doc += "---\n\n";
        doc += "*Generated by Omni Ghost Writer v1.0*\n";
    }
    
    return doc;
}

// ============================================================================
// COMMAND FUNCTION
// ============================================================================

fn cmd_graph(input_file: string, output_file: string) {
    CLI_header("Omni Ghost Writer");
    CLI_info("Analyzing: " + input_file);
    
    let source = read_file(input_file);
    
    // Parse
    let l = new_lexer(source);
    let p = new_parser(l);
    let program = Parser_parse_program(p);
    
    // Analyze
    let writer = GhostWriter_new();
    GhostWriter_analyze(writer, program);
    
    // Get project name from file
    let project_name = "";
    native "js" {
        const path = require('path');
        project_name = path.basename(input_file, '.omni');
    }
    
    // Generate documentation
    let docs = GhostWriter_generate_docs(writer, project_name);
    
    // Write output
    write_file(output_file, docs);
    
    CLI_success("Documentation generated: " + output_file);
    
    // Summary
    native "js" {
        console.log("");
        console.log(CLI_COLORS.bold + "Generated Diagrams:" + CLI_COLORS.reset);
        console.log("  • Class Diagram");
        console.log("  • System Flowchart");
        console.log("  • Sequence Diagram");
        console.log("  • Call Graph");
        console.log("");
        terminal.CLI_info("View the .md file in any Markdown viewer with Mermaid support");
    }
}

// ============================================================================
// EXPORTS
// ============================================================================

export GhostWriter;
export GhostWriter_new;
export GhostWriter_analyze;
export GhostWriter_gen_class_diagram;
export GhostWriter_gen_flowchart;
export GhostWriter_gen_sequence_diagram;
export GhostWriter_gen_call_graph;
export GhostWriter_generate_docs;
export cmd_graph;
