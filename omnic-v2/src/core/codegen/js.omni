
import "base.omni";
import "../ast.omni";
import "../token.omni";

fn CodeGenerator_gen_statement(self: CodeGenerator, stmt: any) -> string {
    if (stmt.kind == NODE_IMPORT) { // IMPORT
        return CodeGenerator_gen_import(self, stmt);
    }

    if (stmt.kind == 80) { // NATIVE
        // Only emit native blocks that match JS target
        if (stmt.lang == "js" || stmt.lang == "javascript") {
            return stmt.code;
        }
        return ""; // Skip non-JS native blocks
    }
    if (stmt.kind == NODE_LET) { // LET
        return "let " + stmt.name + " = " + CodeGenerator_gen_expression(self, stmt.value) + ";";
    }
    if (stmt.kind == NODE_RETURN) { // RETURN
        return "return " + CodeGenerator_gen_expression(self, stmt.value) + ";";
    }
    if (stmt.kind == NODE_FUNCTION) { // FN
        let params = "";
        native "js" { params = stmt.params.join(", "); }
        let body = CodeGenerator_gen_block(self, stmt.body);
        let decl = "function " + stmt.name + "(" + params + ") " + body;
        
        let decorators_code = CodeGenerator_gen_decorators(self, stmt.name, stmt.decorators);
        if (decorators_code != "") {
            decl = decl + "\n" + decorators_code;
        }
        return decl;
    }
    if (stmt.kind == NODE_STRUCT) { // STRUCT
        let decl = CodeGenerator_gen_struct(self, stmt);
        let decorators_code = CodeGenerator_gen_decorators(self, stmt.name, stmt.decorators);
        if (decorators_code != "") {
            decl = decl + "\n" + decorators_code;
        }
        return decl;
    }
    if (stmt.kind == NODE_IF) { // IF
        let cond = CodeGenerator_gen_expression(self, stmt.condition);
        let cons = CodeGenerator_gen_block(self, stmt.consequence);
        let alt = "";
        if (stmt.alternative) {
            alt = " else " + CodeGenerator_gen_block(self, stmt.alternative);
        }
        return "if (" + cond + ") " + cons + alt;
    }
    if (stmt.kind == NODE_WHILE) { // WHILE
         let cond = CodeGenerator_gen_expression(self, stmt.condition);
         let body = CodeGenerator_gen_block(self, stmt.body);
         return "while (" + cond + ") " + body;
    }
    // Expression Stmt (default)
    if (stmt.expr) {
         return CodeGenerator_gen_expression(self, stmt.expr) + ";";
    }
    return "// Unknown stmt kind: " + stmt.kind;
}

fn CodeGenerator_gen_import(self: CodeGenerator, stmt: ImportStmt) -> string {
    let path = stmt.path;
    // Transforma "token.omni" em "./token.js"
    native "js" {
        path = path.replace(".omni", ".js");
        if (path.startsWith(".") == false) path = "./" + path;
        // Extrai nome do arquivo para variÃ¡vel: "./core/token.js" -> "token"
        let name = path.split("/").pop().replace(".js", "");
        // Gera: const token = require("./token.js");
        return "const " + name + " = require(\"" + path + "\");\n" +
               "if (typeof global !== 'undefined') Object.assign(global, " + name + ");";
    }
    return "";
}

fn CodeGenerator_gen_struct(self: CodeGenerator, stmt: StructDecl) -> string {
    let name = stmt.name;
    let assignments = "";
    native "js" {
        for (const field of stmt.fields) {
             assignments = assignments + "        this." + field.name + " = data." + field.name + ";\n";
        }
    }
    return "class " + name + " {\n    constructor(data = {}) {\n" + assignments + "    }\n}";
}

fn CodeGenerator_gen_block(self: CodeGenerator, block: Block) -> string {
    let out = "{\n";
    native "js" {
        if (block && block.statements) {
            for (const s of block.statements) {
                out = out + "    " + CodeGenerator_gen_statement(self, s) + "\n";
            }
        }
    }
    out = out + "}";
    return out;
}

fn CodeGenerator_gen_expression(self: CodeGenerator, expr: any) -> string {
    if (expr == 0) return "null";

    if (expr.kind == NODE_LITERAL) return expr.value;

    if (expr.kind == NODE_STRING) {
        // Add quotes around string value for JS
        return "'" + expr.value + "'";
    }
    
    if (expr.kind == NODE_BOOL) {
        if (expr.value) {
            return "true";
        }
        return "false";
    }

    if (expr.kind == NODE_BINARY) {
        return CodeGenerator_gen_expression(self, expr.left) + " " + expr.op + " " + CodeGenerator_gen_expression(self, expr.right);
    }

    if (expr.kind == NODE_CALL) {
         let args = "";
         native "js" {
             let list = [];
             for(let a of expr.args) list.push(CodeGenerator_gen_expression(self, a));
             args = list.join(", ");
         }
         
         // Generate callee code first
         let callee = CodeGenerator_gen_expression(self, expr.function);
         
         // Heuristic for Class Instantiation (New): 
         // Check if callee starts with Uppercase letter (only if simple identifier)
         let is_class = false;
         native "js" {
             if (typeof expr.function.value === 'string') {
                 let val = expr.function.value;
                 let first = val.charAt(0);
                 is_class = (first >= "A" && first <= "Z") && (val.indexOf("_") == -1);
             }
         }
         if (is_class) return "new " + callee + "(" + args + ")";
         return callee + "(" + args + ")";
    }

    if (expr.kind == NODE_MEMBER) {
        return CodeGenerator_gen_expression(self, expr.target) + "." + expr.property;
    }

    if (expr.kind == NODE_STRUCT_INIT) {
        let fields = "";
        native "js" {
            let list = [];
            for(let f of expr.fields) {
                list.push(f.name + ": " + CodeGenerator_gen_expression(self, f.value));
            }
            fields = list.join(", ");
        }
        return "new " + expr.name + "({ " + fields + " })";
    }

    if (expr.kind == NODE_ARRAY) {
        let elems = "";
        native "js" {
            let list = [];
            for (let e of expr.elements) {
                list.push(CodeGenerator_gen_expression(self, e));
            }
            elems = list.join(", ");
        }
        return "[" + elems + "]";
    }
    
    if (expr.kind == NODE_IDENTIFIER) {
         return expr.value;
    }

    if (expr.kind == NODE_ASSIGNMENT) {
        let left = CodeGenerator_gen_expression(self, expr.left);
        let right = CodeGenerator_gen_expression(self, expr.right);
        let code = "";
        native "js" { code = left + " = " + right; }
        return code;
    }

    // Identifier (string)
    native "js" { if (typeof(expr) == "string") return expr; }

    return expr; // Fallback
}

fn CodeGenerator_gen_decorators(self: CodeGenerator, target_name: string, decorators: any) -> string {
    let out = "";
    native "js" {
        if (decorators && decorators.length > 0) {
             let dec_list = [];
             for (let d of decorators) {
                 let args = "[]";
                 if (d.args && d.args.length > 0) {
                     let arg_list = [];
                     for (let a of d.args) {
                         // struct init fields: {name: "x", value: expr}
                         let val = CodeGenerator_gen_expression(self, a.value);
                         if (a.name && a.name !== "") {
                             arg_list.push('{ name: "' + a.name + '", value: ' + val + ' }');
                         } else {
                             arg_list.push('{ value: ' + val + ' }');
                         }
                     }
                     args = "[" + arg_list.join(", ") + "]";
                 }
                 dec_list.push('{ name: "' + d.name + '", args: ' + args + ' }');
             }
             out = target_name + ".decorators = [" + dec_list.join(", ") + "];";
        }
    }
    return out;
}
