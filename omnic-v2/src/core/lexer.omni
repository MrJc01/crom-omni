import "token.omni";

// Native helper to access characters in a string
fn char_at(s: string, i: i64) -> string {
    native "js" {
        if (i >= s.length) return "\0";
        return s.charAt(i);
    }
}

// Native helper to check if a char is alphanumeric/underscore
fn is_letter(ch: string) -> bool {
    native "js" {
        return /[a-zA-Z_]/.test(ch);
    }
}

// Native helper to check if a char is digit
fn is_digit(ch: string) -> bool {
    native "js" {
        return /\d/.test(ch);
    }
}

struct Lexer {
    input: string,
    position: i64,      // current position in input (points to current char)
    read_position: i64, // current reading position in input (after current char)
    ch: string,         // current char under examination
    line: i64
}

fn Lexer_read_char(self: Lexer) {
    if (self.read_position >= 999999) { // TODO: Check EOF properly
         self.ch = "\0";
    } else {
         self.ch = char_at(self.input, self.read_position);
    }
    
    // Native check for EOF from char_at
    let is_eof = false;
    native "js" {
        is_eof = self.ch === "\0";
    }

    if (is_eof) {
        self.ch = "\0";
    } else {
        self.position = self.read_position;
        self.read_position = self.read_position + 1;
    }
}

fn new_lexer(input: string) -> Lexer {
    let l = Lexer {
        input: input,
        position: 0,
        read_position: 0,
        ch: "\0",
        line: 1
    };
    Lexer_read_char(l);
    return l;
}

fn Lexer_skip_whitespace(self: Lexer) {
    let is_ws = false;
    native "js" {
        is_ws = self.ch === ' ' || self.ch === '\t' || self.ch === '\n' || self.ch === '\r';
    }
    while (is_ws) {
        if (self.ch == "\n") {
            self.line = self.line + 1;
        }
        Lexer_read_char(self);
        native "js" {
                is_ws = self.ch === ' ' || self.ch === '\t' || self.ch === '\n' || self.ch === '\r';
        }
    }
}

fn Lexer_read_identifier(self: Lexer) -> string {
    let start_pos = self.position;
    while (is_letter(self.ch)) {
        Lexer_read_char(self);
    }
    // Slice string
    let ident = "";
    native "js" {
        ident = self.input.substring(Number(start_pos), Number(self.position));
    }
    return ident;
}

fn Lexer_read_number(self: Lexer) -> string {
    let start_pos = self.position;
    while (is_digit(self.ch)) {
        Lexer_read_char(self);
    }
    let num_str = "";
    native "js" {
        num_str = self.input.substring(Number(start_pos), Number(self.position));
    }
    return num_str;
}

fn Lexer_read_string(self: Lexer) -> string {
    let start_pos = self.position + 1;
    while (true) {
        Lexer_read_char(self);
        if (self.ch == "\"" || self.ch == "\0") {
            break;
        }
    }
    let str_val = "";
    native "js" {
        str_val = self.input.substring(Number(start_pos), Number(self.position));
    }
    return str_val;
}

fn Lexer_lookup_ident(ident: string) -> i64 {
    if (ident == "fn") return TOKEN_FN;
    if (ident == "let") return TOKEN_LET;
    if (ident == "true") return TOKEN_TRUE;
    if (ident == "false") return TOKEN_FALSE;
    if (ident == "if") return TOKEN_IF;
    if (ident == "else") return TOKEN_ELSE;
    if (ident == "return") return TOKEN_RETURN;
    if (ident == "struct") return TOKEN_STRUCT;
    if (ident == "import") return TOKEN_IMPORT;
    if (ident == "native") return TOKEN_NATIVE;
    return TOKEN_IDENTIFIER;
}

fn Lexer_next_token(self: Lexer) -> Token {
    Lexer_skip_whitespace(self);

    let tok = new_token(TOKEN_ILLEGAL, self.ch, self.line);
    tok.start = self.position;

    if (self.ch == "\0") {
        tok.kind = TOKEN_EOF;
        tok.lexeme = "";
        return tok;
    }

    if (self.ch == "=") {
        let next_char = char_at(self.input, self.read_position);
        if (next_char == "=") {
            Lexer_read_char(self);
            tok.kind = TOKEN_EQ;
            tok.lexeme = "==";
        } else {
            tok.kind = TOKEN_ASSIGN;
            tok.lexeme = "=";
        }
    } else if (self.ch == "+") {
        tok.kind = TOKEN_PLUS;
        tok.lexeme = "+";
    } else if (self.ch == "-") {
        tok.kind = TOKEN_MINUS;
        tok.lexeme = "-";
    } else if (self.ch == "!") {
            let next_char = char_at(self.input, self.read_position);
            if (next_char == "=") {
                Lexer_read_char(self);
                tok.kind = TOKEN_NOT_EQ;
                tok.lexeme = "!=";
            } else {
                tok.kind = TOKEN_BANG;
                tok.lexeme = "!";
            }
    } else if (self.ch == "*") {
        tok.kind = TOKEN_ASTERISK;
        tok.lexeme = "*";
    } else if (self.ch == "/") {
        tok.kind = TOKEN_SLASH;
        tok.lexeme = "/";
    } else if (self.ch == "<") {
        tok.kind = TOKEN_LT;
        tok.lexeme = "<";
    } else if (self.ch == ">") {
        tok.kind = TOKEN_GT;
        tok.lexeme = ">";
    } else if (self.ch == ";") {
        tok.kind = TOKEN_SEMICOLON;
        tok.lexeme = ";";
    } else if (self.ch == ":") {
        tok.kind = TOKEN_COLON;
        tok.lexeme = ":";
    } else if (self.ch == ",") {
        tok.kind = TOKEN_COMMA;
        tok.lexeme = ",";
    } else if (self.ch == ".") {
        tok.kind = TOKEN_DOT;
        tok.lexeme = ".";
    } else if (self.ch == "{") {
        tok.kind = TOKEN_LBRACE;
        tok.lexeme = "{";
    } else if (self.ch == "}") {
        tok.kind = TOKEN_RBRACE;
        tok.lexeme = "}";
    } else if (self.ch == "(") {
        tok.kind = TOKEN_LPAREN;
        tok.lexeme = "(";
    } else if (self.ch == ")") {
        tok.kind = TOKEN_RPAREN;
        tok.lexeme = ")";
    } else if (self.ch == "\"") {
        tok.kind = TOKEN_STRING;
        tok.lexeme = Lexer_read_string(self);
        // Note: read_string stops at the closing quote, but pointing TO it.
        // We need to consume the closing quote.
    } else {
        if (is_letter(self.ch)) {
            let literal = Lexer_read_identifier(self);
            tok.kind = Lexer_lookup_ident(literal);
            tok.lexeme = literal;
            return tok;
        } else if (is_digit(self.ch)) {
            tok.kind = TOKEN_INT;
            tok.lexeme = Lexer_read_number(self);
            return tok;
        } else {
            tok.kind = TOKEN_ILLEGAL;
            tok.lexeme = self.ch;
        }
    }

    Lexer_read_char(self);
    return tok;
}
