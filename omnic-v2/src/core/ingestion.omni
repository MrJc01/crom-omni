// ============================================================================
// OMNI INGESTION ENGINE - Legacy Code to Omni Transformation
// Deterministic Semantic Mapping Engine (No AI - Pure AST Analysis)
// ============================================================================

import "ast.omni";
import "token.omni";

// ============================================================================
// CANONICAL PATTERN REGISTRY
// Patterns recognized during ingestion and mapped to Omni constructs
// ============================================================================

struct CanonicalPattern {
    name: string,
    language: string,
    signature: string,
    omni_equivalent: string,
    confidence: i64
}

fn CanonicalPattern_new(name: string, lang: string, sig: string, omni: string) -> CanonicalPattern {
    return CanonicalPattern {
        name: name,
        language: lang,
        signature: sig,
        omni_equivalent: omni,
        confidence: 100
    };
}

// ============================================================================
// PATTERN DATABASE - Known Patterns for Each Language
// ============================================================================

struct PatternDatabase {
    patterns: any
}

fn PatternDatabase_new() -> PatternDatabase {
    let db = PatternDatabase { patterns: {} };
    
    native "js" {
        db.patterns = {
            // PHP Patterns
            php: [
                { 
                    name: 'class_definition',
                    regex: /class\s+(\w+)(?:\s+extends\s+(\w+))?(?:\s+implements\s+([\w,\s]+))?\s*\{/,
                    toOmni: (m) => `struct ${m[1]} {\n    // TODO: Extract fields\n}`
                },
                {
                    name: 'function_definition',
                    regex: /function\s+(\w+)\s*\((.*?)\)(?:\s*:\s*(\w+))?\s*\{/,
                    toOmni: (m) => `fn ${m[1]}(${m[2] || ''}) ${m[3] ? '-> ' + m[3] : ''} {\n    // TODO: Extract body\n}`
                },
                {
                    name: 'public_method',
                    regex: /public\s+function\s+(\w+)\s*\((.*?)\)/,
                    toOmni: (m) => `fn ${m[1]}(self: Self${m[2] ? ', ' + m[2] : ''})`
                },
                {
                    name: 'eloquent_model',
                    regex: /class\s+(\w+)\s+extends\s+Model/,
                    toOmni: (m) => `@entity\nstruct ${m[1]} {\n    id: i64\n}`
                },
                {
                    name: 'controller',
                    regex: /class\s+(\w+)Controller\s+extends\s+Controller/,
                    toOmni: (m) => `@server\ncapsule ${m[1]} {\n    // TODO: Extract flows\n}`
                },
                {
                    name: 'route_get',
                    regex: /Route::get\(['"]([^'"]+)['"]\s*,\s*\[(\w+)::class,\s*['"](\w+)['"]\]/,
                    toOmni: (m) => `@server.get("${m[1]}")\nflow ${m[3]}()`
                },
                {
                    name: 'route_post',
                    regex: /Route::post\(['"]([^'"]+)['"]\s*,\s*\[(\w+)::class,\s*['"](\w+)['"]\]/,
                    toOmni: (m) => `@server.post("${m[1]}")\nflow ${m[3]}()`
                }
            ],
            
            // Java Patterns
            java: [
                {
                    name: 'class_definition',
                    regex: /(?:public\s+)?class\s+(\w+)(?:\s+extends\s+(\w+))?(?:\s+implements\s+([\w,\s]+))?\s*\{/,
                    toOmni: (m) => `struct ${m[1]} {\n    // TODO: Extract fields\n}`
                },
                {
                    name: 'method_definition',
                    regex: /(?:public|private|protected)?\s*(?:static\s+)?(\w+)\s+(\w+)\s*\((.*?)\)\s*(?:throws\s+\w+)?\s*\{/,
                    toOmni: (m) => `fn ${m[2]}(${m[3] || ''}) -> ${m[1]} {\n}`
                },
                {
                    name: 'spring_controller',
                    regex: /@(?:RestController|Controller)[\s\S]*?class\s+(\w+)/,
                    toOmni: (m) => `@server\ncapsule ${m[1]} {\n}`
                },
                {
                    name: 'spring_get',
                    regex: /@GetMapping\(['"]([^'"]+)['"]\)[\s\S]*?(?:public\s+)?(\w+)\s+(\w+)/,
                    toOmni: (m) => `@server.get("${m[1]}")\nflow ${m[3]}() -> ${m[2]}`
                },
                {
                    name: 'spring_entity',
                    regex: /@Entity[\s\S]*?class\s+(\w+)/,
                    toOmni: (m) => `@entity\nstruct ${m[1]} {\n    id: i64\n}`
                },
                {
                    name: 'spring_repository',
                    regex: /interface\s+(\w+)Repository\s+extends\s+(?:JpaRepository|CrudRepository)/,
                    toOmni: (m) => `// Repository ${m[1]} -> Omni @entity auto-generates CRUD`
                }
            ],
            
            // JavaScript/TypeScript Patterns
            javascript: [
                {
                    name: 'class_definition',
                    regex: /class\s+(\w+)(?:\s+extends\s+(\w+))?\s*\{/,
                    toOmni: (m) => `struct ${m[1]} {\n}`
                },
                {
                    name: 'function_definition',
                    regex: /(?:async\s+)?function\s+(\w+)\s*\((.*?)\)(?:\s*:\s*(\w+))?\s*\{/,
                    toOmni: (m) => `fn ${m[1]}(${m[2] || ''}) ${m[3] ? '-> ' + m[3] : ''} {\n}`
                },
                {
                    name: 'arrow_function',
                    regex: /const\s+(\w+)\s*=\s*(?:async\s+)?\((.*?)\)\s*=>/,
                    toOmni: (m) => `fn ${m[1]}(${m[2] || ''}) {\n}`
                },
                {
                    name: 'express_route',
                    regex: /(?:app|router)\.(get|post|put|delete)\(['"]([^'"]+)['"]/,
                    toOmni: (m) => `@server.${m[1]}("${m[2]}")\nflow handler()`
                },
                {
                    name: 'nextjs_api',
                    regex: /export\s+(?:async\s+)?function\s+(GET|POST|PUT|DELETE)/,
                    toOmni: (m) => `@server.${m[1].toLowerCase()}("/")\nflow handler()`
                },
                {
                    name: 'react_component',
                    regex: /(?:export\s+)?(?:default\s+)?function\s+(\w+)\s*\(\s*(?:\{[^}]*\}|props)?\s*\)/,
                    toOmni: (m) => `@ui.component\nfn ${m[1]}() {\n}`
                }
            ],
            
            // Python Patterns
            python: [
                {
                    name: 'class_definition',
                    regex: /class\s+(\w+)(?:\((\w+)\))?:/,
                    toOmni: (m) => `struct ${m[1]} {\n}`
                },
                {
                    name: 'function_definition',
                    regex: /def\s+(\w+)\s*\((.*?)\)(?:\s*->\s*(\w+))?:/,
                    toOmni: (m) => `fn ${m[1]}(${m[2] || ''}) ${m[3] ? '-> ' + m[3] : ''} {\n}`
                },
                {
                    name: 'fastapi_get',
                    regex: /@app\.get\(['"]([^'"]+)['"]\)[\s\S]*?(?:async\s+)?def\s+(\w+)/,
                    toOmni: (m) => `@server.get("${m[1]}")\nflow ${m[2]}()`
                },
                {
                    name: 'django_model',
                    regex: /class\s+(\w+)\(models\.Model\):/,
                    toOmni: (m) => `@entity\nstruct ${m[1]} {\n    id: i64\n}`
                },
                {
                    name: 'sqlalchemy_model',
                    regex: /class\s+(\w+)\(Base\):/,
                    toOmni: (m) => `@entity\nstruct ${m[1]} {\n    id: i64\n}`
                }
            ]
        };
        
        // Load external patterns from patterns/ directory
        const fs = require('fs');
        const path = require('path');
        const patternsDir = path.join(__dirname, '..', 'patterns');
        
        if (fs.existsSync(patternsDir)) {
            const files = fs.readdirSync(patternsDir).filter(f => f.endsWith('.json'));
            
            for (const file of files) {
                try {
                    const content = JSON.parse(fs.readFileSync(path.join(patternsDir, file), 'utf-8'));
                    const lang = content.language || path.basename(file, '.json');
                    
                    if (!db.patterns[lang]) {
                        db.patterns[lang] = [];
                    }
                    
                    // Add patterns from external file
                    for (const pattern of (content.patterns || [])) {
                        db.patterns[lang].push({
                            name: pattern.name,
                            regex: new RegExp(pattern.regex, pattern.flags || ''),
                            toOmni: (m) => {
                                let result = pattern.template;
                                for (let i = 0; i < m.length; i++) {
                                    result = result.replace(new RegExp('\\{' + i + '\\}', 'g'), m[i] || '');
                                }
                                return result;
                            }
                        });
                    }
                    
                    console.log("[ingest] Loaded external patterns: " + lang);
                } catch (e) {
                    console.warn("[ingest] Failed to load patterns from " + file + ": " + e.message);
                }
            }
        }
    }
    
    return db;
}

// ============================================================================
// INGESTION ENGINE
// ============================================================================

struct IngestionEngine {
    patterns: PatternDatabase,
    source_language: string,
    detected_patterns: any,
    omni_output: string,
    confidence_score: i64
}

fn IngestionEngine_new(source_lang: string) -> IngestionEngine {
    return IngestionEngine {
        patterns: PatternDatabase_new(),
        source_language: source_lang,
        detected_patterns: [],
        omni_output: "",
        confidence_score: 0
    };
}

fn IngestionEngine_detect_language(source: string) -> string {
    let lang = "unknown";
    
    native "js" {
        // Heuristic language detection
        if (source.includes('<?php') || source.includes('<?=')) {
            lang = 'php';
        } else if (source.includes('public class') || source.includes('import java.')) {
            lang = 'java';
        } else if (source.includes('def ') && source.includes(':') && !source.includes('{')) {
            lang = 'python';
        } else if (source.includes('function') || source.includes('=>') || source.includes('const ')) {
            lang = 'javascript';
        } else if (source.includes('fn ') || source.includes('let ') || source.includes('use ')) {
            if (source.includes('->') && source.includes('::')) {
                lang = 'rust';
            }
        }
    }
    
    return lang;
}

fn IngestionEngine_analyze(self: IngestionEngine, source: string) {
    native "js" {
        const patterns = self.patterns.patterns[self.source_language] || [];
        self.detected_patterns = [];
        
        for (const pattern of patterns) {
            const matches = source.match(new RegExp(pattern.regex, 'gm'));
            if (matches) {
                for (const match of matches) {
                    const groups = match.match(pattern.regex);
                    if (groups) {
                        self.detected_patterns.push({
                            pattern: pattern.name,
                            match: match,
                            omni: pattern.toOmni(groups)
                        });
                    }
                }
            }
        }
        
        // Calculate confidence based on pattern coverage
        if (self.detected_patterns.length > 0) {
            self.confidence_score = Math.min(100, self.detected_patterns.length * 15);
        }
    }
}

fn IngestionEngine_generate_omni(self: IngestionEngine) -> string {
    let output = "";
    
    native "js" {
        output = "// ============================================================================\n";
        output += "// AUTO-GENERATED OMNI CODE\n";
        output += "// Source Language: " + self.source_language.toUpperCase() + "\n";
        output += "// Confidence Score: " + self.confidence_score + "%\n";
        output += "// Patterns Detected: " + self.detected_patterns.length + "\n";
        output += "// ============================================================================\n\n";
        
        // Group by pattern type
        const structs = [];
        const capsules = [];
        const functions = [];
        const flows = [];
        
        for (const detected of self.detected_patterns) {
            const omni = detected.omni;
            if (omni.includes('@entity') || omni.includes('struct')) {
                structs.push(omni);
            } else if (omni.includes('capsule') || omni.includes('@server')) {
                capsules.push(omni);
            } else if (omni.includes('flow')) {
                flows.push(omni);
            } else if (omni.includes('fn ')) {
                functions.push(omni);
            }
        }
        
        // Output in logical order
        if (structs.length > 0) {
            output += "// === ENTITIES ===\n\n";
            output += structs.join('\n\n') + '\n\n';
        }
        
        if (capsules.length > 0 || flows.length > 0) {
            output += "// === CAPSULES ===\n\n";
            output += capsules.join('\n\n') + '\n';
            output += flows.join('\n') + '\n\n';
        }
        
        if (functions.length > 0) {
            output += "// === FUNCTIONS ===\n\n";
            output += functions.join('\n\n') + '\n\n';
        }
        
        // Add main if no capsules
        if (capsules.length === 0) {
            output += "fn main() {\n";
            output += "    // TODO: Implement main logic\n";
            output += "}\n";
        }
        
        self.omni_output = output;
    }
    
    return output;
}

fn IngestionEngine_report(self: IngestionEngine) {
    native "js" {
        console.log("\n┌────────────────────────────────────────────┐");
        console.log("│        INGESTION ANALYSIS REPORT           │");
        console.log("├────────────────────────────────────────────┤");
        console.log("│ Source Language: " + self.source_language.toUpperCase().padEnd(25) + "│");
        console.log("│ Patterns Found:  " + String(self.detected_patterns.length).padEnd(25) + "│");
        console.log("│ Confidence:      " + (self.confidence_score + "%").padEnd(25) + "│");
        console.log("└────────────────────────────────────────────┘");
        console.log("\nDetected Patterns:");
        
        const patternCounts = {};
        for (const p of self.detected_patterns) {
            patternCounts[p.pattern] = (patternCounts[p.pattern] || 0) + 1;
        }
        
        for (const [name, count] of Object.entries(patternCounts)) {
            console.log("  • " + name + ": " + count);
        }
    }
}

// ============================================================================
// INGEST COMMAND FUNCTION
// ============================================================================

fn cmd_ingest(input_file: string, output_file: string) {
    CLI_header("Omni Ingestion Engine");
    CLI_info("Analyzing: " + input_file);
    
    let source = read_file(input_file);
    
    // Detect language
    let lang = IngestionEngine_detect_language(source);
    CLI_info("Detected language: " + lang);
    
    if (lang == "unknown") {
        CLI_error("Could not detect source language");
        return;
    }
    
    // Create engine and analyze
    let engine = IngestionEngine_new(lang);
    IngestionEngine_analyze(engine, source);
    
    // Generate report
    IngestionEngine_report(engine);
    
    // Generate Omni code
    let omni_code = IngestionEngine_generate_omni(engine);
    
    // Write output
    write_file(output_file, omni_code);
    
    CLI_success("Generated: " + output_file);
    CLI_info("Review the generated code and add missing implementation details.");
}

// ============================================================================
// EXPORTS
// ============================================================================

export IngestionEngine;
export IngestionEngine_new;
export IngestionEngine_detect_language;
export IngestionEngine_analyze;
export IngestionEngine_generate_omni;
export IngestionEngine_report;
export PatternDatabase;
export CanonicalPattern;
export cmd_ingest;
