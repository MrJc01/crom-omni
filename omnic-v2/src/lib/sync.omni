// Omni StdLib - Synchronization Primitives
// Cross-platform Channel for inter-process communication

native "js" {
const { Worker, isMainThread, parentPort, workerData, MessageChannel } = require('worker_threads');

class Channel {
    constructor() {
        this.queue = [];
        this.waiters = [];
    }
    
    send(value) {
        if (this.waiters.length > 0) {
            const resolve = this.waiters.shift();
            resolve(value);
        } else {
            this.queue.push(value);
        }
    }
    
    async receive() {
        if (this.queue.length > 0) {
            return this.queue.shift();
        }
        return new Promise(resolve => {
            this.waiters.push(resolve);
        });
    }
    
    tryReceive() {
        return this.queue.length > 0 ? this.queue.shift() : null;
    }
    
    get length() {
        return this.queue.length;
    }
}

// Worker setup for spawn
if (!isMainThread && workerData) {
    const { fn, args } = workerData;
    // The function should be defined in the compiled code
    if (typeof global[fn] === 'function') {
        const result = global[fn](...args);
        parentPort.postMessage(result);
    }
}

// Export
if (typeof module !== 'undefined') {
    module.exports = { Channel, isMainThread, parentPort, workerData };
}
if (typeof global !== 'undefined') {
    global.Channel = Channel;
}
}

native "python" {
from multiprocessing import Process, Queue as MPQueue
from threading import Thread
from queue import Queue

class Channel:
    def __init__(self):
        self.queue = Queue()
    
    def send(self, value):
        self.queue.put(value)
    
    def receive(self):
        return self.queue.get()
    
    def try_receive(self):
        if not self.queue.empty():
            return self.queue.get_nowait()
        return None
    
    @property
    def length(self):
        return self.queue.qsize()

def spawn(fn, *args):
    """Spawn a function in a new process"""
    def worker(queue, fn, args):
        result = fn(*args)
        queue.put(result)
    
    queue = MPQueue()
    p = Process(target=worker, args=(queue, fn, args))
    p.start()
    return queue
}
