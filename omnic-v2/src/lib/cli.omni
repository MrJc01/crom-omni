// ============================================================================
// OMNI CLI LIBRARY - Terminal Colors, Spinners, and Argument Parsing
// Version: 1.2.0 - Rust Parser Compatible
// ============================================================================

// ============================================================================
// ANSI COLOR CODES
// ============================================================================

struct Colors {
    reset: string,
    bold: string,
    dim: string,
    underline: string,
    
    // Foreground colors
    black: string,
    red: string,
    green: string,
    yellow: string,
    blue: string,
    magenta: string,
    cyan: string,
    white: string,
    
    // Background colors
    bg_black: string,
    bg_red: string,
    bg_green: string,
    bg_yellow: string,
    bg_blue: string,
    bg_magenta: string,
    bg_cyan: string,
    bg_white: string
}

fn Colors_new() -> Colors {
    let c = Colors {
        reset: "",
        bold: "",
        dim: "",
        underline: "",
        black: "",
        red: "",
        green: "",
        yellow: "",
        blue: "",
        magenta: "",
        cyan: "",
        white: "",
        bg_black: "",
        bg_red: "",
        bg_green: "",
        bg_yellow: "",
        bg_blue: "",
        bg_magenta: "",
        bg_cyan: "",
        bg_white: ""
    };
    
    native "js" {
        // Check if terminal supports colors
        const supportsColor = process.stdout.isTTY && 
            (process.env.TERM !== 'dumb') && 
            !process.env.NO_COLOR;
        
        if (supportsColor) {
            c.reset = '\x1b[0m';
            c.bold = '\x1b[1m';
            c.dim = '\x1b[2m';
            c.underline = '\x1b[4m';
            
            c.black = '\x1b[30m';
            c.red = '\x1b[31m';
            c.green = '\x1b[32m';
            c.yellow = '\x1b[33m';
            c.blue = '\x1b[34m';
            c.magenta = '\x1b[35m';
            c.cyan = '\x1b[36m';
            c.white = '\x1b[37m';
            
            c.bg_black = '\x1b[40m';
            c.bg_red = '\x1b[41m';
            c.bg_green = '\x1b[42m';
            c.bg_yellow = '\x1b[43m';
            c.bg_blue = '\x1b[44m';
            c.bg_magenta = '\x1b[45m';
            c.bg_cyan = '\x1b[46m';
            c.bg_white = '\x1b[47m';
        }
    }
    
    return c;
}

// Global colors instance - initialized lazily
let CLI_COLORS_INIT = false;
let CLI_COLORS_CACHE = Colors {
    reset: "",
    bold: "",
    dim: "",
    underline: "",
    black: "",
    red: "",
    green: "",
    yellow: "",
    blue: "",
    magenta: "",
    cyan: "",
    white: "",
    bg_black: "",
    bg_red: "",
    bg_green: "",
    bg_yellow: "",
    bg_blue: "",
    bg_magenta: "",
    bg_cyan: "",
    bg_white: ""
};

fn CLI_COLORS() -> Colors {
    if (CLI_COLORS_INIT == false) {
        CLI_COLORS_CACHE = Colors_new();
        CLI_COLORS_INIT = true;
    }
    return CLI_COLORS_CACHE;
}

// ============================================================================
// CLI OUTPUT HELPERS
// ============================================================================

fn CLI_success(msg: string) {
    native "js" {
        const c = CLI_COLORS();
        console.log(c.green + 'âœ“' + c.reset + ' ' + msg);
    }
}

fn CLI_error(msg: string) {
    native "js" {
        const c = CLI_COLORS();
        console.error(c.red + 'âœ—' + c.reset + ' ' + msg);
    }
}

fn CLI_warning(msg: string) {
    native "js" {
        const c = CLI_COLORS();
        console.log(c.yellow + 'âš ' + c.reset + ' ' + msg);
    }
}

fn CLI_info(msg: string) {
    native "js" {
        const c = CLI_COLORS();
        console.log(c.blue + 'â„¹' + c.reset + ' ' + msg);
    }
}

fn CLI_step(step: i64, total: i64, msg: string) {
    native "js" {
        const c = CLI_COLORS();
        const prefix = c.cyan + '[' + step + '/' + total + ']' + c.reset;
        console.log(prefix + ' ' + msg);
    }
}

fn CLI_header(title: string) {
    native "js" {
        const c = CLI_COLORS();
        console.log('');
        console.log(c.bold + c.cyan + 'â•â•â• ' + title + ' â•â•â•' + c.reset);
        console.log('');
    }
}

fn CLI_dim(msg: string) -> string {
    let result = "";
    native "js" {
        const c = CLI_COLORS();
        result = c.dim + msg + c.reset;
    }
    return result;
}

fn CLI_bold(msg: string) -> string {
    let result = "";
    native "js" {
        const c = CLI_COLORS();
        result = c.bold + msg + c.reset;
    }
    return result;
}

fn CLI_green(msg: string) -> string {
    let result = "";
    native "js" {
        const c = CLI_COLORS();
        result = c.green + msg + c.reset;
    }
    return result;
}

fn CLI_red(msg: string) -> string {
    let result = "";
    native "js" {
        const c = CLI_COLORS();
        result = c.red + msg + c.reset;
    }
    return result;
}

fn CLI_yellow(msg: string) -> string {
    let result = "";
    native "js" {
        const c = CLI_COLORS();
        result = c.yellow + msg + c.reset;
    }
    return result;
}

fn CLI_cyan(msg: string) -> string {
    let result = "";
    native "js" {
        const c = CLI_COLORS();
        result = c.cyan + msg + c.reset;
    }
    return result;
}

// ============================================================================
// PROGRESS SPINNER
// ============================================================================

struct Spinner {
    frames: string,
    current: i64,
    interval: i64,
    message: string,
    running: bool
}

fn Spinner_new(message: string) -> Spinner {
    let spinner = Spinner {
        frames: "â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â ",
        current: 0,
        interval: 0,
        message: message,
        running: false
    };
    return spinner;
}

fn Spinner_start(self: Spinner) {
    native "js" {
        if (self.running) return;
        self.running = true;
        const frames = self.frames.split('');
        const c = CLI_COLORS();
        
        self.interval = setInterval(() => {
            process.stdout.write('\r' + c.cyan + 
                frames[self.current % frames.length] + c.reset + 
                ' ' + self.message);
            self.current = (self.current + 1) % frames.length;
        }, 80);
    }
}

fn Spinner_stop(self: Spinner, success: bool) {
    native "js" {
        if (!self.running) return;
        
        clearInterval(self.interval);
        self.running = false;
        const c = CLI_COLORS();
        
        const icon = success 
            ? c.green + 'âœ“' + c.reset 
            : c.red + 'âœ—' + c.reset;
        
        process.stdout.write('\r' + icon + ' ' + self.message + '\n');
    }
}

// ============================================================================
// PROGRESS BAR
// ============================================================================

fn CLI_progress_bar(current: i64, total: i64, width: i64) -> string {
    let result = "";
    native "js" {
        const c = CLI_COLORS();
        const percent = Math.floor((current / total) * 100);
        const filled = Math.floor((current / total) * width);
        const empty = width - filled;
        
        const bar = c.green + 'â–ˆ'.repeat(filled) + 
                    c.dim + 'â–‘'.repeat(empty) + c.reset;
        
        result = bar + ' ' + percent + '%';
    }
    return result;
}

// ============================================================================
// ARGUMENT PARSER (Simplified - uses native JS for complex parsing)
// ============================================================================

struct ParsedArgs {
    command: string,
    arg1: string,
    arg2: string,
    arg3: string,
    flag_help: bool,
    flag_version: bool,
    flag_verbose: bool,
    flag_global: bool,
    flag_app: bool,
    flag_tui: bool,
    opt_target: string,
    opt_port: string,
    opt_framework: string
}

fn ParsedArgs_new() -> ParsedArgs {
    let args = ParsedArgs {
        command: "",
        arg1: "",
        arg2: "",
        arg3: "",
        flag_help: false,
        flag_version: false,
        flag_verbose: false,
        flag_global: false,
        flag_app: false,
        flag_tui: false,
        opt_target: "js",
        opt_port: "3000",
        opt_framework: ""
    };
    
    native "js" {
        const argv = process.argv.slice(2);
        
        let positional = [];
        for (let i = 0; i < argv.length; i++) {
            const arg = argv[i];
            
            if (arg === '--help' || arg === '-h') {
                args.flag_help = true;
            } else if (arg === '--version' || arg === '-v') {
                args.flag_version = true;
            } else if (arg === '--verbose' || arg === '-V') {
                args.flag_verbose = true;
            } else if (arg === '--global' || arg === '-g') {
                args.flag_global = true;
            } else if (arg === '--app') {
                args.flag_app = true;
            } else if (arg === '--tui') {
                args.flag_tui = true;
            } else if (arg === '--target' && argv[i + 1]) {
                args.opt_target = argv[++i];
            } else if (arg === '--port' && argv[i + 1]) {
                args.opt_port = argv[++i];
            } else if (arg === '--framework' && argv[i + 1]) {
                args.opt_framework = argv[++i];
            } else if (!arg.startsWith('-')) {
                positional.push(arg);
            }
        }
        
        args.command = positional[0] || '';
        args.arg1 = positional[1] || '';
        args.arg2 = positional[2] || '';
        args.arg3 = positional[3] || '';
    }
    
    return args;
}

// ============================================================================
// TABLE FORMATTER
// ============================================================================

fn CLI_table_simple(col1: string, col2: string) {
    native "js" {
        const c = CLI_COLORS();
        console.log('  ' + c.cyan + col1.padEnd(20) + c.reset + col2);
    }
}

fn CLI_table_header(title: string) {
    native "js" {
        const c = CLI_COLORS();
        console.log('');
        console.log(c.bold + title + c.reset);
        console.log('â”€'.repeat(50));
    }
}

// ============================================================================
// VERSION AND BANNER
// ============================================================================

fn CLI_banner() {
    native "js" {
        const c = CLI_COLORS();
        console.log('');
        console.log(c.cyan + c.bold + 
            '   ____  __  __ _   _ ___ ' + c.reset);
        console.log(c.cyan + 
            '  / __ \\|  \\/  | \\ | |_ _|' + c.reset);
        console.log(c.cyan + 
            ' | |  | | |\\/| |  \\| || | ' + c.reset);
        console.log(c.cyan + 
            ' | |__| | |  | | |\\  || | ' + c.reset);
        console.log(c.cyan + 
            '  \\____/|_|  |_|_| \\_|___|' + c.reset);
        console.log('');
        console.log(c.dim + 
            '  Hybrid Metamorphosis Compiler' + c.reset);
        console.log('');
    }
}

fn CLI_version() -> string {
    return "1.2.0";
}
