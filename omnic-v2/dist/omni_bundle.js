'use strict';
// Omni Compiler Bundle
// Global Header: Core Node.js dependencies
const path = require('path');
const fs = require('fs');
const { execSync } = require('child_process');
const http = require('http');
const https = require('https');
const readline = require('readline');
const child_process = require('child_process'); // Expose full module




const codegen_hybrid_impl = {
    LanguageProfile_load_impl: function(self) {
        // Try multiple paths for profile
        const paths = [
            path.join(__dirname, '..', 'targets', self.name + '.json'),
            path.join(__dirname, '..', '..', 'targets', self.name + '.json'),
            path.join(process.cwd(), 'targets', self.name + '.json')
        ];
        
        let profile = null;
        for (const p of paths) {
            if (fs.existsSync(p)) {
                profile = JSON.parse(fs.readFileSync(p, 'utf-8'));
                break;
            }
        }
        
        if (profile) {
            self.extension = profile.extension || '.txt';
            self.templates = profile.templates || {};
            self.type_map = profile.type_map || {};
            self.operators = profile.operators || {};
            self.indent_str = profile.indent || '    ';
            self.statement_end = profile.statement_end || ';';
            self.loaded = true;
        } else {
            // Fallback defaults for JavaScript
            self.extension = '.js';
            self.templates = {
                program_header: "// Generated by Omni Compiler\n'use strict';\n\n",
                fn_decl: "function {name}({params}) {\n{body}\n}",
                let_decl: "let {name} = {value};",
                return_stmt: "return {value};",
                if_stmt: "if ({condition}) {\n{consequence}\n}",
                if_else_stmt: "if ({condition}) {\n{consequence}\n} else {\n{alternative}\n}",
                while_stmt: "while ({condition}) {\n{body}\n}",
                class_decl: "class {name} {\n{body}\n}",
                call_expr: "{callee}({args})",
                binary_expr: "{left} {op} {right}",
                bool_true: "true",
                bool_false: "false",
                null: "null"
            };
            self.type_map = { i64: "number", string: "string", bool: "boolean" };
            self.operators = { eq: "===", neq: "!==", and: "&&", or: "||" };
            self.loaded = true;
        }
        return self;
    },

    LanguageProfile_render_impl: function(self, template_name, data) {
        const template = self.templates[template_name];
        if (!template) {
            return "/* Template '" + template_name + "' not found */";
        }
        return template.replace(/\{(\w+)\}/g, (_, key) => {
            return data.hasOwnProperty(key) ? data[key] : '';
        });
    },

    LanguageProfile_map_operator_impl: function(self, op) {
        const opMap = { '==': 'eq', '!=': 'neq', '&&': 'and', '||': 'or', '<': 'lt', '>': 'gt' };
        const key = opMap[op];
        if (key && self.operators[key]) {
            return self.operators[key];
        }
        return op;
    },

    HybridCodeGenerator_indent_impl: function(self, code) {
        const prefix = self.profile.indent_str.repeat(self.indent_level);
        return code.split('\n').map(line => line ? prefix + line : line).join('\n');
    },

    check_native_lang: function(self, stmt) {
        let lang = stmt.lang || 'js';
        // Strip quotes if present
        if ((lang.startsWith('"') && lang.endsWith('"')) || (lang.startsWith("'") && lang.endsWith("'"))) {
            lang = lang.substring(1, lang.length - 1);
        }
        
        const targetLang = self.profile.name;
        
        // Check if lang matches
        if (lang === 'js' || lang === 'javascript') {
            if (targetLang !== 'js' && targetLang !== 'javascript') return "";
        } else if (lang === 'py' || lang === 'python') {
            if (targetLang !== 'py' && targetLang !== 'python') return "";
        } else if (lang !== targetLang) {
            return "";
        }

        // Language matched, strip common indentation
        let code = stmt.code;
        if (!code) return "";
        
        const lines = code.split('\n');
        // Find min indent (ignoring first line if it starts immediately after brace, but parser usually captures full block string)
        // Actually, parser captures text between braces.
        
        const nonEmptyLines = lines.filter(l => l.trim().length > 0);
        if (nonEmptyLines.length > 0) {
            const minIndent = nonEmptyLines.reduce((min, line) => {
                const match = line.match(/^\s*/);
                const indent = match ? match[0].length : 0;
                return indent < min ? indent : min;
                return indent < min ? indent : min;
            }, Infinity);

            try {
                const debugPath = path.join('c:', 'Users', 'juanc', '.gemini', 'dedent_debug.txt');
                fs.appendFileSync(debugPath, "MinIndent: " + minIndent + "\nCode:\n" + JSON.stringify(code) + "\n----------------\n");
            } catch(e) {}

            if (minIndent > 0 && minIndent !== Infinity) {
                code = lines.map(line => {
                    if (line.trim().length === 0) return ''; 
                    // Verify if line actually has that indent
                    return line.length >= minIndent ? line.substring(minIndent) : line;
                }).join('\n');
            }
        }
        
        return code;
    },

    gen_expression_literal: function(self, expr) {
        let val = String(expr.value);
        if (val === 'true') val = self.profile.templates.bool_true || 'true';
        if (val === 'false') val = self.profile.templates.bool_false || 'false';
        if (val === 'null') val = self.profile.templates.null || 'null';
        return val;
    },

    gen_expression_bool: function(self, expr) {
        return expr.value ? 
            (self.profile.templates.bool_true || 'true') : 
            (self.profile.templates.bool_false || 'false');
    },

    gen_struct_body: function(stmt, generator_param) {
        // Safe access to profile name if generator_param passed as first arg in some contexts, 
        // but here 'stmt' is first arg, 'generator_param' (impl 'self') is likely context.
        // Actually, looking at call site in codegen_hybrid.omni: 
        // result = impl.HybridCodeGenerator_gen_statement_impl(self, stmt); -> calls specific gen functions?
        // No, verify call site. 
        // struct definition usually handled elsewhere. 
        // Wait, 'gen_struct_body' is likely called from 'LanguageProfile_render' or similar.
        
        // Let's look at how it's called. It might not have access to 'self' (generator).
        // However, we can handle it if we knew the target.
        
        // Assuming 'this' context or we need to pass target.
        // Let's make it robust using global target if needed, or better, use 'self' if passed.
        
        // Looking at line 101: gen_expression_literal: function(self, expr)
        // It seems 'self' is passed as first arg in many functions.
        // But 'gen_struct_body: function(stmt)' at line 115 only has stmt.
        
        // I need to check where gen_struct_body is called.
        // If it's a template helper, it might be hard.
        
        // Workaround: Check global.OMNI_TARGET
        let is_python = (typeof global !== 'undefined' && (global.OMNI_TARGET === 'python' || global.OMNI_TARGET === 'py'));
        if (typeof process !== 'undefined' && process.argv && process.argv.some(a => a === '--app' || a === '--python' || (typeof a === 'string' && a.endsWith('.py')))) {
             is_python = true;
        }

        let constructor_body = "";
        let selfRef = is_python ? "self" : "this";
        
        for (const field of stmt.fields || []) {
            if (is_python) {
                constructor_body += "        " + selfRef + "." + field.name + " = data.get('" + field.name + "')\n";
                // Or data['field'] if we are sure it exists. data.get returns None if missing, which matches `data=None` default logic somewhat.
                // But data={} default. data.get is safer.
                // Original JS was data.field. 
            } else {
                constructor_body += "        " + selfRef + "." + field.name + " = data." + field.name + ";\n";
            }
        }
        return constructor_body;
    },

    gen_entity_repo: function(stmt) {
        const name = stmt.name;
        const fields = (stmt.fields || []).filter(f => f.name !== 'id').map(f => f.name);
        
        // Use let in generated code for modern JS
        let out = "\n// @entity Repository: " + name + "\n";
        out += name + ".find = async (id) => {\n";
        out += "    let db = await Database.get('main_db');\n";
        out += "    let row = await db.get('SELECT * FROM " + name + " WHERE id = ?', [id]);\n";
        out += "    return row ? new " + name + "(row) : null;\n";
        out += "};\n\n";
        
        out += name + ".all = async () => {\n";
        out += "    let db = await Database.get('main_db');\n";
        out += "    return (await db.all('SELECT * FROM " + name + "')).map(r => new " + name + "(r));\n";
        out += "};\n";
        return out;
    },

    gen_capsule: function(stmt) {
        const name = stmt.name;
        let flows = "";
        const flowDefs = stmt.flows || [];
        const flow_list = flowDefs.map(f => "'" + f.name + "'").join(', ');
        
        for (const flow of flowDefs) {
            const params = flow.params.map(p => p.name).join(', ');
            const paramJson = flow.params.map(p => p.name + ": " + p.name).join(', ');
            
            flows += "    async " + flow.name + "(" + params + ") {\n";
            flows += "        let route = TopologyResolver.resolve('" + name + "');\n";
            flows += "        if (route.local) {\n";
            flows += "            return this._impl_" + flow.name + "(" + params + ");\n";
            flows += "        } else {\n";
            flows += "            let response = await fetch(route.url + '/" + name + "/" + flow.name + "', {\n";
            flows += "                method: 'POST',\n";
            flows += "                headers: { 'Content-Type': 'application/json' },\n";
            flows += "                body: JSON.stringify({ " + paramJson + " })\n";
            flows += "            });\n";
            flows += "            return await response.json();\n";
            flows += "        }\n";
            flows += "    },\n\n";
            
            flows += "    _impl_" + flow.name + "(" + params + ") {\n";
            flows += "        throw new Error('" + name + "." + flow.name + " not implemented');\n";
            flows += "    },\n\n";
        }
        
        let out = "// Capsule: " + name + "\n";
        out += "const " + name + " = {\n";
        out += "    _name: '" + name + "',\n";
        out += "    _flows: [" + flow_list + "],\n\n";
        out += flows;
        out += "};\n";
        return out;
    },

    gen_spawn_code: function(fn_name, args_str) {
        let out = "(() => {\n";
        out += "    const { Worker } = require('worker_threads');\n";
        out += "    let worker = new Worker(__filename, {\n";
        out += "        workerData: { fn: '" + fn_name + "', args: [" + args_str + "] }\n";
        out += "    });\n";
        out += "    worker.on('message', r => console.log('[spawn] " + fn_name + " done:', r));\n";
        out += "    worker.on('error', e => console.error('[spawn] " + fn_name + " error:', e));\n";
        out += "})()";
        return out;
    },

    gen_service_client: function(stmt) {
        const name = stmt.name;
        let methods = "";
        
        for (const method of stmt.methods || []) {
            const params = method.params ? method.params.map(p => p.name).join(', ') : '';
            methods += "    async " + method.name + "(" + params + ") {\n";
            methods += "        let url = Discovery.resolve('" + name + "');\n";
            methods += "        let response = await fetch(url + '/" + name + "/" + method.name + "', {\n";
            methods += "            method: 'POST',\n";
            methods += "            headers: { 'Content-Type': 'application/json' },\n";
            methods += "            body: JSON.stringify({ " + params + " })\n";
            methods += "        });\n";
            methods += "        return await response.json();\n";
            methods += "    },\n";
        }
        
        return "// @service RPC Client: " + name + "\n" +
               "const " + name + " = {\n" + methods + "};\n";
    },

    gen_import: function(stmt, generator_param) { // Renamed parameter to avoid clash
        let module_path = stmt.path || stmt.module || '';
        module_path = module_path.replace(/^['"]|['"]$/g, '');
        const alias = stmt.alias || module_path.split('/').pop().replace('.omni', '');
        // console.log('[DEBUG GEN_IMPORT] module_path = "' + module_path + '"');
        
        // Resolve target
        let target = 'js';
        if (generator_param && generator_param.profile && generator_param.profile.name) {
             target = generator_param.profile.name;
        } else if (typeof generator_param === 'string') {
             target = generator_param; // Backwards compat if string passed
        } else if (typeof global !== 'undefined' && global.OMNI_TARGET) {
             target = global.OMNI_TARGET; // Workaround from cmd_run
        }
        
        // Fallback detection from process.argv when generator is not passed
        if (target === 'js') {
             if (typeof process !== 'undefined' && process.argv && process.argv.some(a => a === '--app' || a === '--python' || (typeof a === 'string' && a.endsWith('.py')))) {
                 target = 'python';
             }
        }
        
        // Inline bundling for std/ imports
        if (module_path.startsWith('std/') || module_path.startsWith('std\\')) {
            // Find the std/ folder
            let projectRoot = process.cwd();
            // Need to handle if running from dist/ or root
            // If projectRoot has omnic-v2 then go up? 
            // Assume process.cwd() is project root where command is run
            
            let stdPath = path.join(projectRoot, module_path);
            // console.log('[DEBUG] Inline bundling: ' + module_path + ' -> ' + stdPath);
            
            // Try parent directories if not found (search up 5 levels)
            if (!fs.existsSync(stdPath)) {
                let dir = projectRoot;
                for (let i = 0; i < 5; i++) {
                    dir = path.dirname(dir);
                    stdPath = path.join(dir, module_path);
                    if (fs.existsSync(stdPath)) break;
                }
            }
            
            if (fs.existsSync(stdPath)) {
                try {
                    const source = fs.readFileSync(stdPath, 'utf-8');
                    
                    // Helper to get function or require it safely
                    const get_fn = (name, modPath, subPath) => {
                        if (typeof global[name] === 'function') return global[name];
                        try {
                            // Try local scope (eval hack if needed? no, check typeof directly above)
                            // If we are here, typeof check failed.
                            // Try require
                            try { return require(modPath)[name]; } catch (e) {}
                            try { return require(subPath)[name]; } catch (e) {}
                        } catch (e) {}
                        return undefined;
                    };
                    
                    // Direct typeof check works if in same scope (hoisted)
                    // But if this obj is defined BEFORE lexer, hoisting works.

                    // Check for components using correct names (from src/*.omni)
                    // Note: dist files export these names.
                    const new_lexer_fn = (typeof new_lexer !== 'undefined') ? new_lexer : 
                                         (typeof global.new_lexer !== 'undefined') ? global.new_lexer :
                                         require('./core/lexer.js').new_lexer;
                                         
                    const new_parser_fn = (typeof new_parser !== 'undefined') ? new_parser : 
                                          (typeof global.new_parser !== 'undefined') ? global.new_parser :
                                          require('./core/parser.js').new_parser;
                                          
                    const parse_program_fn = (typeof Parser_parse_program !== 'undefined') ? Parser_parse_program : 
                                            (typeof global.Parser_parse_program !== 'undefined') ? global.Parser_parse_program :
                                            require('./core/parser.js').Parser_parse_program;
                                            
                    const Hybrid_new_fn = (typeof HybridCodeGenerator_new !== 'undefined') ? HybridCodeGenerator_new : 
                                          (typeof global.HybridCodeGenerator_new !== 'undefined') ? global.HybridCodeGenerator_new :
                                          require('./core/codegen_hybrid.js').HybridCodeGenerator_new;
                                          
                    const Hybrid_gen_fn = (typeof HybridCodeGenerator_gen_statement !== 'undefined') ? HybridCodeGenerator_gen_statement : 
                                          (typeof global.HybridCodeGenerator_gen_statement !== 'undefined') ? global.HybridCodeGenerator_gen_statement :
                                          require('./core/codegen_hybrid.js').HybridCodeGenerator_gen_statement;
                    
                    const lexer = new_lexer_fn(source);
                    const parser = new_parser_fn(lexer);
                    const ast = parse_program_fn(parser);
                    
                    // Generate inline code using hybrid generator
                    // console.log("DEBUG TARGET: " + target);
                    let generator = Hybrid_new_fn(target); // This is a local variable, distinct from generator_param
                    let commentStart = (target === 'py' || target === 'python') ? "#" : "//";
                    let code = commentStart + " ===== INLINE: " + module_path + " =====\n";
                    
                    if (ast && ast.statements) {
                        for (const s of ast.statements) {
                            // Skip import statements in imported files to avoid recursion issues
                            if (s.kind === 10) continue; // NODE_IMPORT = 10
                            generator.indent_level = 0; // Force reset to prevent drift
                            let stmtCode = Hybrid_gen_fn(generator, s);
                            if (stmtCode) code += stmtCode + "\n";
                        }
                    }
                    code += commentStart + " ===== END: " + module_path + " =====\n";
                    return code;
                } catch (e) {
                    const msg = (e.message || String(e)).replace(/\n/g, ' ');
                    const stack = (e.stack || "").split('\n').map(l => "// " + l).join('\n');
                    return "// [ERROR] Failed to inline " + module_path + ": " + msg + "\n" + stack;
                }
            } else {
                return "// [WARN] Could not find: " + module_path + " (searched " + stdPath + ")";
            }
        }
        
        // Fallback for non-std imports
        return "// MARKER: Hybrid Import\n" + 
               "const " + alias + " = require(\"" + module_path + "\");\n" +
               "if (typeof global !== 'undefined') Object.assign(global, " + alias + ");";
    }
};



let TOKEN_EOF = 0;
let TOKEN_ILLEGAL = 1;
let TOKEN_IDENTIFIER = 10;
let TOKEN_INT = 11;
let TOKEN_STRING = 12;
let TOKEN_ASSIGN = 20;
let TOKEN_PLUS = 21;
let TOKEN_MINUS = 22;
let TOKEN_BANG = 23;
let TOKEN_ASTERISK = 24;
let TOKEN_SLASH = 25;
let TOKEN_LT = 26;
let TOKEN_GT = 27;
let TOKEN_EQ = 28;
let TOKEN_NOT_EQ = 29;
let TOKEN_COLON = 30;
let TOKEN_DOT = 31;
let TOKEN_AND = 32;
let TOKEN_OR = 33;
let TOKEN_LE = 34;
let TOKEN_GE = 35;
let TOKEN_COMMA = 40;
let TOKEN_SEMICOLON = 41;
let TOKEN_LPAREN = 42;
let TOKEN_RPAREN = 43;
let TOKEN_LBRACE = 44;
let TOKEN_RBRACE = 45;
let TOKEN_LBRACKET = 46;
let TOKEN_RBRACKET = 47;
let TOKEN_FN = 60;
let TOKEN_LET = 61;
let TOKEN_TRUE = 62;
let TOKEN_FALSE = 63;
let TOKEN_IF = 64;
let TOKEN_ELSE = 65;
let TOKEN_RETURN = 66;
let TOKEN_WHILE = 67;
let TOKEN_FOR = 68;
let TOKEN_IN = 69;
let TOKEN_STRUCT = 70;
let TOKEN_NATIVE = 80;
let TOKEN_IMPORT = 90;
let TOKEN_PACKAGE = 91;
let TOKEN_EXPORT = 92;
let TOKEN_AT = 95;
let TOKEN_ARROW = 99;
class Token {
    constructor(data = {}) {
        this.kind = data.kind;
        this.lexeme = data.lexeme;
        this.line = data.line;
        this.start = data.start;
        this.end = data.end;
    }
}
function new_token(kind, lexeme, line) {
    return new Token({ kind: kind, lexeme: lexeme, line: line, start: 0, end: 0 });
}

module.exports = { new_token };


function char_at(s, i) {
    
        if (i >= s.length) return "\0";
        return s.charAt(i);
    
}
function is_letter(ch) {
     return /[a-zA-Z_]/.test(ch); 
}
function is_digit(ch) {
     return /\d/.test(ch); 
}
function is_quote(ch) {
     return ch === String.fromCharCode(34); 
}
class Lexer {
    constructor(data = {}) {
        this.input = data.input;
        this.position = data.position;
        this.read_position = data.read_position;
        this.ch = data.ch;
        this.line = data.line;
    }
}
function new_lexer(input) {
    let l = new Lexer({ input: input, position: 0, read_position: 0, ch: "\0", line: 1 });
    Lexer_read_char(l);
    return l;
}
function Lexer_read_char(l) {
    if (l.read_position >= 999999) {
    l.ch = "\0";
} else {
    l.ch = char_at(l.input, l.read_position);
}
    let is_eof = false;
     is_eof = l.ch === "\0"; 
    if (is_eof) {
    l.ch = "\0";
} else {
    l.position = l.read_position;
    l.read_position = l.read_position + 1;
}
}
function Lexer_skip_whitespace(l) {
    let should_skip = false;
    
        // Skip whitespace AND non-ASCII characters (Unicode box-drawing, etc.)
        const code = l.ch.charCodeAt(0);
        should_skip = l.ch === ' ' || l.ch === '\t' || l.ch === '\n' || l.ch === '\r' || code > 127;
    
    while (should_skip) {
    if (l.ch == "\n") {
    l.line = l.line + 1;
}
    Lexer_read_char(l);
    
            const code = l.ch.charCodeAt(0);
            should_skip = l.ch === ' ' || l.ch === '\t' || l.ch === '\n' || l.ch === '\r' || code > 127;
        
}
}
function Lexer_read_identifier(l) {
    let start_pos = l.position;
    while (is_letter(l.ch) || is_digit(l.ch)) {
    Lexer_read_char(l);
}
    let ident = "";
    
        ident = l.input.substring(Number(start_pos), Number(l.position));
    
    return ident;
}
function Lexer_read_number(l) {
    let start_pos = l.position;
    while (is_digit(l.ch)) {
    Lexer_read_char(l);
}
    if (l.ch == ".") {
    let peek_next = char_at(l.input, l.read_position);
    if (is_digit(peek_next)) {
    Lexer_read_char(l);
    while (is_digit(l.ch)) {
    Lexer_read_char(l);
}
}
}
    let num_str = "";
    
        num_str = l.input.substring(Number(start_pos), Number(l.position));
    
    return num_str;
}
function Lexer_lookup_ident(ident) {
    if (ident == "fn") {
    return TOKEN_FN;
}
    if (ident == "let") {
    return TOKEN_LET;
}
    if (ident == "struct") {
    return TOKEN_STRUCT;
}
    if (ident == "if") {
    return TOKEN_IF;
}
    if (ident == "else") {
    return TOKEN_ELSE;
}
    if (ident == "return") {
    return TOKEN_RETURN;
}
    if (ident == "true") {
    return TOKEN_TRUE;
}
    if (ident == "false") {
    return TOKEN_FALSE;
}
    if (ident == "native") {
    return TOKEN_NATIVE;
}
    if (ident == "import") {
    return 90;
}
    if (ident == "package") {
    return 91;
}
    if (ident == "export") {
    return 92;
}
    if (ident == "capsule") {
    return 93;
}
    if (ident == "flow") {
    return 94;
}
    if (ident == "while") {
    return TOKEN_WHILE;
}
    if (ident == "for") {
    return 68;
}
    if (ident == "in") {
    return 69;
}
    return TOKEN_IDENTIFIER;
}
function Lexer_next_token(l) {
    Lexer_skip_whitespace(l);
    if (l.ch == "/") {
    let peek = char_at(l.input, l.read_position);
    if (peek == "/") {
    while (l.ch != "\n" && l.ch != "\0") {
    Lexer_read_char(l);
}
    Lexer_skip_whitespace(l);
}
}
    let tok = new_token(TOKEN_ILLEGAL, l.ch, l.line);
    tok.start = l.position;
    if (l.ch == "\0") {
    tok.kind = TOKEN_EOF;
    tok.lexeme = "";
    return tok;
}
    if (l.ch == ":") {
    tok.kind = 30;
    tok.lexeme = ":";
    Lexer_read_char(l);
    return tok;
}
    if (l.ch == "=") {
    let peek_eq = char_at(l.input, l.read_position);
    if (peek_eq == "=") {
    Lexer_read_char(l);
    tok.kind = TOKEN_EQ;
    tok.lexeme = "==";
} else {
    tok.kind = TOKEN_ASSIGN;
    tok.lexeme = "=";
}
} else {
    if (l.ch == "!") {
    let peek_bang = char_at(l.input, l.read_position);
    if (peek_bang == "=") {
    Lexer_read_char(l);
    tok.kind = TOKEN_NOT_EQ;
    tok.lexeme = "!=";
} else {
    tok.kind = TOKEN_BANG;
    tok.lexeme = "!";
}
} else {
    if (l.ch == ";") {
    tok.kind = TOKEN_SEMICOLON;
    tok.lexeme = ";";
} else {
    if (l.ch == "(") {
    tok.kind = TOKEN_LPAREN;
    tok.lexeme = "(";
} else {
    if (l.ch == ")") {
    tok.kind = TOKEN_RPAREN;
    tok.lexeme = ")";
} else {
    if (l.ch == "{") {
    tok.kind = TOKEN_LBRACE;
    tok.lexeme = "{";
} else {
    if (l.ch == "}") {
    tok.kind = TOKEN_RBRACE;
    tok.lexeme = "}";
} else {
    if (l.ch == ",") {
    tok.kind = TOKEN_COMMA;
    tok.lexeme = ",";
} else {
    if (l.ch == ".") {
    tok.kind = 31;
    tok.lexeme = ".";
} else {
    if (l.ch == "[") {
    tok.kind = TOKEN_LBRACKET;
    tok.lexeme = "[";
} else {
    if (l.ch == "]") {
    tok.kind = TOKEN_RBRACKET;
    tok.lexeme = "]";
} else {
    if (l.ch == "+") {
    tok.kind = TOKEN_PLUS;
    tok.lexeme = "+";
} else {
    if (l.ch == "-") {
    let peek_arrow = char_at(l.input, l.read_position);
    if (peek_arrow == ">") {
    Lexer_read_char(l);
    tok.kind = 99;
    tok.lexeme = "->";
} else {
    tok.kind = TOKEN_MINUS;
    tok.lexeme = "-";
}
} else {
    if (l.ch == "*") {
    tok.kind = TOKEN_ASTERISK;
    tok.lexeme = "*";
} else {
    if (l.ch == "/") {
    let peek_slash = char_at(l.input, l.read_position);
    if (peek_slash == "/") {
    Lexer_read_char(l);
    Lexer_read_char(l);
    while (l.ch != "\n" && l.ch != "\0") {
    Lexer_read_char(l);
}
    return Lexer_next_token(l);
} else {
    tok.kind = TOKEN_SLASH;
    tok.lexeme = "/";
}
} else {
    if (is_quote(l.ch)) {
    let str_val = "";
    Lexer_read_char(l);
    let start = l.position;
    while (is_quote(l.ch) == false && l.ch != "\0") {
    if (l.ch == "\\") {
    Lexer_read_char(l);
    Lexer_read_char(l);
} else {
    Lexer_read_char(l);
}
}
    let end = l.position;
    
            str_val = l.input.substring(Number(start), Number(end));
        
    tok.kind = TOKEN_STRING;
    tok.lexeme = str_val;
} else {
    if (l.ch == "&") {
    let peek_and = char_at(l.input, l.read_position);
    if (peek_and == "&") {
    Lexer_read_char(l);
    tok.kind = TOKEN_AND;
    tok.lexeme = "&&";
} else {
    tok.kind = TOKEN_ILLEGAL;
    tok.lexeme = "&";
}
} else {
    if (l.ch == "|") {
    let peek_or = char_at(l.input, l.read_position);
    if (peek_or == "|") {
    Lexer_read_char(l);
    tok.kind = TOKEN_OR;
    tok.lexeme = "||";
} else {
    tok.kind = TOKEN_ILLEGAL;
    tok.lexeme = "|";
}
} else {
    if (l.ch == "<") {
    let peek_lt = char_at(l.input, l.read_position);
    if (peek_lt == "=") {
    Lexer_read_char(l);
    tok.kind = TOKEN_LE;
    tok.lexeme = "<=";
} else {
    tok.kind = TOKEN_LT;
    tok.lexeme = "<";
}
} else {
    if (l.ch == "@") {
    tok.kind = 95;
    tok.lexeme = "@";
} else {
    if (l.ch == ">") {
    let peek_gt = char_at(l.input, l.read_position);
    if (peek_gt == "=") {
    Lexer_read_char(l);
    tok.kind = TOKEN_GE;
    tok.lexeme = ">=";
} else {
    tok.kind = TOKEN_GT;
    tok.lexeme = ">";
}
} else {
    if (is_letter(l.ch)) {
    let literal = Lexer_read_identifier(l);
    tok.kind = Lexer_lookup_ident(literal);
    tok.lexeme = literal;
    return tok;
} else {
    if (is_digit(l.ch)) {
    tok.kind = TOKEN_INT;
    tok.lexeme = Lexer_read_number(l);
    return tok;
} else {
    tok.kind = TOKEN_ILLEGAL;
    tok.lexeme = l.ch;
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
    Lexer_read_char(l);
    return tok;
}

module.exports = { char_at, is_letter, is_digit, is_quote, new_lexer, Lexer_read_char, Lexer_skip_whitespace, Lexer_read_identifier, Lexer_read_number, Lexer_lookup_ident, Lexer_next_token };


class Parser {
    constructor(data = {}) {
        this.lexer = data.lexer;
        this.cur_token = data.cur_token;
        this.peek_token = data.peek_token;
    }
}
function new_parser(l) {
    let p = new Parser({ lexer: l, cur_token: new_token(0, "", 0), peek_token: new_token(0, "", 0) });
    Parser_next_token(p);
    Parser_next_token(p);
    return p;
}
function Parser_next_token(p) {
    p.cur_token = p.peek_token;
    p.peek_token = Lexer_next_token(p.lexer);
}
function Parser_parse_program(p) {
    let stmts = [];
    while (p.cur_token.kind != TOKEN_EOF) {
    let stmt = Parser_parse_statement(p);
    if (stmt != 0) {
    if (stmt.kind != 0) {
     stmts.push(stmt); 
}
}
}
    return new Program({ statements: stmts });
}
function Parser_parse_statement(p) {
    if (p.cur_token.kind == 95) {
    let decorators = [];
    while (p.cur_token.kind == 95) {
     decorators.push(Parser_parse_decorator(p)); 
}
    let stmt = Parser_parse_statement(p);
     if (stmt) stmt.decorators = decorators; 
    return stmt;
}
    if (p.cur_token.kind == 92) {
    Parser_next_token(p);
    let stmt = Parser_parse_statement(p);
     if (stmt) stmt.is_exported = true; 
    return stmt;
}
    if (p.cur_token.kind == 91) {
    return Parser_parse_package(p);
}
    if (p.cur_token.kind == 90) {
    return Parser_parse_import(p);
}
    if (p.cur_token.kind == 45) {
    Parser_next_token(p);
    return 0;
}
    if (p.cur_token.kind == 64) {
    return Parser_parse_if(p);
}
    if (p.cur_token.kind == 67) {
    return Parser_parse_while(p);
}
    if (p.cur_token.kind == 68) {
    return Parser_parse_for(p);
}
    if (p.cur_token.kind == 61) {
    return Parser_parse_let(p);
}
    if (p.cur_token.kind == 60) {
    return Parser_parse_fn(p);
}
    if (p.cur_token.kind == 70) {
    return Parser_parse_struct(p);
}
    if (p.cur_token.kind == 66) {
    return Parser_parse_return(p);
}
    if (p.cur_token.kind == 93) {
    return Parser_parse_capsule(p);
}
    if (p.cur_token.kind == 94) {
    return Parser_parse_fn(p);
}
    if (p.cur_token.kind == 80) {
    return Parser_parse_native_block(p);
}
    return Parser_parse_expr_stmt(p);
}
function Parser_parse_import(p) {
    Parser_next_token(p);
    let path = p.cur_token.lexeme;
    Parser_next_token(p);
    if (p.cur_token.kind == TOKEN_SEMICOLON) {
    Parser_next_token(p);
}
    return new ImportDecl({ kind: NODE_IMPORT, path: path });
}
function Parser_parse_package(p) {
    Parser_next_token(p);
    while (p.cur_token.kind != TOKEN_SEMICOLON && p.cur_token.kind != TOKEN_EOF) {
    Parser_next_token(p);
}
    if (p.cur_token.kind == TOKEN_SEMICOLON) {
    Parser_next_token(p);
}
    return 0;
}
function Parser_parse_let(p) {
    Parser_next_token(p);
    let name = p.cur_token.lexeme;
    Parser_next_token(p);
    if (p.cur_token.kind == 30) {
    Parser_next_token(p);
    Parser_next_token(p);
    while (p.cur_token.kind == 46) {
    Parser_next_token(p);
    if (p.cur_token.kind == 47) {
    Parser_next_token(p);
}
}
}
    Parser_next_token(p);
    let val = Parser_parse_expression(p);
    if (p.cur_token.kind == TOKEN_SEMICOLON) {
    Parser_next_token(p);
}
    return new LetStmt({ kind: NODE_LET, name: name, value: val, is_exported: false });
}
function Parser_parse_return(p) {
    Parser_next_token(p);
    let val = Parser_parse_expression(p);
    if (p.cur_token.kind == TOKEN_SEMICOLON) {
    Parser_next_token(p);
}
    return new ReturnStmt({ kind: NODE_RETURN, value: val });
}
function Parser_parse_fn(p) {
    Parser_next_token(p);
    let name = p.cur_token.lexeme;
    Parser_next_token(p);
    Parser_next_token(p);
    let params = [];
    while (p.cur_token.kind != TOKEN_RPAREN) {
     params.push(p.cur_token.lexeme); 
    Parser_next_token(p);
    if (p.cur_token.kind == 30) {
    Parser_next_token(p);
    Parser_next_token(p);
}
    if (p.cur_token.kind == TOKEN_COMMA) {
    Parser_next_token(p);
}
}
    Parser_next_token(p);
    if (p.cur_token.kind == 99) {
    Parser_next_token(p);
    Parser_next_token(p);
}
    let body = Parser_parse_block(p);
    return new FunctionDecl({ kind: NODE_FUNCTION, name: name, params: params, body: body, is_exported: false, decorators: [] });
}
function Parser_parse_struct(p) {
    Parser_next_token(p);
    let name = p.cur_token.lexeme;
    Parser_next_token(p);
    Parser_next_token(p);
    let fields = [];
    while (p.cur_token.kind != TOKEN_RBRACE && p.cur_token.kind != TOKEN_EOF) {
    if (p.cur_token.kind == TOKEN_RBRACE) {
    break;
}
    let field_name = p.cur_token.lexeme;
    Parser_next_token(p);
    Parser_next_token(p);
    let field_type = p.cur_token.lexeme;
    Parser_next_token(p);
    let f = new_struct_field(field_name, field_type);
     fields.push(f); 
    if (p.cur_token.kind == TOKEN_COMMA) {
    Parser_next_token(p);
}
}
    Parser_next_token(p);
    return new StructDecl({ kind: NODE_STRUCT, name: name, fields: fields, is_exported: false, decorators: [] });
}
function Parser_parse_native_block(p) {
    Parser_next_token(p);
    let lang = "js";
    if (p.cur_token.kind == TOKEN_STRING) {
    lang = p.cur_token.lexeme;
    Parser_next_token(p);
}
    if (p.cur_token.kind != TOKEN_LBRACE) {
    return new NativeStmt({ kind: 0, lang: "", code: "" });
}
    let start_pos = p.cur_token.start;
    let code = "";
    let end_pos = 0;
    
        const input = p.lexer.input;
        let pos = Number(start_pos) + 1;
        let brace_count = 1;
        let start_extract = pos;
        
        while (pos < input.length && brace_count > 0) {
            const char = input[pos];
            if (char === '{') brace_count++;
            if (char === '}') brace_count--;
            pos++;
        }
        
        end_pos = pos;
        if (brace_count == 0) {
            code = input.substring(start_extract, pos - 1);
        }
        p.lexer.read_position = end_pos;
        Lexer_read_char(p.lexer);
        p.cur_token = Lexer_next_token(p.lexer);
        p.peek_token = Lexer_next_token(p.lexer);
    
    return new NativeStmt({ kind: NODE_NATIVE, lang: lang, code: code });
}
function Parser_parse_block(p) {
    let stmts = [];
    if (p.cur_token.kind == TOKEN_LBRACE) {
    Parser_next_token(p);
    while (p.cur_token.kind != TOKEN_RBRACE && p.cur_token.kind != TOKEN_EOF) {
    let stmt = Parser_parse_statement(p);
     stmts.push(stmt); 
}
    Parser_next_token(p);
} else {
    let stmt = Parser_parse_statement(p);
     stmts.push(stmt); 
}
    return new Block({ kind: NODE_BLOCK, statements: stmts });
}
function Parser_parse_expr_stmt(p) {
    let expr = Parser_parse_expression(p);
    if (p.cur_token.kind == TOKEN_SEMICOLON) {
    Parser_next_token(p);
}
    return new ExpressionStmt({ kind: NODE_EXPRESSION_STMT, expr: expr });
}
function Parser_parse_expression(p) {
    return Parser_parse_assignment(p);
}
function Parser_parse_assignment(p) {
    let left = Parser_parse_logic(p);
    if (p.cur_token.kind == TOKEN_ASSIGN) {
    Parser_next_token(p);
    let right = Parser_parse_assignment(p);
    return new AssignmentExpr({ kind: NODE_ASSIGNMENT, left: left, right: right });
}
    return left;
}
function Parser_parse_equality(p) {
    let left = Parser_parse_relational(p);
    while (true) {
    let k = p.cur_token.kind;
    if (k != TOKEN_EQ && k != TOKEN_NOT_EQ) {
    break;
}
    let op = p.cur_token.lexeme;
    Parser_next_token(p);
    let right = Parser_parse_relational(p);
    left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
}
    return left;
}
function Parser_parse_relational(p) {
    let left = Parser_parse_term(p);
    while (true) {
    let k = p.cur_token.kind;
    if (k != TOKEN_LT && k != TOKEN_GT && k != TOKEN_LE && k != TOKEN_GE) {
    break;
}
    let op = p.cur_token.lexeme;
    Parser_next_token(p);
    let right = Parser_parse_term(p);
    left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
}
    return left;
}
function Parser_parse_logic(p) {
    let left = Parser_parse_equality(p);
    while (true) {
    let k = p.cur_token.kind;
    if (k != TOKEN_AND && k != TOKEN_OR) {
    break;
}
    let op = p.cur_token.lexeme;
    Parser_next_token(p);
    let right = Parser_parse_equality(p);
    left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
}
    return left;
}
function Parser_parse_term(p) {
    let left = Parser_parse_multiplication(p);
    while (true) {
    let k = p.cur_token.kind;
    if (k != TOKEN_PLUS && k != TOKEN_MINUS) {
    break;
}
    let op = p.cur_token.lexeme;
    Parser_next_token(p);
    let right = Parser_parse_multiplication(p);
    left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
}
    return left;
}
function Parser_parse_multiplication(p) {
    let left = Parser_parse_factor(p);
    while (true) {
    let k = p.cur_token.kind;
    if (k != TOKEN_ASTERISK && k != TOKEN_SLASH) {
    break;
}
    let op = p.cur_token.lexeme;
    Parser_next_token(p);
    let right = Parser_parse_factor(p);
    left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
}
    return left;
}
function Parser_parse_factor(p) {
    let node = 0;
    if (p.cur_token.kind == TOKEN_MINUS) {
    Parser_next_token(p);
    let operand = Parser_parse_factor(p);
    node = new BinaryExpr({ kind: NODE_BINARY, left: new IntegerLiteral({ kind: NODE_LITERAL, value: 0 }), op: "-", right: operand });
    return node;
}
    if (p.cur_token.kind == TOKEN_BANG) {
    Parser_next_token(p);
    let operand = Parser_parse_factor(p);
    node = new UnaryExpr({ kind: NODE_UNARY, op: "!", operand: operand });
    return node;
}
    if (p.cur_token.kind == TOKEN_NATIVE) {
    return Parser_parse_native_block(p);
}
    if (p.cur_token.kind == TOKEN_INT) {
    let val = 0;
     val = Number(p.cur_token.lexeme); 
    node = new IntegerLiteral({ kind: NODE_LITERAL, value: val });
    Parser_next_token(p);
} else {
    if (p.cur_token.kind == TOKEN_IDENTIFIER) {
    let name = p.cur_token.lexeme;
    Parser_next_token(p);
    if (p.cur_token.kind == TOKEN_LBRACE) {
    Parser_next_token(p);
    let init_fields = [];
    while (p.cur_token.kind != TOKEN_RBRACE && p.cur_token.kind != TOKEN_EOF) {
    let field_name = p.cur_token.lexeme;
    Parser_next_token(p);
    Parser_next_token(p);
    let field_val = Parser_parse_expression(p);
    let field = new StructInitField({ name: field_name, value: field_val });
     init_fields.push(field); 
    if (p.cur_token.kind == TOKEN_COMMA) {
    Parser_next_token(p);
}
}
    Parser_next_token(p);
    node = new StructInitExpr({ kind: NODE_STRUCT_INIT, name: name, fields: init_fields });
} else {
    node = new Identifier({ kind: NODE_IDENTIFIER, value: name });
}
} else {
    if (p.cur_token.kind == TOKEN_LPAREN) {
    Parser_next_token(p);
    node = Parser_parse_expression(p);
    Parser_next_token(p);
} else {
    if (p.cur_token.kind == TOKEN_STRING) {
    let str_val = p.cur_token.lexeme;
    node = new StringLiteral({ kind: NODE_STRING, value: str_val });
    Parser_next_token(p);
} else {
    if (p.cur_token.kind == TOKEN_TRUE) {
    node = new BoolLiteral({ kind: NODE_BOOL, value: true });
    Parser_next_token(p);
} else {
    if (p.cur_token.kind == TOKEN_FALSE) {
    node = new BoolLiteral({ kind: NODE_BOOL, value: false });
    Parser_next_token(p);
} else {
    if (p.cur_token.kind == TOKEN_LBRACKET) {
    Parser_next_token(p);
    let elements = [];
    while (p.cur_token.kind != TOKEN_RBRACKET && p.cur_token.kind != TOKEN_EOF) {
     elements.push(Parser_parse_expression(p)); 
    if (p.cur_token.kind == TOKEN_COMMA) {
    Parser_next_token(p);
}
}
    Parser_next_token(p);
     node = { kind: NODE_ARRAY, elements: elements }; 
} else {
     console.error("Unexpected token in expression: Kind " + p.cur_token.kind + ", Lexeme: " + p.cur_token.lexeme); 
    Parser_next_token(p);
    return 0;
}
}
}
}
}
}
}
    let continue_loop = true;
    while (continue_loop) {
    if (p.cur_token.kind == 31) {
    Parser_next_token(p);
    let prop = p.cur_token.lexeme;
    Parser_next_token(p);
    node = new MemberExpr({ kind: NODE_MEMBER, target: node, property: prop });
} else {
    if (p.cur_token.kind == TOKEN_LPAREN) {
    Parser_next_token(p);
    let args = [];
    while (p.cur_token.kind != TOKEN_RPAREN && p.cur_token.kind != TOKEN_EOF) {
     args.push(Parser_parse_expression(p)); 
    if (p.cur_token.kind == TOKEN_COMMA) {
    Parser_next_token(p);
}
}
    Parser_next_token(p);
    node = new CallExpr({ kind: NODE_CALL, function: node, args: args });
} else {
    continue_loop = false;
}
}
}
    return node;
}
function Parser_parse_if(p) {
    Parser_next_token(p);
    let cond = Parser_parse_expression(p);
    let cons = Parser_parse_block(p);
    let alt = 0;
    if (p.cur_token.kind == TOKEN_ELSE) {
    Parser_next_token(p);
    if (p.cur_token.kind == TOKEN_IF) {
    let if_stmt = Parser_parse_if(p);
    let stmts = [];
     stmts.push(if_stmt); 
    alt = new Block({ kind: NODE_BLOCK, statements: stmts });
} else {
    alt = Parser_parse_block(p);
}
}
    return new IfStmt({ kind: NODE_IF, condition: cond, consequence: cons, alternative: alt });
}
function Parser_parse_while(p) {
    Parser_next_token(p);
    let cond = Parser_parse_expression(p);
    let body = Parser_parse_block(p);
    return new WhileStmt({ kind: NODE_WHILE, condition: cond, body: body });
}
function Parser_parse_decorator(p) {
    Parser_next_token(p);
    let name = p.cur_token.lexeme;
    Parser_next_token(p);
    let args = [];
    if (p.cur_token.kind == TOKEN_LPAREN) {
    Parser_next_token(p);
    while (p.cur_token.kind != TOKEN_RPAREN && p.cur_token.kind != TOKEN_EOF) {
    let arg_name = "";
    let arg_val = 0;
    let is_named = false;
    if (p.cur_token.kind == TOKEN_IDENTIFIER) {
    if (p.peek_token.kind == TOKEN_ASSIGN) {
    is_named = true;
}
}
    if (is_named) {
    arg_name = p.cur_token.lexeme;
    Parser_next_token(p);
    Parser_next_token(p);
    arg_val = Parser_parse_expression(p);
} else {
    arg_val = Parser_parse_expression(p);
}
    let field = new StructInitField({ name: arg_name, value: arg_val });
     args.push(field); 
    if (p.cur_token.kind == TOKEN_COMMA) {
    Parser_next_token(p);
}
}
    Parser_next_token(p);
}
    return new Decorator({ name: name, args: args });
}
function Parser_parse_for(p) {
    Parser_next_token(p);
    let iter = p.cur_token.lexeme;
    Parser_next_token(p);
    if (p.cur_token.kind == 69) {
    Parser_next_token(p);
}
    let collection = Parser_parse_expression(p);
    let body = Parser_parse_block(p);
    return new ForStmt({ kind: NODE_FOR, iterator: iter, collection: collection, body: body });
}
function Parser_parse_capsule(p) {
    Parser_next_token(p);
    let name = p.cur_token.lexeme;
    Parser_next_token(p);
    let body = Parser_parse_block(p);
    return new CapsuleDecl({ kind: 90, name: name, body: body });
}

module.exports = { new_parser, Parser_next_token, Parser_parse_program, Parser_parse_statement, Parser_parse_import, Parser_parse_package, Parser_parse_let, Parser_parse_return, Parser_parse_fn, Parser_parse_struct, Parser_parse_native_block, Parser_parse_block, Parser_parse_expr_stmt, Parser_parse_expression, Parser_parse_assignment, Parser_parse_equality, Parser_parse_relational, Parser_parse_logic, Parser_parse_term, Parser_parse_multiplication, Parser_parse_factor, Parser_parse_if, Parser_parse_while, Parser_parse_decorator, Parser_parse_for, Parser_parse_capsule };


let NODE_PROGRAM = 1;
let NODE_LET = 2;
let NODE_LITERAL = 3;
let NODE_FUNCTION = 4;
let NODE_BLOCK = 5;
let NODE_CALL = 6;
let NODE_RETURN = 7;
let NODE_BINARY = 8;
let NODE_MEMBER = 9;
let NODE_IMPORT = 10;
let NODE_ARRAY = 11;
let NODE_STRUCT_INIT = 12;
let NODE_IF = 13;
let NODE_WHILE = 14;
let NODE_IDENTIFIER = 15;
let NODE_ASSIGNMENT = 16;
let NODE_STRING = 17;
let NODE_BOOL = 18;
let NODE_FOR = 19;
let NODE_EXPRESSION_STMT = 20;
let NODE_UNARY = 21;
let NODE_STRUCT = 70;
let NODE_NATIVE = 80;
let NODE_CAPSULE = 90;
let NODE_SPAWN = 100;
let NODE_INTERFACE = 110;
class Program {
    constructor(data = {}) {
        this.statements = data.statements;
    }
}
class AssignmentExpr {
    constructor(data = {}) {
        this.kind = data.kind;
        this.left = data.left;
        this.right = data.right;
    }
}
class UnaryExpr {
    constructor(data = {}) {
        this.kind = data.kind;
        this.op = data.op;
        this.operand = data.operand;
    }
}
class NativeStmt {
    constructor(data = {}) {
        this.kind = data.kind;
        this.lang = data.lang;
        this.code = data.code;
    }
}
class LetStmt {
    constructor(data = {}) {
        this.kind = data.kind;
        this.name = data.name;
        this.value = data.value;
        this.is_exported = data.is_exported;
    }
}
class ImportDecl {
    constructor(data = {}) {
        this.kind = data.kind;
        this.path = data.path;
    }
}
class ExpressionStmt {
    constructor(data = {}) {
        this.kind = data.kind;
        this.expr = data.expr;
    }
}
class IntegerLiteral {
    constructor(data = {}) {
        this.kind = data.kind;
        this.value = data.value;
    }
}
class StringLiteral {
    constructor(data = {}) {
        this.kind = data.kind;
        this.value = data.value;
    }
}
class BoolLiteral {
    constructor(data = {}) {
        this.kind = data.kind;
        this.value = data.value;
    }
}
class StructInitExpr {
    constructor(data = {}) {
        this.kind = data.kind;
        this.name = data.name;
        this.fields = data.fields;
    }
}
class StructInitField {
    constructor(data = {}) {
        this.name = data.name;
        this.value = data.value;
    }
}
class BinaryExpr {
    constructor(data = {}) {
        this.kind = data.kind;
        this.left = data.left;
        this.op = data.op;
        this.right = data.right;
    }
}
class MemberExpr {
    constructor(data = {}) {
        this.kind = data.kind;
        this.target = data.target;
        this.property = data.property;
    }
}
class FunctionDecl {
    constructor(data = {}) {
        this.kind = data.kind;
        this.name = data.name;
        this.params = data.params;
        this.body = data.body;
        this.is_exported = data.is_exported;
        this.decorators = data.decorators;
    }
}
class Block {
    constructor(data = {}) {
        this.kind = data.kind;
        this.statements = data.statements;
    }
}
class CallExpr {
    constructor(data = {}) {
        this.kind = data.kind;
        this.function = data.function;
        this.args = data.args;
    }
}
class ReturnStmt {
    constructor(data = {}) {
        this.kind = data.kind;
        this.value = data.value;
    }
}
class IfStmt {
    constructor(data = {}) {
        this.kind = data.kind;
        this.condition = data.condition;
        this.consequence = data.consequence;
        this.alternative = data.alternative;
    }
}
class WhileStmt {
    constructor(data = {}) {
        this.kind = data.kind;
        this.condition = data.condition;
        this.body = data.body;
    }
}
class ForStmt {
    constructor(data = {}) {
        this.kind = data.kind;
        this.iterator = data.iterator;
        this.collection = data.collection;
        this.body = data.body;
    }
}
class StructDecl {
    constructor(data = {}) {
        this.kind = data.kind;
        this.name = data.name;
        this.fields = data.fields;
        this.is_exported = data.is_exported;
        this.decorators = data.decorators;
    }
}
class CapsuleDecl {
    constructor(data = {}) {
        this.kind = data.kind;
        this.name = data.name;
        this.body = data.body;
    }
}
class StructField {
    constructor(data = {}) {
        this.name = data.name;
        this.typename = data.typename;
    }
}
class Decorator {
    constructor(data = {}) {
        this.name = data.name;
        this.args = data.args;
    }
}
function new_struct_field(name, typename) {
    return new StructField({ name: name, typename: typename });
}
class Identifier {
    constructor(data = {}) {
        this.kind = data.kind;
        this.value = data.value;
    }
}

module.exports = { new_struct_field };


function CodeGenerator_generate(self, program) {
    let hybrid = new_code_generator(self.target);
    let h = HybridCodeGenerator_new(self.target);
    return HybridCodeGenerator_generate(h, program);
}

module.exports = { CodeGenerator_generate };


class LanguageProfile {
    constructor(data = {}) {
        this.name = data.name;
        this.extension = data.extension;
        this.templates = data.templates;
        this.type_map = data.type_map;
        this.operators = data.operators;
        this.indent_str = data.indent_str;
        this.statement_end = data.statement_end;
        this.loaded = data.loaded;
    }
}
function new_map() {
     return {}; 
    return 0;
}
function LanguageProfile_new(name) {
    return new LanguageProfile({ name: name, extension: ".txt", templates: new_map(), type_map: new_map(), operators: new_map(), indent_str: "    ", statement_end: ";", loaded: false });
}
function LanguageProfile_load(self) {
    
const impl = codegen_hybrid_impl;
        return impl.LanguageProfile_load_impl(self);
    
    return self;
}
function LanguageProfile_render(self, template_name, data) {
    let result = "";
    
const impl = codegen_hybrid_impl;
        result = impl.LanguageProfile_render_impl(self, template_name, data);
    
    return result;
}
function LanguageProfile_map_type(self, omni_type) {
    let result = omni_type;
    
        result = self.type_map[omni_type] || omni_type;
    
    return result;
}
function LanguageProfile_map_operator(self, op) {
    let result = op;
    
const impl = codegen_hybrid_impl;
        result = impl.LanguageProfile_map_operator_impl(self, op);
    
    return result;
}
class HybridCodeGenerator {
    constructor(data = {}) {
        this.profile = data.profile;
        this.indent_level = data.indent_level;
        this.exports = data.exports;
        this.ast_node_count = data.ast_node_count;
        this.generated_count = data.generated_count;
    }
}
function HybridCodeGenerator_new(target) {
    let profile = LanguageProfile_new(target);
    profile = LanguageProfile_load(profile);
    return new HybridCodeGenerator({ profile: profile, indent_level: 0, exports: [], ast_node_count: 0, generated_count: 0 });
}
function HybridCodeGenerator_indent(self, code) {
    let result = "";
    
const impl = codegen_hybrid_impl;
        result = impl.HybridCodeGenerator_indent_impl(self, code);
    
    return result;
}
function HybridCodeGenerator_generate(self, program) {
    let output = "";
    output = LanguageProfile_render(self.profile, "program_header", null, null);
    
        self.exports = [];
        self.ast_node_count = 0;
        self.generated_count = 0;
        
        if (program && program.statements) {
            for (const stmt of program.statements) {
                self.ast_node_count++;
                const code = HybridCodeGenerator_gen_statement(self, stmt);
                if (code) {
                    output += code + "\n";
                    self.generated_count++;
                }
            }
        }
        
        // Auto-exports
        if (self.exports.length > 0) {
            if (self.profile.name === "python") {
                output += "\n__all__ = [" + self.exports.map(e => '"' + e + '"').join(', ') + "]\n";
            } else {
                output += "\nmodule.exports = { " + self.exports.join(", ") + " };\n";
            }
        }

        // Auto-main execution
        var nl = String.fromCharCode(10);
        if (self.profile.name === "python") {
                output += nl + "if __name__ == '__main__':" + nl + "    if 'main' in globals():" + nl + "        main()" + nl;
        } else {
                output += nl + "if (typeof main === 'function') { main(); }" + nl;
        }
        
        // AST Parity Validation
        const coverage = self.ast_node_count > 0 ? 
            (self.generated_count / self.ast_node_count * 100).toFixed(1) : 100;
        if (coverage < 100) {
            console.warn("[codegen] AST coverage: " + coverage + "% (" + 
                self.generated_count + "/" + self.ast_node_count + " nodes)");
        }
    
    return output;
}
function HybridCodeGenerator_gen_statement(self, stmt) {
    if (stmt.kind == NODE_IMPORT) {
    return HybridCodeGenerator_gen_import(self, stmt);
}
    if (stmt.kind == NODE_NATIVE) {
    let result = "";
    
const impl = codegen_hybrid_impl;
            result = impl.check_native_lang(self, stmt);
        
    return result;
}
    if (stmt.kind == NODE_LET) {
    let value = HybridCodeGenerator_gen_expression(self, stmt.value);
    let result = "";
    
const impl = codegen_hybrid_impl;
            result = impl.LanguageProfile_render_impl(self.profile, "let_decl", {
                name: stmt.name,
                value: value
            });
        
    return result;
}
    if (stmt.kind == NODE_RETURN) {
    let value = HybridCodeGenerator_gen_expression(self, stmt.value);
    let result = "";
    
const impl = codegen_hybrid_impl;
            result = impl.LanguageProfile_render_impl(self.profile, "return_stmt", {
                value: value
            });
        
    return result;
}
    if (stmt.kind == NODE_FUNCTION) {
    let params = "";
     params = stmt.params ? stmt.params.join(", ") : ""; 
    let saved_indent = self.indent_level;
    self.indent_level = 1;
    let body = HybridCodeGenerator_gen_block(self, stmt.body);
    self.indent_level = saved_indent;
    
            self.exports.push(stmt.name);
        
    let result = "";
    
const impl = codegen_hybrid_impl;
            result = impl.LanguageProfile_render_impl(self.profile, "fn_decl", {
                name: stmt.name,
                params: params,
                body: body
            });
        
    return result;
}
    if (stmt.kind == NODE_STRUCT) {
    return HybridCodeGenerator_gen_struct(self, stmt);
}
    if (stmt.kind == NODE_IF) {
    return HybridCodeGenerator_gen_if(self, stmt);
}
    if (stmt.kind == NODE_WHILE) {
    let cond = HybridCodeGenerator_gen_expression(self, stmt.condition);
    let saved_indent = self.indent_level;
    self.indent_level = 1;
    let body = HybridCodeGenerator_gen_block(self, stmt.body);
    self.indent_level = saved_indent;
    let result = "";
    
const impl = codegen_hybrid_impl;
            result = impl.LanguageProfile_render_impl(self.profile, "while_stmt", {
                condition: cond,
                body: body
            });
        
    return result;
}
    if (stmt.kind == 19) {
    let iter = stmt.iterator;
    let col = HybridCodeGenerator_gen_expression(self, stmt.collection);
    let saved_indent = self.indent_level;
    self.indent_level = 1;
    let body = HybridCodeGenerator_gen_block(self, stmt.body);
    self.indent_level = saved_indent;
    let code = "";
    
             if (self.profile.name === "python") {
                 code = "for " + iter + " in " + col + ":\n" + body;
             } else {
                 code = "for (const " + iter + " of " + col + ") {\n" + body + "}";
             }
         
    return code;
}
    if (stmt.kind == NODE_CAPSULE) {
    return HybridCodeGenerator_gen_capsule(self, stmt);
}
    if (stmt.kind == NODE_SPAWN) {
    return HybridCodeGenerator_gen_spawn(self, stmt);
}
    if (stmt.kind == NODE_INTERFACE) {
    return HybridCodeGenerator_gen_interface(self, stmt);
}
    if (stmt.kind == NODE_ASSIGNMENT) {
    let left = HybridCodeGenerator_gen_expression(self, stmt.left);
    let right = HybridCodeGenerator_gen_expression(self, stmt.right);
    return left + " = " + right + self.profile.statement_end;
}
    if (stmt.kind == NODE_CALL) {
    let callee = "";
    let function_node = 0;
     function_node = stmt.function || stmt.callee || stmt.name; 
    if (function_node) {
    let is_node = false;
     is_node = typeof function_node === "object"; 
    if (is_node) {
    callee = HybridCodeGenerator_gen_expression(self, function_node);
} else {
     callee = String(function_node); 
}
}
    let args = "";
    
            if (stmt.args && stmt.args.length > 0) {
                args = stmt.args.map(a => HybridCodeGenerator_gen_expression(self, a)).join(', ');
            }
        
    let result = "";
    
const impl = codegen_hybrid_impl;
            result = impl.LanguageProfile_render_impl(self.profile, "call_expr", {
                callee: callee,
                args: args
            });
        
    return result + self.profile.statement_end;
}
    if (stmt.kind == 20) {
    
            if (self.profile.name === 'python') self.profile.statement_end = '';
        
    let expr = HybridCodeGenerator_gen_expression(self, stmt.expr);
    if (expr == "") {
    return "";
}
    return expr + self.profile.statement_end;
}
    let result = "";
     result = "// Unknown stmt kind: " + stmt.kind; 
    return result;
}
function HybridCodeGenerator_gen_expression(self, expr) {
    let is_null = false;
     is_null = !expr; 
    if (is_null) {
    return "";
}
    if (expr.kind == NODE_NATIVE) {
    let result = "";
    
const impl = codegen_hybrid_impl;
            // Check if lang matches
            let code = impl.check_native_lang(self, expr);
            if (code) {
                // Wrap in IIFE for expression context
                result = "(() => { " + code + " })()";
            } else {
                result = "null"; // Fallback for wrong target
            }
        
    return result;
}
    if (expr.kind == NODE_LITERAL) {
    let val = "";
     
            val = String(expr.value);
            // Map booleans
            if (val === "true") val = self.profile.templates.bool_true || "true";
            if (val === "false") val = self.profile.templates.bool_false || "false";
            if (val === "null") val = self.profile.templates.null || "null";
        
    return val;
}
    if (expr.kind == NODE_UNARY) {
    let op = expr.op;
    let operand = HybridCodeGenerator_gen_expression(self, expr.operand);
    if (op == "!") {
     
                 if (self.profile.operators && self.profile.operators.not) op = self.profile.operators.not;
                 else op = "!";
             
}
    return op + operand;
}
    if (expr.kind == NODE_ASSIGNMENT) {
    let left = HybridCodeGenerator_gen_expression(self, expr.left);
    let right = HybridCodeGenerator_gen_expression(self, expr.right);
    return left + " = " + right;
}
    if (expr.kind == NODE_STRING) {
    let result = "";
     result = JSON.stringify(expr.value); 
    return result;
}
    if (expr.kind == NODE_BOOL) {
    let result = "";
    
const impl = codegen_hybrid_impl;
            result = impl.gen_expression_bool(self, expr);
        
    return result;
}
    if (expr.kind == NODE_IDENTIFIER) {
    let result = "";
     result = expr.value || expr.name || ''; 
    if (result == "print") {
    let is_js = false;
     is_js = self.profile.name !== "python"; 
    if (is_js) {
    return "console.log";
}
}
    return result;
}
    if (expr.kind == NODE_BINARY) {
    let left = HybridCodeGenerator_gen_expression(self, expr.left);
    let right = HybridCodeGenerator_gen_expression(self, expr.right);
    let op = LanguageProfile_map_operator(self.profile, expr.op);
    let result = "";
    
const impl = codegen_hybrid_impl;
            result = impl.LanguageProfile_render_impl(self.profile, "binary_expr", {
                left: left,
                op: op,
                right: right
            });
        
    return result;
}
    if (expr.kind == NODE_CALL) {
    let callee = "";
    let function_node = 0;
    
             function_node = expr.function || expr.callee;
        
    if (function_node) {
    callee = HybridCodeGenerator_gen_expression(self, function_node);
}
    let args = "";
    
            if (expr.args) {
                args = expr.args.map(a => HybridCodeGenerator_gen_expression(self, a)).join(', ');
            }
        
    let result = "";
    
const impl = codegen_hybrid_impl;
            result = impl.LanguageProfile_render_impl(self.profile, "call_expr", {
                callee: callee,
                args: args
            });
        
    return result;
}
    if (expr.kind == NODE_MEMBER) {
    let obj = HybridCodeGenerator_gen_expression(self, expr.target);
    return obj + "." + expr.property;
}
    if (expr.kind == NODE_ARRAY) {
    let elements = "";
    
            if (expr.elements) {
                elements = expr.elements.map(e => HybridCodeGenerator_gen_expression(self, e)).join(', ');
            }
        
    return "[" + elements + "]";
}
    if (expr.kind == NODE_STRUCT_INIT) {
    let fields = "";
    let is_python = false;
     is_python = self.profile.name === "python"; 
    
            if (expr.fields && Array.isArray(expr.fields)) {
                if (is_python) {
                    fields = expr.fields.map(f => "'" + f.name + "': " + HybridCodeGenerator_gen_expression(self, f.value)).join(', ');
                } else {
                    fields = expr.fields.map(f => f.name + ": " + HybridCodeGenerator_gen_expression(self, f.value)).join(', ');
                }
            }
        
    if (is_python) {
    return expr.name + "({ " + fields + " })";
} else {
    return "new " + expr.name + "({ " + fields + " })";
}
}
    let result = "";
     result = String(expr.value || expr.name || ''); 
    return result;
}
function HybridCodeGenerator_gen_block(self, body) {
    let result = "";
    
        if (!body) return '';
        const statements = Array.isArray(body) ? body : (body.statements || []);
        if (!Array.isArray(statements)) return '';
        result = statements.map(s => {
            const code = HybridCodeGenerator_gen_statement(self, s);
            return HybridCodeGenerator_indent(self, code);
        }).join('\n');
        
        // Python requires 'pass' for empty blocks
        if (self.profile.name === 'python' && (!result || result.trim() === '')) {
            result = HybridCodeGenerator_indent(self, 'pass');
        }
    
    return result;
    return result;
}
function HybridCodeGenerator_gen_if(self, stmt) {
    let cond = HybridCodeGenerator_gen_expression(self, stmt.condition);
    let saved_indent = self.indent_level;
    self.indent_level = 1;
    let consequence = HybridCodeGenerator_gen_block(self, stmt.consequence);
    self.indent_level = saved_indent;
    let has_alt = false;
     
        // Check for both array and Block object formats
        has_alt = stmt.alternative && (
            (Array.isArray(stmt.alternative) && stmt.alternative.length > 0) ||
            (stmt.alternative.statements && stmt.alternative.statements.length > 0) ||
            (stmt.alternative.kind) // Any AST node (e.g., Block, IfStmt)
        ); 
    
    if (has_alt) {
    let saved_alt_indent = self.indent_level;
    self.indent_level = 1;
    let alternative = HybridCodeGenerator_gen_block(self, stmt.alternative);
    self.indent_level = saved_alt_indent;
    let result = "";
    
const impl = codegen_hybrid_impl;
            result = impl.LanguageProfile_render_impl(self.profile, "if_else_stmt", {
                condition: cond,
                consequence: consequence,
                alternative: alternative
            });
        
    return result;
}
    let result = "";
    
const impl = codegen_hybrid_impl;
        result = impl.LanguageProfile_render_impl(self.profile, "if_stmt", {
            condition: cond,
            consequence: consequence
        });
    
    return result;
}
function HybridCodeGenerator_gen_struct(self, stmt) {
    let is_entity = false;
    
        is_entity = stmt.attributes && stmt.attributes.some(a => a.name === 'entity');
    
    let constructor_body = "";
     {
const impl = codegen_hybrid_impl;
        constructor_body = impl.gen_struct_body(stmt);
    } 
    let class_body = "";
    
        if (self.profile.name === "python") {
            class_body = "    def __init__(self, data={}):\n" + constructor_body;
        } else {
            class_body = "    constructor(data = {}) {\n" + constructor_body + "    }\n";
        }
    
    let out = "";
     {
const impl = codegen_hybrid_impl;
        out = impl.LanguageProfile_render_impl(self.profile, "class_decl", {
            name: stmt.name,
            body: class_body
        });
    } 
    if (is_entity) {
    out = out + HybridCodeGenerator_gen_entity_repo(self, stmt);
}
    return out;
}
function HybridCodeGenerator_gen_entity_repo(self, stmt) {
    let result = "";
    
const impl = codegen_hybrid_impl;
        result = impl.gen_entity_repo(stmt);
    
    return result;
}
function HybridCodeGenerator_gen_capsule(self, stmt) {
    let name = stmt.name;
    let result = "";
    
        const is_python = self.profile.name === "python";
        
        if (is_python) {
            result = "class " + name + ":\n";
            if (!stmt.body || !stmt.body.statements || stmt.body.statements.length === 0) {
                result += "    pass\n";
            } else {
                for (const s of stmt.body.statements) {
                    // Let/Var -> Class Attribute
                    if (s.kind == 2 || s.kind == 61) {
                         let val = HybridCodeGenerator_gen_expression(self, s.value);
                         result += "    " + s.name + " = " + val + "\n";
                    }
                    // Function -> Static Method
                    if (s.kind == 4 || s.kind == 94) {
                        let params = s.params ? s.params.join(", ") : "";
                        
                        let saved_indent = self.indent_level;
                        self.indent_level = 2; // Methods inside Class need 2 levels (8 spaces)
                        let body = HybridCodeGenerator_gen_block(self, s.body);
                        self.indent_level = saved_indent;
                        
                        let method = "    @staticmethod\n    def " + s.name + "(" + params + "):\n" + body + "\n";
                        result += method;
                    }
                }
            }
        } else {
            // JavaScript Object
            let props = "";
            if (stmt.body && stmt.body.statements) {
                for (const s of stmt.body.statements) {
                    if (s.kind == 2 || s.kind == 61) { 
                        let val = HybridCodeGenerator_gen_expression(self, s.value);
                        props += "    " + s.name + ": " + val + ",\n";
                    }
                    if (s.kind == 4 || s.kind == 94) { 
                        let params = s.params ? s.params.join(", ") : "";
                        self.indent_level++;
                        let body = HybridCodeGenerator_gen_block(self, s.body);
                        self.indent_level--;
                        props += "    " + s.name + "(" + params + ") {\n" + body + "    },\n";
                    }
                }
            }
            result = "// Capsule: " + name + "\nconst " + name + " = {\n" + props + "\n};\n";
        }
    
    return result;
}
function HybridCodeGenerator_gen_spawn(self, stmt) {
    let fn_name = "";
    let args = "";
    
        const call = stmt.call;
        fn_name = call?.name || call?.callee?.value || 'unknown';
        if (call?.args) {
            args = call.args.map(a => HybridCodeGenerator_gen_expression(self, a)).join(', ');
        }
    
    let out = "";
    
const impl = codegen_hybrid_impl;
        out = impl.gen_spawn_code(fn_name, args);
    
    return out;
}
function HybridCodeGenerator_gen_import(self, stmt) {
    let result = "";
    
const impl = codegen_hybrid_impl;
        result = impl.gen_import(stmt);
    
    return result;
}
function HybridCodeGenerator_gen_interface(self, stmt) {
    let is_service = false;
    
        is_service = stmt.attributes && stmt.attributes.some(a => a.name === 'service');
    
    if (is_service) {
    return HybridCodeGenerator_gen_service_client(self, stmt);
}
    return "// Interface: " + stmt.name;
}
function HybridCodeGenerator_gen_service_client(self, stmt) {
    let result = "";
    
const impl = codegen_hybrid_impl;
        result = impl.gen_service_client(stmt);
    
    return result;
}
function new_code_generator(target) {
    return HybridCodeGenerator_new(target);
}
function CodeGenerator_generate(self, program) {
    return HybridCodeGenerator_generate(self, program);
}

module.exports = { new_map, LanguageProfile_new, LanguageProfile_load, LanguageProfile_render, LanguageProfile_map_type, LanguageProfile_map_operator, HybridCodeGenerator_new, HybridCodeGenerator_indent, HybridCodeGenerator_generate, HybridCodeGenerator_gen_statement, HybridCodeGenerator_gen_expression, HybridCodeGenerator_gen_block, HybridCodeGenerator_gen_if, HybridCodeGenerator_gen_struct, HybridCodeGenerator_gen_entity_repo, HybridCodeGenerator_gen_capsule, HybridCodeGenerator_gen_spawn, HybridCodeGenerator_gen_import, HybridCodeGenerator_gen_interface, HybridCodeGenerator_gen_service_client, new_code_generator, CodeGenerator_generate };


class VMEnvironment {
    constructor(data = {}) {
        this.variables = data.variables;
        this.functions = data.functions;
        this.parent = data.parent;
        this.call_stack = data.call_stack;
    }
}
function new_map() {
     return {}; 
    return 0;
}
function VMEnvironment_new(parent) {
    let env = 0;
    
        env = {
            _omni_struct: true,
            name: "VMEnvironment",
            variables: {},
            functions: {},
            parent: parent,
            call_stack: []
        };
        
        // Register builtin functions
        env.functions['print'] = (...args) => { console.log(...args); return null; };
        env.functions['read_file'] = (path) => {
            return fs.existsSync(path) ? fs.readFileSync(path, 'utf-8') : '';
        };
        env.functions['write_file'] = (path, content) => {
            fs.writeFileSync(path, content);
            return null;
        };
        env.functions['len'] = (arr) => Array.isArray(arr) ? arr.length : 0;
        env.functions['push'] = (arr, val) => { arr.push(val); return arr; };
        env.functions['pop'] = (arr) => arr.pop();
        env.functions['keys'] = (obj) => Object.keys(obj);
        env.functions['values'] = (obj) => Object.values(obj);
        env.functions['typeof'] = (val) => typeof val;
        env.functions['parseInt'] = (s) => parseInt(s, 10);
        env.functions['parseFloat'] = (s) => parseFloat(s);
        env.functions['toString'] = (val) => String(val);
        env.functions['JSON_parse'] = (s) => JSON.parse(s);
        env.functions['JSON_stringify'] = (obj) => JSON.stringify(obj);
    
    return env;
}
function VMEnvironment_get(self, name) {
    let result = 0;
    
        if (self.variables.hasOwnProperty(name)) {
            result = self.variables[name];
        } else if (self.parent) {
            result = VMEnvironment_get(self.parent, name);
        } else {
            result = undefined;
        }
    
    return result;
}
function VMEnvironment_set(self, name, value) {
    
        self.variables[name] = value;
    
}
function VMEnvironment_get_function(self, name) {
    let result = 0;
    
        if (self.functions.hasOwnProperty(name)) {
            result = self.functions[name];
        } else if (self.parent) {
            result = VMEnvironment_get_function(self.parent, name);
        } else {
            result = null;
        }
    
    return result;
}
function VMEnvironment_set_function(self, name, func) {
    
        self.functions[name] = func;
    
}
class OmniVM {
    constructor(data = {}) {
        this.env = data.env;
        this.trace = data.trace;
        this.step_count = data.step_count;
    }
}
function OmniVM_new() {
    let env = VMEnvironment_new(0);
    return new OmniVM({ env: env, trace: true, step_count: 0 });
}
function OmniVM_run(self, program) {
    let result = 0;
    
        if (!program || !program.statements) {
            console.error("[vm] Invalid program");
            return null;
        }
        
        if (self.trace) console.log("[vm] Starting execution...");
        const startTime = Date.now();
        
        try {
            // Execute all statements
            for (const stmt of program.statements) {
                self.step_count++;
                result = OmniVM_exec_statement(self, stmt);
            }
            
            // Call main() if exists
            const mainFn = VMEnvironment_get_function(self.env, 'main');
            if (mainFn && typeof mainFn === 'object' && mainFn._omni_fn) {
                result = OmniVM_call_function(self, mainFn, []);
            }
            
            const elapsed = Date.now() - startTime;
            if (self.trace) {
                console.log("[vm] Execution completed in " + elapsed + "ms");
                console.log("[vm] Steps executed: " + self.step_count);
            }
            
        } catch (e) {
            console.error("[vm] Runtime error:", e.message);
            if (self.trace) {
                console.error(e.stack);
            }
        }
    
    return result;
}
function OmniVM_exec_statement(self, stmt) {
    let result = 0;
    
        if (self.trace) {
            console.log("[vm:trace] Executing stmt kind:", stmt.kind);
        }
        
        // Function declaration
        if (stmt.kind === 4) { // NODE_FUNCTION
            const fn = {
                _omni_fn: true,
                name: stmt.name,
                params: stmt.params || [],
                body: stmt.body
            };
            VMEnvironment_set_function(self.env, stmt.name, fn);
            return null;
        }
        
        // Struct declaration
        if (stmt.kind === 70) { // NODE_STRUCT
            const structDef = {
                _omni_struct: true,
                name: stmt.name,
                fields: stmt.fields || []
            };
            VMEnvironment_set(self.env, stmt.name, structDef);
            return null;
        }
        
        // Let declaration
        if (stmt.kind === 2) { // NODE_LET
            const value = OmniVM_eval_expression(self, stmt.value);
            VMEnvironment_set(self.env, stmt.name, value);
            return null;
        }
        
        // Return statement
        if (stmt.kind === 7) { // NODE_RETURN
            const value = OmniVM_eval_expression(self, stmt.value);
            throw { _omni_return: true, value: value };
        }
        
        // If statement
        if (stmt.kind === 13) { // NODE_IF
            const condition = OmniVM_eval_expression(self, stmt.condition);
            if (condition) {
                return OmniVM_exec_block(self, stmt.consequence);
            } else if (stmt.alternative) {
                return OmniVM_exec_block(self, stmt.alternative);
            }
            return null;
        }
        
        // While statement
        if (stmt.kind === 14) { // NODE_WHILE
            let loopResult = null;
            while (OmniVM_eval_expression(self, stmt.condition)) {
                loopResult = OmniVM_exec_block(self, stmt.body);
                self.step_count++;
                // Safety limit
                if (self.step_count > 1000000) {
                    throw new Error("Infinite loop detected");
                }
            }
            return loopResult;
        }
        
        // Assignment
        if (stmt.kind === 16) { // NODE_ASSIGNMENT
            const value = OmniVM_eval_expression(self, stmt.value);
            VMEnvironment_set(self.env, stmt.name, value);
            return null;
        }
        
        // Call as statement
        if (stmt.kind === 6) { // NODE_CALL
            return OmniVM_eval_expression(self, stmt);
        }
        
        // Import (skip for VM)
        if (stmt.kind === 10) { // NODE_IMPORT
            return null;
        }
        
        // Native block (skip for VM)
        if (stmt.kind === 80) { // NODE_NATIVE
            return null;
        }
        
        // Capsule (register flows)
        if (stmt.kind === 93) { // NODE_CAPSULE
            const capsule = {
                _omni_capsule: true,
                name: stmt.name,
                flows: {}
            };
            for (const flow of (stmt.flows || [])) {
                capsule.flows[flow.name] = {
                    params: flow.params,
                    body: flow.body
                };
            }
            VMEnvironment_set(self.env, stmt.name, capsule);
            return null;
        }
        
        // Expression statement (Statement wrapper)
        if (stmt.kind === 20) { // NODE_EXPRESSION_STMT
             return OmniVM_eval_expression(self, stmt.expr);
        }
        
        console.warn("[vm] Unknown statement kind:", stmt.kind);
        return null;
    
    return result;
}
function OmniVM_exec_block(self, block) {
    let result = 0;
    
        if (!block) return null;
        
        const statements = Array.isArray(block) ? block : (block.statements || []);
        
        for (const stmt of statements) {
            self.step_count++;
            result = OmniVM_exec_statement(self, stmt);
        }
    
    return result;
}
function OmniVM_eval_expression(self, expr) {
    let result = 0;
    
        if (!expr) return null;
        
        // Literal
        if (expr.kind === 3) { // NODE_LITERAL
            const val = expr.value;
            if (val === 'true') return true;
            if (val === 'false') return false;
            if (val === 'null') return null;
            return isNaN(Number(val)) ? val : Number(val);
        }
        
        // String
        if (expr.kind === 17) { // NODE_STRING
            return expr.value;
        }
        
        // Boolean
        if (expr.kind === 18) { // NODE_BOOL
            return expr.value;
        }
        
        // Identifier
        if (expr.kind === 15) { // NODE_IDENTIFIER
            const name = expr.value || expr.name;
            return VMEnvironment_get(self.env, name);
        }
        
        // Binary expression
        if (expr.kind === 8) { // NODE_BINARY
            const left = OmniVM_eval_expression(self, expr.left);
            const right = OmniVM_eval_expression(self, expr.right);
            const op = expr.op;
            
            switch (op) {
                case '+': return left + right;
                case '-': return left - right;
                case '*': return left * right;
                case '/': return left / right;
                case '%': return left % right;
                case '==': return left === right;
                case '!=': return left !== right;
                case '<': return left < right;
                case '<=': return left <= right;
                case '>': return left > right;
                case '>=': return left >= right;
                case '&&': return left && right;
                case '||': return left || right;
                default: throw new Error("Unknown operator: " + op);
            }
        }
        
        // Call expression
        if (expr.kind === 6) { // NODE_CALL
            // Fix: CallExpr uses 'function' field (AST), not 'callee' or 'name'
            const funcNode = expr.function;
            const fnName = funcNode ? (funcNode.value || funcNode.name) : '';

            const args = (expr.args || []).map(a => OmniVM_eval_expression(self, a));
            
            // Check builtin
            const builtin = VMEnvironment_get_function(self.env, fnName);
            if (builtin && typeof builtin === 'function') {
                return builtin(...args);
            }
            
            // Check user function
            if (builtin && builtin._omni_fn) {
                return OmniVM_call_function(self, builtin, args);
            }
            
            throw new Error("Function not found: " + fnName);
        }
        
        // Member access
        if (expr.kind === 9) { // NODE_MEMBER
            const obj = OmniVM_eval_expression(self, expr.object);
            return obj ? obj[expr.member] : undefined;
        }
        
        // Array literal
        if (expr.kind === 11) { // NODE_ARRAY
            return (expr.elements || []).map(e => OmniVM_eval_expression(self, e));
        }
        
        // Struct init
        if (expr.kind === 12) { // NODE_STRUCT_INIT
            const obj = {};
            if (expr.fields) {
                for (const [k, v] of Object.entries(expr.fields)) {
                    obj[k] = OmniVM_eval_expression(self, v);
                }
            }
            return obj;
        }
        
        return expr.value;
    
    return result;
}
function OmniVM_call_function(self, func, args) {
    let result = 0;
    
        // Create new environment for function scope
        const prevEnv = self.env;
        self.env = VMEnvironment_new(prevEnv);
        
        // Bind parameters
        for (let i = 0; i < func.params.length; i++) {
            const paramName = typeof func.params[i] === 'string' ? func.params[i] : func.params[i].name;
            VMEnvironment_set(self.env, paramName, args[i]);
        }
        
        try {
            result = OmniVM_exec_block(self, func.body);
        } catch (e) {
            if (e._omni_return) {
                result = e.value;
            } else {
                throw e;
            }
        }
        
        // Restore environment
        self.env = prevEnv;
    
    return result;
}

module.exports = { new_map, VMEnvironment_new, VMEnvironment_get, VMEnvironment_set, VMEnvironment_get_function, VMEnvironment_set_function, OmniVM_new, OmniVM_run, OmniVM_exec_statement, OmniVM_exec_block, OmniVM_eval_expression, OmniVM_call_function };


class FrameworkAdapter {
    constructor(data = {}) {
        this.name = data.name;
        this.language = data.language;
        this.ui_templates = data.ui_templates;
        this.server_templates = data.server_templates;
        this.structure = data.structure;
    }
}
function FrameworkAdapter_new(name) {
    return new FrameworkAdapter({ name: name, language: "javascript", ui_templates: null });
    // Unknown stmt kind: 0
    server_templates;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
}
// Unknown stmt kind: undefined
// Unknown stmt kind: undefined
// Unknown stmt kind: undefined
function FrameworkAdapter_nextjs() {
    let adapter = FrameworkAdapter_new("nextjs");
    
        adapter.language = "typescript";
        
        // UI Templates
        adapter.ui_templates = {
            page: `// Generated by Omni Compiler
import { Suspense } from 'react';

export default function {name}Page() {
    return (
        <main className="container mx-auto p-4">
            {content}
        </main>
    );
}`,
            
            component: `'use client';

import { useState } from 'react';

export function {name}({props}) {
    {body}
}`,
            
            button: `<button
    className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
    onClick={{action}}
>
    {label}
</button>`,
            
            input: `<input
    type="{type}"
    className="border rounded px-3 py-2"
    placeholder="{placeholder}"
    onChange={(e) => {onChange}(e.target.value)}
/>`,
            
            list: `<div className="space-y-2">
    {{items}.map((item, index) => (
        <div key={index}>
            {renderItem}
        </div>
    ))}
</div>`,

            card: `<div className="bg-white rounded-lg shadow p-4">
    {content}
</div>`
        };
        
        // Server Templates
        adapter.server_templates = {
            route: `// Generated by Omni Compiler
import { NextRequest, NextResponse } from 'next/server';

export async function {method}(request: NextRequest) {
    try {
        {body}
        return NextResponse.json({ success: true, data: result });
    } catch (error) {
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}`,
            
            middleware: `// Generated by Omni Compiler
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
    {body}
    return NextResponse.next();
}

export const config = {
    matcher: '{matcher}',
};`
        };
        
        // Project Structure
        adapter.structure = {
            'app/layout.tsx': `// Generated by Omni Compiler
import type { Metadata } from 'next';
import './globals.css';

export const metadata: Metadata = {
    title: '{projectName}',
    description: 'Generated by Omni Compiler',
};

export default function RootLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    return (
        <html lang="en">
            <body>{children}</body>
        </html>
    );
}`,
            
            'app/globals.css': `@tailwind base;
@tailwind components;
@tailwind utilities;`,
            
            'tailwind.config.ts': `import type { Config } from 'tailwindcss';

export default {
    content: ['./app/**/*.{js,ts,jsx,tsx}'],
    theme: { extend: {} },
    plugins: [],
} satisfies Config;`
        };
    
    return adapter;
}
function FrameworkAdapter_laravel() {
    let adapter = FrameworkAdapter_new("laravel");
    
        adapter.language = "php";
        
        // UI Templates (Blade)
        adapter.ui_templates = {
            page: `{{-- Generated by Omni Compiler --}}
@extends('layouts.app')

@section('title', '{title}')

@section('content')
<div class="container mx-auto px-4 py-8">
    {content}
</div>
@endsection`,
            
            component: `{{-- Component: {name} --}}
<div class="component-{name}">
    {content}
</div>`,
            
            button: `<button 
    class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
    onclick="{action}"
>
    {label}
</button>`,
            
            list: `@foreach({items} as $item)
    <div class="p-2">
        {renderItem}
    </div>
@endforeach`,

            card: `<div class="bg-white rounded-lg shadow p-4">
    {content}
</div>`
        };
        
        // Server Templates
        adapter.server_templates = {
            controller: `<?php

namespace App\\Http\\Controllers;

use Illuminate\\Http\\Request;
use Illuminate\\Http\\JsonResponse;

class {name}Controller extends Controller
{
    {methods}
}`,
            
            route_get: `Route::get('{path}', [{controller}::class, '{method}']);`,
            route_post: `Route::post('{path}', [{controller}::class, '{method}']);`,
            
            controller_method: `
    public function {name}(Request $request): JsonResponse
    {
        {body}
        return response()->json(['success' => true, 'data' => $result]);
    }`,
            
            middleware: `<?php

namespace App\\Http\\Middleware;

use Closure;
use Illuminate\\Http\\Request;

class {name}Middleware
{
    public function handle(Request $request, Closure $next)
    {
        {body}
        return $next($request);
    }
}`
        };
        
        // Project Structure
        adapter.structure = {
            'routes/api.php': `<?php

use Illuminate\\Support\\Facades\\Route;

{routes}`,
            
            'resources/views/layouts/app.blade.php': `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>@yield('title', '{projectName}')</title>
    @vite(['resources/css/app.css', 'resources/js/app.js'])
</head>
<body>
    @yield('content')
</body>
</html>`
        };
    
    return adapter;
}
function FrameworkAdapter_android() {
    let adapter = FrameworkAdapter_new("android");
    
        adapter.language = "kotlin";
        
        // UI Templates (Jetpack Compose)
        adapter.ui_templates = {
            screen: `// Generated by Omni Compiler
package {package}

import androidx.compose.runtime.*
import androidx.compose.material3.*
import androidx.compose.foundation.layout.*
import androidx.compose.ui.Modifier

@Composable
fun {name}Screen(
    onNavigate: (String) -> Unit = {}
) {
    Column(
        modifier = Modifier.fillMaxSize().padding(16.dp)
    ) {
        {content}
    }
}`,
            
            button: `Button(
    onClick = { {action} },
    modifier = Modifier.fillMaxWidth()
) {
    Text("{label}")
}`,
            
            input: `var {name} by remember { mutableStateOf("") }
OutlinedTextField(
    value = {name},
    onValueChange = { {name} = it },
    label = { Text("{label}") },
    modifier = Modifier.fillMaxWidth()
)`,
            
            list: `LazyColumn {
    items({items}) { item ->
        {renderItem}
    }
}`,
            
            card: `Card(
    modifier = Modifier.fillMaxWidth().padding(8.dp)
) {
    Column(modifier = Modifier.padding(16.dp)) {
        {content}
    }
}`
        };
        
        // Server Templates (Ktor client)
        adapter.server_templates = {
            api_call: `suspend fun {name}({params}): Result<{returnType}> {
    return try {
        val response = httpClient.{method}("{url}") {
            contentType(ContentType.Application.Json)
            {body}
        }
        Result.success(response.body())
    } catch (e: Exception) {
        Result.failure(e)
    }
}`,
            
            repository: `// Generated by Omni Compiler
package {package}

import io.ktor.client.*
import io.ktor.client.request.*
import kotlinx.coroutines.*

class {name}Repository(
    private val httpClient: HttpClient
) {
    {methods}
}`
        };
    
    return adapter;
}
class FrameworkGenerator {
    constructor(data = {}) {
        this.adapter = data.adapter;
        this.output_dir = data.output_dir;
        this.files = data.files;
    }
}
function FrameworkGenerator_new(framework, output_dir) {
    let adapter = FrameworkAdapter_new(framework);
    
        switch (framework) {
            case 'nextjs':
            case 'next':
                adapter = FrameworkAdapter_nextjs();
                break;
            case 'laravel':
                adapter = FrameworkAdapter_laravel();
                break;
            case 'android':
            case 'kotlin':
                adapter = FrameworkAdapter_android();
                break;
            default:
                console.warn("[adapter] Unknown framework:", framework);
        }
    
    return new FrameworkGenerator({ adapter: adapter, output_dir: output_dir, files: null });
}
// Unknown stmt kind: undefined
function FrameworkGenerator_generate_structure(self, project_name) {
    
        
        // Create base directory
        if (!fs.existsSync(self.output_dir)) {
            fs.mkdirSync(self.output_dir, { recursive: true });
        }
        
        // Generate structure files
        for (const [filePath, template] of Object.entries(self.adapter.structure)) {
            const fullPath = path.join(self.output_dir, filePath);
            const dir = path.dirname(fullPath);
            
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
            
            const content = template
                .replace(/\{projectName\}/g, project_name)
                .replace(/\{package\}/g, 'com.omni.' + project_name.toLowerCase());
            
            fs.writeFileSync(fullPath, content);
            console.log("[adapter] Created:", filePath);
        }
    
}
function FrameworkGenerator_generate_ui(self, name, annotation) {
    let result = "";
    
        const templateName = annotation.type || 'component';
        const template = self.adapter.ui_templates[templateName];
        
        if (!template) {
            result = "/* UI template not found: " + templateName + " */";
            return;
        }
        
        result = template
            .replace(/\{name\}/g, name)
            .replace(/\{label\}/g, annotation.label || name)
            .replace(/\{action\}/g, annotation.action || 'onClick')
            .replace(/\{content\}/g, annotation.content || '')
            .replace(/\{props\}/g, annotation.props || '');
    
    return result;
}
function FrameworkGenerator_generate_server(self, capsule) {
    let result = "";
    
        
        const capsuleName = capsule.name;
        const flows = capsule.flows || [];
        
        if (self.adapter.name === 'nextjs') {
            // Generate API routes for Next.js
            for (const flow of flows) {
                const serverAttr = flow.attributes?.find(a => a.name.startsWith('server.'));
                if (serverAttr) {
                    const method = serverAttr.name.split('.')[1].toUpperCase();
                    const routePath = serverAttr.args?.[0] || '/' + capsuleName.toLowerCase() + '/' + flow.name;
                    
                    const template = self.adapter.server_templates.route;
                    const code = template
                        .replace(/\{method\}/g, method)
                        .replace(/\{body\}/g, 'const result = await ' + capsuleName + '.' + flow.name + '();');
                    
                    // Write route file
                    const routeDir = path.join(self.output_dir, 'app/api', capsuleName.toLowerCase(), flow.name);
                    if (!fs.existsSync(routeDir)) {
                        fs.mkdirSync(routeDir, { recursive: true });
                    }
                    fs.writeFileSync(path.join(routeDir, 'route.ts'), code);
                    console.log("[adapter] Created: app/api/" + capsuleName.toLowerCase() + "/" + flow.name + "/route.ts");
                }
            }
        } else if (self.adapter.name === 'laravel') {
            // Generate Controller for Laravel
            let methods = '';
            let routes = '';
            
            for (const flow of flows) {
                const serverAttr = flow.attributes?.find(a => a.name.startsWith('server.'));
                if (serverAttr) {
                    const httpMethod = serverAttr.name.split('.')[1];
                    const routePath = serverAttr.args?.[0] || '/' + capsuleName.toLowerCase() + '/' + flow.name;
                    
                    methods += self.adapter.server_templates.controller_method
                        .replace(/\{name\}/g, flow.name)
                        .replace(/\{body\}/g, '$result = null; // TODO: implement');
                    
                    const routeTemplate = httpMethod === 'get' 
                        ? self.adapter.server_templates.route_get 
                        : self.adapter.server_templates.route_post;
                    routes += routeTemplate
                        .replace(/\{path\}/g, routePath)
                        .replace(/\{controller\}/g, capsuleName + 'Controller')
                        .replace(/\{method\}/g, flow.name) + '\n';
                }
            }
            
            const controller = self.adapter.server_templates.controller
                .replace(/\{name\}/g, capsuleName)
                .replace(/\{methods\}/g, methods);
            
            // Write controller
            const controllerDir = path.join(self.output_dir, 'app/Http/Controllers');
            if (!fs.existsSync(controllerDir)) {
                fs.mkdirSync(controllerDir, { recursive: true });
            }
            fs.writeFileSync(path.join(controllerDir, capsuleName + 'Controller.php'), controller);
            console.log("[adapter] Created: app/Http/Controllers/" + capsuleName + "Controller.php");
            
            result = routes;
        }
    
    return result;
}
function FrameworkGenerator_add_file(self, path, content) {
    
        self.files[path] = content;
    
}
function FrameworkGenerator_write_all(self) {
    
        
        for (const [filePath, content] of Object.entries(self.files)) {
            const fullPath = path.join(self.output_dir, filePath);
            const dir = path.dirname(fullPath);
            
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
            
            fs.writeFileSync(fullPath, content);
            console.log("[adapter] Written:", filePath);
        }
    
}

    exports.FrameworkAdapter = FrameworkAdapter;
    exports.FrameworkAdapter_nextjs = FrameworkAdapter_nextjs;
    exports.FrameworkAdapter_laravel = FrameworkAdapter_laravel;
    exports.FrameworkAdapter_android = FrameworkAdapter_android;
    exports.FrameworkGenerator = FrameworkGenerator;
    exports.FrameworkGenerator_new = FrameworkGenerator_new;
    exports.FrameworkGenerator_generate_structure = FrameworkGenerator_generate_structure;
    exports.FrameworkGenerator_generate_ui = FrameworkGenerator_generate_ui;
    exports.FrameworkGenerator_generate_server = FrameworkGenerator_generate_server;


module.exports = { FrameworkAdapter_new, FrameworkAdapter_nextjs, FrameworkAdapter_laravel, FrameworkAdapter_android, FrameworkGenerator_new, FrameworkGenerator_generate_structure, FrameworkGenerator_generate_ui, FrameworkGenerator_generate_server, FrameworkGenerator_add_file, FrameworkGenerator_write_all };


class CanonicalPattern {
    constructor(data = {}) {
        this.name = data.name;
        this.language = data.language;
        this.signature = data.signature;
        this.omni_equivalent = data.omni_equivalent;
        this.confidence = data.confidence;
    }
}
function CanonicalPattern_new(name, lang, sig, omni) {
    return new CanonicalPattern({ name: name, language: lang, signature: sig, omni_equivalent: omni, confidence: 100 });
}
class PatternDatabase {
    constructor(data = {}) {
        this.patterns = data.patterns;
    }
}
function new_map() {
     return {}; 
    return 0;
}
function PatternDatabase_new() {
    let db = new PatternDatabase({ patterns: new_map() });
    
        db.patterns = patterns;
        
        // Load external patterns from patterns/ directory
        const patternsDir = path.join(__dirname, '..', 'patterns');
        
        if (fs.existsSync(patternsDir)) {
            const files = fs.readdirSync(patternsDir).filter(f => f.endsWith('.json'));
            
            for (const file of files) {
                try {
                    const content = JSON.parse(fs.readFileSync(path.join(patternsDir, file), 'utf-8'));
                    const lang = content.language || path.basename(file, '.json');
                    
                    if (!db.patterns[lang]) {
                        db.patterns[lang] = [];
                    }
                    
                    // Add patterns from external file
                    for (const pattern of (content.patterns || [])) {
                        db.patterns[lang].push({
                            name: pattern.name,
                            regex: new RegExp(pattern.regex, pattern.flags || ''),
                            toOmni: (m) => {
                                let result = pattern.template;
                                for (let i = 0; i < m.length; i++) {
                                    result = result.replace(new RegExp('\\{' + i + '\\}', 'g'), m[i] || '');
                                }
                                return result;
                            }
                        });
                    }
                    
                    console.log("[ingest] Loaded external patterns: " + lang);
                } catch (e) {
                    console.warn("[ingest] Failed to load patterns from " + file + ": " + e.message);
                }
            }
        }
    
    return db;
}
// Unknown stmt kind: undefined
class IngestionEngine {
    constructor(data = {}) {
        this.patterns = data.patterns;
        this.source_language = data.source_language;
        this.detected_patterns = data.detected_patterns;
        this.omni_output = data.omni_output;
        this.confidence_score = data.confidence_score;
    }
}
function IngestionEngine_new(source_lang) {
    return new IngestionEngine({ patterns: PatternDatabase_new(), source_language: source_lang, detected_patterns: [], omni_output: "", confidence_score: 0 });
}
function IngestionEngine_detect_language(source) {
    let lang = "unknown";
    
        // Heuristic language detection
        if (source.includes('<?php') || source.includes('<?=')) {
            lang = 'php';
        } else if (source.includes('public class') || source.includes('import java.')) {
            lang = 'java';
        } else if (source.includes('def ') && source.includes(':') && !source.includes('{')) { // }
            lang = 'python';
        } else if (source.includes('function') || source.includes('=>') || source.includes('const ')) {
            lang = 'javascript';
        } else if (source.includes('fn ') || source.includes('let ') || source.includes('use ')) {
            if (source.includes('->') && source.includes('::')) {
                lang = 'rust';
            }
        }
    
    return lang;
}
function IngestionEngine_analyze(self, source) {
    
        const patterns = self.patterns.patterns[self.source_language] || [];
        self.detected_patterns = [];
        
        for (const pattern of patterns) {
            const matches = source.match(new RegExp(pattern.regex, 'gm'));
            if (matches) {
                for (const match of matches) {
                    const groups = match.match(pattern.regex);
                    if (groups) {
                        self.detected_patterns.push({
                            pattern: pattern.name,
                            match: match,
                            omni: pattern.toOmni(groups)
                        });
                    }
                }
            }
        }
        
        // Calculate confidence based on pattern coverage
        if (self.detected_patterns.length > 0) {
            self.confidence_score = Math.min(100, self.detected_patterns.length * 15);
        }
    
}
function IngestionEngine_generate_omni(self) {
    let output = "";
    
        output = "// ============================================================================\n";
        output += "// AUTO-GENERATED OMNI CODE\n";
        output += "// Source Language: " + self.source_language.toUpperCase() + "\n";
        output += "// Confidence Score: " + self.confidence_score + "%\n";
        output += "// Patterns Detected: " + self.detected_patterns.length + "\n";
        output += "// ============================================================================\n\n";
        
        // Group by pattern type
        const structs = [];
        const capsules = [];
        const functions = [];
        const flows = [];
        
        for (const detected of self.detected_patterns) {
            const omni = detected.omni;
            if (omni.includes('@entity') || omni.includes('struct')) {
                structs.push(omni);
            } else if (omni.includes('capsule') || omni.includes('@server')) {
                capsules.push(omni);
            } else if (omni.includes('flow')) {
                flows.push(omni);
            } else if (omni.includes('fn ')) {
                functions.push(omni);
            }
        }
        
        // Output in logical order
        if (structs.length > 0) {
            output += "// === ENTITIES ===\n\n";
            output += structs.join('\n\n') + '\n\n';
        }
        
        if (capsules.length > 0 || flows.length > 0) {
            output += "// === CAPSULES ===\n\n";
            output += capsules.join('\n\n') + '\n';
            output += flows.join('\n') + '\n\n';
        }
        
        if (functions.length > 0) {
            output += "// === FUNCTIONS ===\n\n";
            output += functions.join('\n\n') + '\n\n';
        }
        
        // Add main if no capsules
        if (capsules.length === 0) {
            output += "fn main() {\n";
            output += "    // TODO: Implement main logic\n";
            output += "}\n";
        }
        
        self.omni_output = output;
    
    return output;
}
function IngestionEngine_report(self) {
    
        console.log("\n");
        console.log("        INGESTION ANALYSIS REPORT           ");
        console.log("");
        console.log(" Source Language: " + self.source_language.toUpperCase().padEnd(25) + "");
        console.log(" Patterns Found:  " + String(self.detected_patterns.length).padEnd(25) + "");
        console.log(" Confidence:      " + (self.confidence_score + "%").padEnd(25) + "");
        console.log("");
        console.log("\nDetected Patterns:");
        
        const patternCounts = {};
        for (const p of self.detected_patterns) {
            patternCounts[p.pattern] = (patternCounts[p.pattern] || 0) + 1;
        }
        
        for (const [name, count] of Object.entries(patternCounts)) {
            console.log("   " + name + ": " + count);
        }
    
}
function cmd_ingest(input_file, output_file) {
    CLI_header("Omni Ingestion Engine");
    CLI_info("Analyzing: " + input_file);
    let source = read_file(input_file);
    let lang = IngestionEngine_detect_language(source);
    CLI_info("Detected language: " + lang);
    if (lang == "unknown") {
    CLI_error("Could not detect source language");
    return null;
}
    let engine = IngestionEngine_new(lang);
    IngestionEngine_analyze(engine, source);
    IngestionEngine_report(engine);
    let omni_code = IngestionEngine_generate_omni(engine);
    write_file(output_file, omni_code);
    CLI_success("Generated: " + output_file);
    CLI_info("Review the generated code and add missing implementation details.");
}

module.exports = { CanonicalPattern_new, new_map, PatternDatabase_new, IngestionEngine_new, IngestionEngine_detect_language, IngestionEngine_analyze, IngestionEngine_generate_omni, IngestionEngine_report, cmd_ingest };


class GitPackage {
    constructor(data = {}) {
        this.name = data.name;
        this.provider = data.provider;
        this.owner = data.owner;
        this.repo = data.repo;
        this.full_url = data.full_url;
        this.commit = data.commit;
        this.branch = data.branch;
        this.local_path = data.local_path;
    }
}
function GitPackage_parse(spec) {
    let pkg = new GitPackage({ name: "", provider: "github", owner: "", repo: "", full_url: "", commit: "", branch: "main", local_path: "" });
    
        
        // Parse different formats:
        // github:user/repo
        // gitlab:user/repo
        // https://github.com/user/repo
        // user/repo (default to github)
        
        let input = spec.trim();
        
        if (input.startsWith('github:')) {
            pkg.provider = 'github';
            input = input.substring(7);
        } else if (input.startsWith('gitlab:')) {
            pkg.provider = 'gitlab';
            input = input.substring(7);
        } else if (input.startsWith('https://github.com/')) {
            pkg.provider = 'github';
            input = input.substring(19);
        } else if (input.startsWith('https://gitlab.com/')) {
            pkg.provider = 'gitlab';
            input = input.substring(19);
        } else if (input.startsWith('http://') || input.startsWith('https://')) {
            pkg.provider = 'url';
            pkg.full_url = input;
            // Extract name from URL
            const parts = input.split('/');
            pkg.name = parts.slice(-2).join('/');
            pkg.owner = parts[parts.length - 2];
            pkg.repo = parts[parts.length - 1].replace('.git', '');
        }
        
        // Parse owner/repo format
        if (!pkg.full_url && input.includes('/')) {
            const parts = input.split('/');
            pkg.owner = parts[0];
            pkg.repo = parts[1].replace('.git', '');
            pkg.name = pkg.owner + '/' + pkg.repo;
            
            if (pkg.provider === 'github') {
                pkg.full_url = 'https://github.com/' + pkg.owner + '/' + pkg.repo;
            } else if (pkg.provider === 'gitlab') {
                pkg.full_url = 'https://gitlab.com/' + pkg.owner + '/' + pkg.repo;
            }
        }
        
        // Set local path
        pkg.local_path = path.join('packages', pkg.owner, pkg.repo);
    
    return pkg;
}
function GitPackage_get_zip_url(pkg) {
    let url = "";
    
        if (pkg.provider === 'github') {
            // GitHub archive URL (no git required)
            const branch = pkg.commit || pkg.branch || 'main';
            url = pkg.full_url + '/archive/refs/heads/' + branch + '.zip';
        } else if (pkg.provider === 'gitlab') {
            const branch = pkg.commit || pkg.branch || 'main';
            url = pkg.full_url + '/-/archive/' + branch + '/' + pkg.repo + '-' + branch + '.zip';
        } else {
            url = pkg.full_url;
        }
    
    return url;
}
function GitPackage_get_api_url(pkg) {
    let url = "";
    
        if (pkg.provider === 'github') {
            url = 'https://api.github.com/repos/' + pkg.owner + '/' + pkg.repo;
        } else if (pkg.provider === 'gitlab') {
            url = 'https://gitlab.com/api/v4/projects/' + encodeURIComponent(pkg.owner + '/' + pkg.repo);
        }
    
    return url;
}
class LockEntry {
    constructor(data = {}) {
        this.name = data.name;
        this.url = data.url;
        this.commit = data.commit;
        this.installed_at = data.installed_at;
    }
}
class LockFile {
    constructor(data = {}) {
        this.version = data.version;
        this.packages = data.packages;
    }
}
function new_map() {
     return {}; 
    return 0;
}
function LockFile_load(project_dir) {
    let lock = new LockFile({ version: "1.0", packages: new_map() });
    
        
        const lockPath = path.join(project_dir, 'omni.lock');
        
        if (fs.existsSync(lockPath)) {
            try {
                const data = JSON.parse(fs.readFileSync(lockPath, 'utf-8'));
                lock.version = data.version || '1.0';
                lock.packages = data.packages || {};
            } catch (e) {
                console.error('[lock] Failed to parse omni.lock: ' + e.message);
            }
        }
    
    return lock;
}
function LockFile_save(lock, project_dir) {
    
        
        const lockPath = path.join(project_dir, 'omni.lock');
        
        fs.writeFileSync(lockPath, JSON.stringify({
            version: lock.version,
            packages: lock.packages
        }, null, 2));
        
        console.log(CLI_COLORS.green + '' + CLI_COLORS.reset + ' Updated omni.lock');
    
}
function LockFile_add(lock, pkg) {
    
        lock.packages[pkg.name] = {
            name: pkg.name,
            url: pkg.full_url,
            commit: pkg.commit,
            installed_at: new Date().toISOString()
        };
    
}
function LockFile_get(lock, name) {
    let entry = new LockEntry({ name: "", url: "", commit: "", installed_at: "" });
    
        if (lock.packages[name]) {
            entry = lock.packages[name];
        }
    
    return entry;
}
function LockFile_remove(lock, name) {
    
        delete lock.packages[name];
    
}
function git_get_latest_commit(pkg) {
    let commit = "";
    
        
        // Use GitHub API to get latest commit
        if (pkg.provider === 'github') {
            const apiUrl = 'https://api.github.com/repos/' + pkg.owner + '/' + pkg.repo + '/commits?per_page=1';
            
            console.log(CLI_COLORS.dim + '  Fetching latest commit...' + CLI_COLORS.reset);
            
            // Sync HTTP request (simplified for demo)
            const { execSync } = require('child_process');
            try {
                const result = execSync(
                    'curl -s -H "Accept: application/vnd.github.v3+json" "' + apiUrl + '"',
                    { encoding: 'utf-8' }
                );
                const data = JSON.parse(result);
                if (data && data[0] && data[0].sha) {
                    commit = data[0].sha;
                }
            } catch (e) {
                console.error(CLI_COLORS.dim + '  Could not fetch commit, using HEAD' + CLI_COLORS.reset);
            }
        }
    
    return commit;
}
function git_clone(pkg, target_dir) {
    let success = false;
    
        const { execSync, exec } = require('child_process');
        
        // Ensure parent directory exists
        const parentDir = path.dirname(target_dir);
        if (!fs.existsSync(parentDir)) {
            fs.mkdirSync(parentDir, { recursive: true });
        }
        
        // Remove existing directory
        if (fs.existsSync(target_dir)) {
            fs.rmSync(target_dir, { recursive: true });
        }
        
        console.log(CLI_COLORS.cyan + '  Cloning: ' + CLI_COLORS.reset + pkg.full_url);
        
        try {
            // Try git clone first (depth 1 for speed)
            execSync(
                'git clone --depth 1 --quiet "' + pkg.full_url + '.git" "' + target_dir + '"',
                { stdio: 'pipe' }
            );
            success = true;
        } catch (e) {
            // Fallback to ZIP download
            console.log(CLI_COLORS.dim + '  Git not available, using ZIP download...' + CLI_COLORS.reset);
            
            const zipUrl = GitPackage_get_zip_url(pkg);
            const zipPath = path.join(parentDir, pkg.repo + '.zip');
            
            try {
                // Download ZIP
                execSync('curl -sL "' + zipUrl + '" -o "' + zipPath + '"');
                
                // Extract
                if (process.platform === 'win32') {
                    execSync('powershell -Command "Expand-Archive -Path \'' + zipPath + '\' -DestinationPath \'' + parentDir + '\' -Force"');
                } else {
                    execSync('unzip -q "' + zipPath + '" -d "' + parentDir + '"');
                }
                
                // Rename extracted folder
                const entries = fs.readdirSync(parentDir);
                for (const entry of entries) {
                    if (entry.startsWith(pkg.repo + '-') && fs.statSync(path.join(parentDir, entry)).isDirectory()) {
                        fs.renameSync(path.join(parentDir, entry), target_dir);
                        break;
                    }
                }
                
                // Cleanup ZIP
                fs.unlinkSync(zipPath);
                
                success = true;
            } catch (e2) {
                CLI_error('Failed to download package: ' + e2.message);
            }
        }
    
    return success;
}
function cmd_install(package_spec) {
    CLI_banner();
    CLI_header("Omni Package Installer");
    if (package_spec == "") {
    cmd_install_from_lock();
    return null;
}
    let pkg = GitPackage_parse(package_spec);
    if (pkg.name == "") {
    CLI_error("Invalid package specification: " + package_spec);
    CLI_info("Examples:");
    CLI_info("  omni install github:crom/utils");
    CLI_info("  omni install crom/utils");
    CLI_info("  omni install https://github.com/crom/utils");
    return null;
}
    CLI_info("Package: " + pkg.name);
    CLI_info("Source: " + pkg.full_url);
    let commit = git_get_latest_commit(pkg);
    if (commit != "") {
    pkg.commit = commit;
    CLI_info("Commit: " + commit.substring(0, 8) + "...");
}
    let cwd = "";
     cwd = process.cwd(); 
    let target = "";
    
        target = path.join(cwd, pkg.local_path);
    
    CLI_step(1, 3, "Downloading...");
    let success = git_clone(pkg, target);
    if (success) {
    CLI_step(2, 3, "Updating lock file...");
    let lock = LockFile_load(cwd);
    LockFile_add(lock, pkg);
    LockFile_save(lock, cwd);
    CLI_step(3, 3, "Done!");
    CLI_success("Installed: " + pkg.name);
    
            console.log("");
            console.log(CLI_COLORS.cyan + "  Usage:" + CLI_COLORS.reset);
            console.log(CLI_COLORS.dim + '    import "' + pkg.owner + '/' + pkg.repo + '/src/main.omni";' + CLI_COLORS.reset);
        
} else {
    CLI_error("Failed to install package");
}
}
function cmd_install_from_lock() {
    CLI_info("Installing packages from omni.lock...");
    let cwd = "";
     cwd = process.cwd(); 
    let lock = LockFile_load(cwd);
    
        const packages = Object.values(lock.packages);
        
        if (packages.length === 0) {
            terminal.CLI_info("No packages in omni.lock");
            return;
        }
        
        console.log(CLI_COLORS.dim + "  Found " + packages.length + " packages" + CLI_COLORS.reset);
        
        for (const entry of packages) {
            const pkg = GitPackage_parse(entry.url);
            pkg.commit = entry.commit;
            
            const target = path.join(cwd, pkg.local_path);
            
            console.log(CLI_COLORS.cyan + "  Installing: " + CLI_COLORS.reset + pkg.name);
            git_clone(pkg, target);
        }
        
        CLI_success("All packages installed!");
    
}
function cmd_uninstall(package_name) {
    CLI_banner();
    CLI_header("Omni Package Uninstaller");
    if (package_name == "") {
    CLI_error("Usage: omni uninstall <package>");
    return null;
}
    let cwd = "";
     cwd = process.cwd(); 
    let lock = LockFile_load(cwd);
    let found = false;
    
        
        // Find package in lock
        for (const [name, entry] of Object.entries(lock.packages)) {
            if (name === package_name || name.endsWith('/' + package_name)) {
                found = true;
                
                // Remove directory
                const pkg = GitPackage_parse(entry.url);
                const targetDir = path.join(cwd, pkg.local_path);
                
                if (fs.existsSync(targetDir)) {
                    fs.rmSync(targetDir, { recursive: true });
                    console.log(CLI_COLORS.dim + "  Removed: " + targetDir + CLI_COLORS.reset);
                }
                
                // Remove from lock
                LockFile_remove(lock, name);
                break;
            }
        }
    
    if (found) {
    LockFile_save(lock, cwd);
    CLI_success("Uninstalled: " + package_name);
} else {
    CLI_error("Package not found: " + package_name);
}
}
function cmd_list() {
    CLI_banner();
    CLI_header("Installed Packages");
    let cwd = "";
     cwd = process.cwd(); 
    let lock = LockFile_load(cwd);
    
        const packages = Object.values(lock.packages);
        
        if (packages.length === 0) {
            terminal.CLI_info("No packages installed.");
            console.log("");
            terminal.CLI_info("Install packages with: omni install github:user/repo");
            return;
        }
        
        console.log("");
        console.log(CLI_COLORS.cyan + "  " + packages.length + " packages installed:" + CLI_COLORS.reset);
        console.log("");
        
        for (const pkg of packages) {
            const commit = pkg.commit ? pkg.commit.substring(0, 8) : 'HEAD';
            console.log("   " + CLI_COLORS.bold + pkg.name + CLI_COLORS.reset + 
                        CLI_COLORS.dim + " @ " + commit + CLI_COLORS.reset);
            console.log("     " + CLI_COLORS.dim + pkg.url + CLI_COLORS.reset);
        }
        
        console.log("");
    
}
function cmd_update(package_name) {
    CLI_banner();
    CLI_header("Omni Package Updater");
    let cwd = "";
     cwd = process.cwd(); 
    let lock = LockFile_load(cwd);
    
        let packagesToUpdate = Object.values(lock.packages);
        
        if (package_name) {
            packagesToUpdate = packagesToUpdate.filter(p => 
                p.name === package_name || p.name.endsWith('/' + package_name)
            );
        }
        
        if (packagesToUpdate.length === 0) {
            CLI_info("No packages to update");
            return;
        }
        
        console.log(CLI_COLORS.dim + "  Updating " + packagesToUpdate.length + " packages..." + CLI_COLORS.reset);
        
        for (const entry of packagesToUpdate) {
            const pkg = GitPackage_parse(entry.url);
            
            console.log(CLI_COLORS.cyan + "  Updating: " + CLI_COLORS.reset + pkg.name);
            
            // Get latest commit
            const newCommit = git_get_latest_commit(pkg);
            
            if (newCommit && newCommit !== entry.commit) {
                console.log(CLI_COLORS.dim + "    " + entry.commit.substring(0, 8) + "  " + newCommit.substring(0, 8) + CLI_COLORS.reset);
                
                pkg.commit = newCommit;
                const target = path.join(cwd, pkg.local_path);
                git_clone(pkg, target);
                
                LockFile_add(lock, pkg);
            } else {
                console.log(CLI_COLORS.dim + "    Already up to date" + CLI_COLORS.reset);
            }
        }
        
        LockFile_save(lock, cwd);
        CLI_success("Update complete!");
    
}
function cmd_doctor() {
    CLI_banner();
    CLI_header("Omni Doctor - System Health Check");
    
        const { execSync } = require('child_process');
        
        let allOk = true;
        
        // Check git
        console.log("");
        console.log(CLI_COLORS.cyan + "  Checking tools:" + CLI_COLORS.reset);
        
        const tools = [
            { name: 'git', cmd: 'git --version' },
            { name: 'node', cmd: 'node --version' },
            { name: 'curl', cmd: 'curl --version' }
        ];
        
        for (const tool of tools) {
            try {
                const version = execSync(tool.cmd, { encoding: 'utf-8' }).trim().split('\n')[0];
                console.log("  " + CLI_COLORS.green + "" + CLI_COLORS.reset + " " + tool.name + ": " + CLI_COLORS.dim + version + CLI_COLORS.reset);
            } catch (e) {
                console.log("  " + CLI_COLORS.red + "" + CLI_COLORS.reset + " " + tool.name + ": not found");
                allOk = false;
            }
        }
        
        // Check omni.lock
        console.log("");
        console.log(CLI_COLORS.cyan + "  Checking project:" + CLI_COLORS.reset);
        
        const cwd = process.cwd();
        const files = [
            { name: 'omni.config.json', path: path.join(cwd, 'omni.config.json') },
            { name: 'omni.lock', path: path.join(cwd, 'omni.lock') },
            { name: 'packages/', path: path.join(cwd, 'packages') }
        ];
        
        for (const file of files) {
            if (fs.existsSync(file.path)) {
                console.log("  " + CLI_COLORS.green + "" + CLI_COLORS.reset + " " + file.name);
            } else {
                console.log("  " + CLI_COLORS.yellow + "" + CLI_COLORS.reset + " " + file.name + CLI_COLORS.dim + " (optional)" + CLI_COLORS.reset);
            }
        }
        
        console.log("");
        if (allOk) {
            CLI_success("All systems operational!");
        } else {
            CLI_warning("Some tools are missing. Git is recommended for package installation.");
        }
    
}
function cmd_search(query) {
    CLI_banner();
    CLI_header("Omni Package Search");
    
        
        // Fetch from static registry JSON
        const registryUrl = 'https://raw.githubusercontent.com/crom-lang/registry/main/packages.json';
        
        console.log(CLI_COLORS.dim + "  Fetching registry..." + CLI_COLORS.reset);
        
        const { execSync } = require('child_process');
        
        try {
            const result = execSync('curl -sL "' + registryUrl + '"', { encoding: 'utf-8' });
            const registry = JSON.parse(result);
            
            let results = registry.packages || [];
            
            if (query) {
                const q = query.toLowerCase();
                results = results.filter(p => 
                    p.name.toLowerCase().includes(q) ||
                    (p.description && p.description.toLowerCase().includes(q)) ||
                    (p.tags && p.tags.some(t => t.toLowerCase().includes(q)))
                );
            }
            
            console.log("");
            console.log(CLI_COLORS.cyan + "  Found " + results.length + " packages:" + CLI_COLORS.reset);
            console.log("");
            
            for (const pkg of results.slice(0, 20)) {
                console.log("   " + CLI_COLORS.bold + pkg.name + CLI_COLORS.reset);
                if (pkg.description) {
                    console.log("     " + CLI_COLORS.dim + pkg.description + CLI_COLORS.reset);
                }
                console.log("     " + CLI_COLORS.dim + "omni install github:" + pkg.repo + CLI_COLORS.reset);
                console.log("");
            }
        } catch (e) {
            CLI_warning("Could not fetch registry. You can still install packages directly:");
            console.log(CLI_COLORS.dim + "  omni install github:user/repo" + CLI_COLORS.reset);
        }
    
}

module.exports = { GitPackage_parse, GitPackage_get_zip_url, GitPackage_get_api_url, new_map, LockFile_load, LockFile_save, LockFile_add, LockFile_get, LockFile_remove, git_get_latest_commit, git_clone, cmd_install, cmd_install_from_lock, cmd_uninstall, cmd_list, cmd_update, cmd_doctor, cmd_search };




class CapsuleGraph {
    constructor(data = {}) {
        this.name = data.name;
        this.flows = data.flows;
        this.entities = data.entities;
        this.dependencies = data.dependencies;
        this.attributes = data.attributes;
    }
}
class EntityGraph {
    constructor(data = {}) {
        this.name = data.name;
        this.fields = data.fields;
        this.relations = data.relations;
    }
}
class FlowGraph {
    constructor(data = {}) {
        this.name = data.name;
        this.params = data.params;
        this.return_type = data.return_type;
        this.calls = data.calls;
        this.attributes = data.attributes;
    }
}
class GhostWriter {
    constructor(data = {}) {
        this.capsules = data.capsules;
        this.entities = data.entities;
        this.functions = data.functions;
        this.imports = data.imports;
        this.call_graph = data.call_graph;
    }
}
function GhostWriter_new() {
    return new GhostWriter({ capsules: [], entities: [], functions: [], imports: [], call_graph: null });
}
// Unknown stmt kind: undefined
function GhostWriter_analyze(self, program) {
    
        if (!program || !program.statements) {
            console.error("[ghost] Invalid program");
            return;
        }
        
        for (const stmt of program.statements) {
            // Capsule
            if (stmt.kind === 93) { // NODE_CAPSULE
                const capsule = {
                    name: stmt.name,
                    flows: [],
                    entities: [],
                    dependencies: [],
                    attributes: stmt.attributes || []
                };
                
                for (const flow of (stmt.flows || [])) {
                    capsule.flows.push({
                        name: flow.name,
                        params: flow.params || [],
                        return_type: flow.return_type || 'void',
                        attributes: flow.attributes || []
                    });
                }
                
                self.capsules.push(capsule);
            }
            
            // Struct / Entity
            if (stmt.kind === 70) { // NODE_STRUCT
                const entity = {
                    name: stmt.name,
                    fields: stmt.fields || [],
                    isEntity: (stmt.attributes || []).some(a => a.name === 'entity')
                };
                self.entities.push(entity);
            }
            
            // Function
            if (stmt.kind === 4) { // NODE_FUNCTION
                const fn = {
                    name: stmt.name,
                    params: stmt.params || [],
                    return_type: stmt.return_type || 'void',
                    calls: []
                };
                
                // Extract function calls from body
                const extractCalls = (node) => {
                    if (!node) return;
                    if (node.kind === 6) { // NODE_CALL
                        fn.calls.push(node.name || (node.callee && node.callee.value));
                    }
                    if (Array.isArray(node)) {
                        node.forEach(extractCalls);
                    }
                    if (node.statements) extractCalls(node.statements);
                    if (node.body) extractCalls(node.body);
                    if (node.consequence) extractCalls(node.consequence);
                    if (node.alternative) extractCalls(node.alternative);
                };
                
                extractCalls(stmt.body);
                self.functions.push(fn);
            }
            
            // Import
            if (stmt.kind === 10) { // NODE_IMPORT
                self.imports.push(stmt.path || stmt.value);
            }
        }
        
        // Build call graph
        for (const fn of self.functions) {
            self.call_graph[fn.name] = fn.calls.filter(c => c);
        }
    
}
function GhostWriter_gen_class_diagram(self) {
    let diagram = "";
    
        diagram = "```mermaid\nclassDiagram\n";
        
        // Entities
        for (const entity of self.entities) {
            diagram += "    class " + entity.name + " {\n";
            
            for (const field of entity.fields) {
                const fieldName = field.name || field;
                const fieldType = field.type || 'any';
                diagram += "        +" + fieldType + " " + fieldName + "\n";
            }
            
            diagram += "    }\n\n";
        }
        
        // Capsules as classes
        for (const capsule of self.capsules) {
            diagram += "    class " + capsule.name + " {\n";
            diagram += "        <<capsule>>\n";
            
            for (const flow of capsule.flows) {
                const params = (flow.params || []).map(p => 
                    typeof p === 'string' ? p : p.name
                ).join(', ');
                diagram += "        +" + flow.name + "(" + params + ") " + flow.return_type + "\n";
            }
            
            diagram += "    }\n\n";
        }
        
        // Relations (capsules using entities)
        for (const capsule of self.capsules) {
            for (const entity of self.entities) {
                // Check if capsule references entity
                const capsuleStr = JSON.stringify(capsule);
                if (capsuleStr.includes(entity.name)) {
                    diagram += "    " + capsule.name + " --> " + entity.name + " : uses\n";
                }
            }
        }
        
        diagram += "```\n";
    
    return diagram;
}
function GhostWriter_gen_flowchart(self) {
    let diagram = "";
    
        diagram = "```mermaid\nflowchart TD\n";
        
        // Subgraphs for capsules
        for (const capsule of self.capsules) {
            diagram += "    subgraph " + capsule.name + "\n";
            
            for (const flow of capsule.flows) {
                const nodeId = capsule.name + "_" + flow.name;
                
                // Check for server attribute
                const serverAttr = flow.attributes.find(a => 
                    a.name && a.name.startsWith('server.')
                );
                
                if (serverAttr) {
                    const method = serverAttr.name.split('.')[1].toUpperCase();
                    diagram += "        " + nodeId + "[(" + method + " " + flow.name + ")]\n";
                } else {
                    diagram += "        " + nodeId + "[" + flow.name + "]\n";
                }
            }
            
            diagram += "    end\n\n";
        }
        
        // Connect capsule flows
        for (const capsule of self.capsules) {
            for (let i = 0; i < capsule.flows.length - 1; i++) {
                const from = capsule.name + "_" + capsule.flows[i].name;
                const to = capsule.name + "_" + capsule.flows[i + 1].name;
                // diagram += "    " + from + " --> " + to + "\n";
            }
        }
        
        // External connections
        for (const entity of self.entities.filter(e => e.isEntity)) {
            diagram += "    DB[(" + entity.name + " DB)]\n";
            
            for (const capsule of self.capsules) {
                const capsuleStr = JSON.stringify(capsule);
                if (capsuleStr.includes(entity.name)) {
                    diagram += "    " + capsule.name + "_" + capsule.flows[0].name + " --> DB\n";
                }
            }
        }
        
        diagram += "```\n";
    
    return diagram;
}
function GhostWriter_gen_sequence_diagram(self) {
    let diagram = "";
    
        diagram = "```mermaid\nsequenceDiagram\n";
        
        // Participants
        diagram += "    participant Client\n";
        
        for (const capsule of self.capsules) {
            diagram += "    participant " + capsule.name + "\n";
        }
        
        for (const entity of self.entities.filter(e => e.isEntity)) {
            diagram += "    participant " + entity.name + "DB as " + entity.name + " DB\n";
        }
        
        diagram += "\n";
        
        // Sequence for each flow
        for (const capsule of self.capsules) {
            for (const flow of capsule.flows) {
                const serverAttr = flow.attributes.find(a => 
                    a.name && a.name.startsWith('server.')
                );
                
                if (serverAttr) {
                    const method = serverAttr.name.split('.')[1].toUpperCase();
                    diagram += "    Client->>+" + capsule.name + ": " + method + " /" + flow.name + "\n";
                    
                    // Check for entity access
                    for (const entity of self.entities.filter(e => e.isEntity)) {
                        const flowStr = JSON.stringify(flow);
                        if (flowStr.includes(entity.name) || flow.return_type === entity.name) {
                            diagram += "    " + capsule.name + "->>+" + entity.name + "DB: Query\n";
                            diagram += "    " + entity.name + "DB-->>-" + capsule.name + ": Results\n";
                        }
                    }
                    
                    diagram += "    " + capsule.name + "-->>-Client: Response\n\n";
                }
            }
        }
        
        diagram += "```\n";
    
    return diagram;
}
function GhostWriter_gen_call_graph(self) {
    let diagram = "";
    
        diagram = "```mermaid\ngraph LR\n";
        
        // Function nodes
        for (const fn of self.functions) {
            diagram += "    " + fn.name + "[" + fn.name + "()]\n";
        }
        
        // Capsule flow nodes
        for (const capsule of self.capsules) {
            for (const flow of capsule.flows) {
                diagram += "    " + capsule.name + "_" + flow.name + "[" + capsule.name + "." + flow.name + "]\n";
            }
        }
        
        diagram += "\n";
        
        // Call edges
        for (const [caller, callees] of Object.entries(self.call_graph)) {
            for (const callee of callees) {
                if (callee) {
                    diagram += "    " + caller + " --> " + callee + "\n";
                }
            }
        }
        
        diagram += "```\n";
    
    return diagram;
}
function GhostWriter_generate_docs(self, project_name) {
    let doc = "";
    
        doc = "# " + project_name + " - Architecture Documentation\n\n";
        doc += "> Auto-generated by Omni Ghost Writer\n\n";
        doc += "---\n\n";
        
        // Overview
        doc += "## Overview\n\n";
        doc += "| Component | Count |\n";
        doc += "|-----------|-------|\n";
        doc += "| Capsules | " + self.capsules.length + " |\n";
        doc += "| Entities | " + self.entities.length + " |\n";
        doc += "| Functions | " + self.functions.length + " |\n";
        doc += "| Imports | " + self.imports.length + " |\n\n";
        
        // Class Diagram
        doc += "## Class Diagram\n\n";
        doc += GhostWriter_gen_class_diagram(self) + "\n";
        
        // Flowchart
        doc += "## System Flowchart\n\n";
        doc += GhostWriter_gen_flowchart(self) + "\n";
        
        // Sequence Diagram
        doc += "## Sequence Diagram\n\n";
        doc += GhostWriter_gen_sequence_diagram(self) + "\n";
        
        // Call Graph
        doc += "## Call Graph\n\n";
        doc += GhostWriter_gen_call_graph(self) + "\n";
        
        // API Reference
        doc += "## API Reference\n\n";
        
        for (const capsule of self.capsules) {
            doc += "### Capsule: " + capsule.name + "\n\n";
            
            for (const flow of capsule.flows) {
                const params = (flow.params || []).map(p => 
                    typeof p === 'string' ? p : (p.name + ': ' + (p.type || 'any'))
                ).join(', ');
                
                doc += "#### `" + flow.name + "(" + params + ") -> " + flow.return_type + "`\n\n";
                
                // Attributes
                for (const attr of flow.attributes) {
                    if (attr.name && attr.name.startsWith('server.')) {
                        const method = attr.name.split('.')[1].toUpperCase();
                        const path = attr.args && attr.args[0] ? attr.args[0] : '/' + flow.name;
                        doc += "- **Endpoint:** `" + method + " " + path + "`\n";
                    }
                }
                
                doc += "\n";
            }
        }
        
        // Entities
        doc += "## Data Entities\n\n";
        
        for (const entity of self.entities) {
            doc += "### " + (entity.isEntity ? "@entity " : "") + entity.name + "\n\n";
            doc += "| Field | Type |\n";
            doc += "|-------|------|\n";
            
            for (const field of entity.fields) {
                const name = field.name || field;
                const type = field.type || 'any';
                doc += "| " + name + " | " + type + " |\n";
            }
            
            doc += "\n";
        }
        
        doc += "---\n\n";
        doc += "*Generated by Omni Ghost Writer v1.0*\n";
    
    return doc;
}
function cmd_graph(input_file, output_file) {
    CLI_header("Omni Ghost Writer");
    CLI_info("Analyzing: " + input_file);
    let source = read_file(input_file);
    let l = new_lexer(source);
    let p = new_parser(l);
    let program = Parser_parse_program(p);
    let writer = GhostWriter_new();
    GhostWriter_analyze(writer, program);
    let project_name = "";
    
        project_name = path.basename(input_file, '.omni');
    
    let docs = GhostWriter_generate_docs(writer, project_name);
    write_file(output_file, docs);
    CLI_success("Documentation generated: " + output_file);
    
        console.log("");
        console.log(CLI_COLORS.bold + "Generated Diagrams:" + CLI_COLORS.reset);
        console.log("   Class Diagram");
        console.log("   System Flowchart");
        console.log("   Sequence Diagram");
        console.log("   Call Graph");
        console.log("");
        terminal.CLI_info("View the .md file in any Markdown viewer with Mermaid support");
    
}

    exports.GhostWriter = GhostWriter;
    exports.GhostWriter_new = GhostWriter_new;
    exports.GhostWriter_analyze = GhostWriter_analyze;
    exports.GhostWriter_gen_class_diagram = GhostWriter_gen_class_diagram;
    exports.GhostWriter_gen_flowchart = GhostWriter_gen_flowchart;
    exports.GhostWriter_gen_sequence_diagram = GhostWriter_gen_sequence_diagram;
    exports.GhostWriter_gen_call_graph = GhostWriter_gen_call_graph;
    exports.GhostWriter_generate_docs = GhostWriter_generate_docs;
    exports.cmd_graph = cmd_graph;


module.exports = { GhostWriter_new, GhostWriter_analyze, GhostWriter_gen_class_diagram, GhostWriter_gen_flowchart, GhostWriter_gen_sequence_diagram, GhostWriter_gen_call_graph, GhostWriter_generate_docs, cmd_graph };


function get_c_runtime_header() {
    let header = "";
    
        header = `
// ============================================================================
// OMNI RUNTIME - C Native Bootstrap
// ============================================================================

#ifndef OMNI_RUNTIME_H
#define OMNI_RUNTIME_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <time.h>

// ============================================================================
// MEMORY MANAGEMENT - Arena Allocator
// ============================================================================

#define ARENA_SIZE (1024 * 1024 * 16)  // 16MB default arena

typedef struct {
    char* buffer;
    size_t offset;
    size_t capacity;
} OmniArena;

static OmniArena* global_arena = NULL;

static void omni_arena_init() {
    if (global_arena) return;
    global_arena = (OmniArena*)malloc(sizeof(OmniArena));
    global_arena->buffer = (char*)malloc(ARENA_SIZE);
    global_arena->offset = 0;
    global_arena->capacity = ARENA_SIZE;
}

static void* omni_alloc(size_t size) {
    if (!global_arena) omni_arena_init();
    
    // Align to 8 bytes
    size = (size + 7) & ~7;
    
    if (global_arena->offset + size > global_arena->capacity) {
        fprintf(stderr, "[omni] Arena overflow! Requested %zu bytes\\n", size);
        exit(1);
    }
    
    void* ptr = global_arena->buffer + global_arena->offset;
    global_arena->offset += size;
    return ptr;
}

static void omni_arena_reset() {
    if (global_arena) {
        global_arena->offset = 0;
    }
}

static void omni_arena_destroy() {
    if (global_arena) {
        free(global_arena->buffer);
        free(global_arena);
        global_arena = NULL;
    }
}

// ============================================================================
// STRING TYPE
// ============================================================================

typedef struct {
    char* data;
    size_t len;
} OmniString;

static OmniString omni_string_new(const char* str) {
    OmniString s;
    s.len = strlen(str);
    s.data = (char*)omni_alloc(s.len + 1);
    strcpy(s.data, str);
    return s;
}

static OmniString omni_string_concat(OmniString a, OmniString b) {
    OmniString s;
    s.len = a.len + b.len;
    s.data = (char*)omni_alloc(s.len + 1);
    strcpy(s.data, a.data);
    strcat(s.data, b.data);
    return s;
}

#define STR(x) omni_string_new(x)
#define CONCAT(a, b) omni_string_concat(a, b)

// ============================================================================
// DYNAMIC ARRAY
// ============================================================================

typedef struct {
    void** items;
    size_t len;
    size_t capacity;
} OmniArray;

static OmniArray* omni_array_new() {
    OmniArray* arr = (OmniArray*)omni_alloc(sizeof(OmniArray));
    arr->capacity = 16;
    arr->len = 0;
    arr->items = (void**)omni_alloc(arr->capacity * sizeof(void*));
    return arr;
}

static void omni_array_push(OmniArray* arr, void* item) {
    if (arr->len >= arr->capacity) {
        arr->capacity *= 2;
        void** new_items = (void**)omni_alloc(arr->capacity * sizeof(void*));
        memcpy(new_items, arr->items, arr->len * sizeof(void*));
        arr->items = new_items;
    }
    arr->items[arr->len++] = item;
}

#define ARRAY_NEW() omni_array_new()
#define ARRAY_PUSH(arr, item) omni_array_push(arr, (void*)(item))
#define ARRAY_GET(arr, i, type) ((type)arr->items[i])
#define ARRAY_LEN(arr) (arr->len)

// ============================================================================
// STD.IO IMPLEMENTATION
// ============================================================================

#define print(msg) printf("%s", (msg).data)
#define println(msg) printf("%s\\n", (msg).data)

static OmniString omni_input(OmniString prompt) {
    printf("%s", prompt.data);
    char buffer[1024];
    if (fgets(buffer, sizeof(buffer), stdin)) {
        buffer[strcspn(buffer, "\\n")] = 0;
        return omni_string_new(buffer);
    }
    return omni_string_new("");
}

// ============================================================================
// STD.FS IMPLEMENTATION
// ============================================================================

static OmniString omni_read_file(OmniString path) {
    FILE* f = fopen(path.data, "rb");
    if (!f) return omni_string_new("");
    
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    char* buffer = (char*)omni_alloc(size + 1);
    fread(buffer, 1, size, f);
    buffer[size] = 0;
    fclose(f);
    
    OmniString s = { buffer, size };
    return s;
}

static void omni_write_file(OmniString path, OmniString content) {
    FILE* f = fopen(path.data, "wb");
    if (f) {
        fwrite(content.data, 1, content.len, f);
        fclose(f);
    }
}

static bool omni_file_exists(OmniString path) {
    FILE* f = fopen(path.data, "r");
    if (f) {
        fclose(f);
        return true;
    }
    return false;
}

// ============================================================================
// STD.TIME IMPLEMENTATION
// ============================================================================

static int64_t omni_time_now() {
    return (int64_t)(time(NULL) * 1000);
}

static void omni_sleep(int64_t ms) {
    #ifdef _WIN32
    Sleep(ms);
    #else
    usleep(ms * 1000);
    #endif
}

// ============================================================================
// STD.JSON IMPLEMENTATION (Simple)
// ============================================================================

// Minimal JSON - for full JSON use cJSON library
static OmniString omni_json_stringify_string(OmniString s) {
    size_t new_len = s.len + 3;
    char* buffer = (char*)omni_alloc(new_len);
    sprintf(buffer, "\\"%s\\"", s.data);
    return omni_string_new(buffer);
}

// ============================================================================
// TYPE ALIASES
// ============================================================================

typedef int64_t i64;
typedef int32_t i32;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
typedef uint8_t u8;
typedef double f64;
typedef float f32;

#endif // OMNI_RUNTIME_H
`;
    
    return header;
}
function cmd_bootstrap() {
    CLI_banner();
    CLI_header("Omni Bootstrap - Native Compilation");
    
        const { execSync } = require('child_process');
        
        const omniDir = path.join(__dirname, '..');
        const srcDir = path.join(omniDir, 'src');
        const distDir = path.join(omniDir, 'dist');
        const bootstrapDir = path.join(omniDir, 'bootstrap');
        
        // Create bootstrap directory
        if (!fs.existsSync(bootstrapDir)) {
            fs.mkdirSync(bootstrapDir, { recursive: true });
        }
        
        CLI_step(1, 5, "Generating C runtime header...");
        
        // Write runtime header
        const runtimeHeader = get_c_runtime_header();
        fs.writeFileSync(path.join(bootstrapDir, 'omni_runtime.h'), runtimeHeader);
        CLI_success("Created: bootstrap/omni_runtime.h");
        
        CLI_step(2, 5, "Compiling Omni sources to C...");
        
        // List of core source files (order matters)
        const sourceFiles = [
            'core/token.omni',
            'core/ast.omni',
            'core/lexer.omni',
            'core/parser.omni',
            'core/codegen_hybrid.omni',
            'core/vm.omni',
            'lib/std.omni',
            'lib/cli.omni',
            'main.omni'
        ];
        
        let combinedC = '#include "omni_runtime.h"\n\n';
        
        for (const file of sourceFiles) {
            const fullPath = path.join(srcDir, file);
            if (fs.existsSync(fullPath)) {
                CLI_info("Processing: " + file);
                // In real implementation, would compile each file to C
                // For now, create placeholder
                combinedC += '// === ' + file + ' ===\n';
                combinedC += '// TODO: Transpiled C code for ' + file + '\n\n';
            }
        }
        
        // Write combined C file
        fs.writeFileSync(path.join(bootstrapDir, 'omni.c'), combinedC);
        CLI_success("Created: bootstrap/omni.c");
        
        CLI_step(3, 5, "Checking for C compiler...");
        
        let compiler = null;
        const compilers = ['gcc', 'clang', 'cl'];
        
        for (const cc of compilers) {
            try {
                execSync(cc + ' --version', { stdio: 'ignore' });
                compiler = cc;
                CLI_success("Found: " + cc);
                break;
            } catch (e) {
                // Not found
            }
        }
        
        if (!compiler) {
            CLI_warning("No C compiler found (gcc, clang, cl)");
            CLI_info("Install GCC or Clang to compile native binary");
            console.log("");
            CLI_info("To compile manually:");
            console.log(CLI_COLORS.dim + "  gcc -O2 -o omni bootstrap/omni.c" + CLI_COLORS.reset);
            return;
        }
        
        CLI_step(4, 5, "Compiling native binary...");
        
        const isWindows = process.platform === 'win32';
        const outputName = isWindows ? 'omni.exe' : 'omni';
        const outputPath = path.join(bootstrapDir, outputName);
        
        try {
            // Note: This would fail without actual C code
            // const compileCmd = compiler + ' -O2 -o ' + outputPath + ' ' + 
            //                    path.join(bootstrapDir, 'omni.c');
            // execSync(compileCmd, { stdio: 'inherit' });
            
            CLI_info("Compilation command prepared:");
            console.log(CLI_COLORS.dim + "  " + compiler + " -O2 -o " + outputPath + " bootstrap/omni.c" + CLI_COLORS.reset);
            
        } catch (e) {
            CLI_error("Compilation failed: " + e.message);
            return;
        }
        
        CLI_step(5, 5, "Bootstrap complete!");
        
        console.log("");
        console.log("");
        console.log("                  BOOTSTRAP SUMMARY                          ");
        console.log("");
        console.log(" Runtime Header: bootstrap/omni_runtime.h                    ");
        console.log(" Generated C:    bootstrap/omni.c                            ");
        console.log(" Compiler:       " + (compiler || 'Not Found').padEnd(43) + "");
        console.log("");
        
        console.log("");
        CLI_info("To complete native compilation:");
        console.log("");
        console.log(CLI_COLORS.cyan + "  cd bootstrap" + CLI_COLORS.reset);
        console.log(CLI_COLORS.cyan + "  " + compiler + " -O2 -o omni omni.c" + CLI_COLORS.reset);
        console.log(CLI_COLORS.cyan + "  ./omni --version" + CLI_COLORS.reset);
        console.log("");
        
        CLI_success("Bootstrap files generated successfully!");
    
}

    exports.get_c_runtime_header = get_c_runtime_header;
    exports.cmd_bootstrap = cmd_bootstrap;


module.exports = { get_c_runtime_header, cmd_bootstrap };






class AppConfig {
    constructor(data = {}) {
        this.name = data.name;
        this.version = data.version;
        this.icon = data.icon;
        this.description = data.description;
        this.author = data.author;
        this.bundle_id = data.bundle_id;
    }
}
function AppConfig_default() {
    return new AppConfig({ name: "OmniApp", version: "1.0.0", icon: "", description: "Built with Omni", author: "Omni Developer", bundle_id: "org.omni.app" });
}
function detect_platform() {
    let platform = "unknown";
    
        platform = process.platform;
    
    return platform;
}
function detect_build_tools() {
    
        const { execSync } = require('child_process');
        
        let tools = {
            gcc: false,
            clang: false,
            cargo: false,
            android_sdk: false,
            xcode: false,
            wix: false
        };
        
        const check = (cmd) => {
            try {
                execSync(cmd + ' --version', { stdio: 'ignore' });
                return true;
            } catch (e) {
                return false;
            }
        };
        
        tools.gcc = check('gcc');
        tools.clang = check('clang');
        tools.cargo = check('cargo');
        
        // Check for Android SDK
        tools.android_sdk = !!process.env.ANDROID_HOME;
        
        // Check for Xcode (macOS only)
        if (process.platform === 'darwin') {
            tools.xcode = check('xcodebuild');
        }
        
        // Check for WiX (Windows installer)
        if (process.platform === 'win32') {
            tools.wix = check('candle');
        }

        return tools;
    
    return 0;
}
function generate_tauri_config(config, is_studio) {
    let json = "";
    
        const tauriConfig = {
            "build": {
                "distDir": is_studio ? "../studio/dist" : "../dist",
                "devPath": is_studio ? "http://localhost:3000" : "http://localhost:8080"
            },
            "package": {
                "productName": config.name,
                "version": config.version
            },
            "tauri": {
                "bundle": {
                    "active": true,
                    "icon": ["icons/32x32.png", "icons/128x128.png", "icons/icon.ico"],
                    "identifier": config.bundle_id,
                    "targets": ["msi", "appimage", "dmg"]
                },
                "windows": [{
                    "title": config.name,
                    "width": 1280,
                    "height": 800,
                    "minWidth": 800,
                    "minHeight": 600,
                    "resizable": true,
                    "fullscreen": false
                }],
                "allowlist": {
                    "shell": { "execute": true },
                    "fs": { "all": true },
                    "path": { "all": true },
                    "process": { "all": true },
                    "http": { "all": true }
                }
            }
        };
        
        json = JSON.stringify(tauriConfig, null, 2);
    
    return json;
}
function generate_capacitor_config(config) {
    let json = "";
    
        const capConfig = {
            "appId": config.bundle_id,
            "appName": config.name,
            "webDir": "dist",
            "server": {
                "androidScheme": "https"
            },
            "plugins": {
                "SplashScreen": {
                    "launchShowDuration": 2000,
                    "backgroundColor": "#0d1117"
                }
            }
        };
        
        json = JSON.stringify(capConfig, null, 2);
    
    return json;
}
function cmd_package_app(target, config) {
    CLI_banner();
    CLI_header("Omni App Packager");
    CLI_info("Target: " + target);
    CLI_info("App: " + config.name + " v" + config.version);
    let tools = detect_build_tools();
    let platform = detect_platform();
    
        const { execSync } = require('child_process');
        
        const omniDir = path.join(__dirname, '..');
        const buildDir = path.join(omniDir, 'build');
        const distDir = path.join(omniDir, 'dist', 'app');
        
        // Create build directories
        [buildDir, distDir].forEach(dir => {
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
        });
        
        // ================================================================
        // WINDOWS BUILD
        // ================================================================
        if (target === 'windows' || target === 'win32' || target === 'exe') {
            CLI_step(1, 4, "Generating Windows project...");
            
            // Create Tauri project structure
            const tauriDir = path.join(buildDir, 'tauri');
            if (!fs.existsSync(tauriDir)) {
                fs.mkdirSync(tauriDir, { recursive: true });
            }
            
            // Write tauri.conf.json
            const tauriConfig = generate_tauri_config(config, true);
            fs.writeFileSync(path.join(tauriDir, 'tauri.conf.json'), tauriConfig);
            CLI_success("Generated: build/tauri/tauri.conf.json");
            
            CLI_step(2, 4, "Copying Studio UI...");
            
            // Copy Studio files
            const studioDistDir = path.join(tauriDir, 'studio', 'dist');
            if (!fs.existsSync(studioDistDir)) {
                fs.mkdirSync(studioDistDir, { recursive: true });
            }
            
            // Generate minimal index.html that loads Studio
            const indexHtml = `<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>${config.name}</title></head>
<body>
<script>
    // Omni Studio loads here
    window.location.href = 'http://localhost:3000';
</script>
</body>
</html>`;
            fs.writeFileSync(path.join(studioDistDir, 'index.html'), indexHtml);
            
            CLI_step(3, 4, "Checking Tauri...");
            
            if (!tools.cargo) {
                CLI_warning("Rust/Cargo not found. Required for Tauri builds.");
                CLI_info("Install Rust: https://rustup.rs/");
                console.log("");
                CLI_info("Manual build steps:");
                console.log(CLI_COLORS.dim + "  cd build/tauri" + CLI_COLORS.reset);
                console.log(CLI_COLORS.dim + "  cargo tauri build" + CLI_COLORS.reset);
                return;
            }
            
            CLI_step(4, 4, "Building...");
            
            console.log("");
            console.log(CLI_COLORS.yellow + "  To complete the Windows build:" + CLI_COLORS.reset);
            console.log("");
            console.log(CLI_COLORS.cyan + "  cd build/tauri" + CLI_COLORS.reset);
            console.log(CLI_COLORS.cyan + "  cargo install tauri-cli" + CLI_COLORS.reset);
            console.log(CLI_COLORS.cyan + "  cargo tauri build" + CLI_COLORS.reset);
            console.log("");
            CLI_success("Windows project ready in build/tauri/");
            return;
        }
        
        // ================================================================
        // ANDROID BUILD
        // ================================================================
        if (target === 'android' || target === 'apk') {
            CLI_step(1, 5, "Generating Capacitor project...");
            
            const capDir = path.join(buildDir, 'capacitor');
            if (!fs.existsSync(capDir)) {
                fs.mkdirSync(capDir, { recursive: true });
            }
            
            // Write capacitor.config.json
            const capConfig = generate_capacitor_config(config);
            fs.writeFileSync(path.join(capDir, 'capacitor.config.json'), capConfig);
            CLI_success("Generated: build/capacitor/capacitor.config.json");
            
            // Create package.json
            const packageJson = {
                "name": config.bundle_id.replace(/\./g, '-'),
                "version": config.version,
                "scripts": {
                    "build": "echo 'Building...'",
                    "cap:add": "npx cap add android",
                    "cap:sync": "npx cap sync",
                    "cap:open": "npx cap open android"
                },
                "dependencies": {
                    "@capacitor/android": "^5.0.0",
                    "@capacitor/core": "^5.0.0",
                    "@capacitor/cli": "^5.0.0"
                }
            };
            fs.writeFileSync(path.join(capDir, 'package.json'), JSON.stringify(packageJson, null, 2));
            
            CLI_step(2, 5, "Creating dist folder...");
            
            const distFolder = path.join(capDir, 'dist');
            if (!fs.existsSync(distFolder)) {
                fs.mkdirSync(distFolder, { recursive: true });
            }
            
            // Create minimal index.html
            const indexHtml = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${config.name}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: system-ui, sans-serif;
            background: linear-gradient(135deg, #0d1117 0%, #161b22 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .container { text-align: center; padding: 20px; }
        h1 { font-size: 2rem; margin-bottom: 1rem; color: #58a6ff; }
        p { color: #8b949e; }
        .btn {
            display: inline-block;
            margin-top: 20px;
            padding: 12px 24px;
            background: #238636;
            color: white;
            border-radius: 8px;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1> ${config.name}</h1>
        <p>Built with Omni</p>
        <a href="#" class="btn" onclick="window.location.reload()">Start</a>
    </div>
</body>
</html>`;
            fs.writeFileSync(path.join(distFolder, 'index.html'), indexHtml);
            
            CLI_step(3, 5, "Checking Android SDK...");
            
            if (!tools.android_sdk) {
                CLI_warning("Android SDK not found (ANDROID_HOME not set)");
                CLI_info("Install Android Studio: https://developer.android.com/studio");
            }
            
            CLI_step(4, 5, "Generating build instructions...");
            
            console.log("");
            console.log(CLI_COLORS.yellow + "  To complete the Android build:" + CLI_COLORS.reset);
            console.log("");
            console.log(CLI_COLORS.cyan + "  cd build/capacitor" + CLI_COLORS.reset);
            console.log(CLI_COLORS.cyan + "  npm install" + CLI_COLORS.reset);
            console.log(CLI_COLORS.cyan + "  npx cap add android" + CLI_COLORS.reset);
            console.log(CLI_COLORS.cyan + "  npx cap sync" + CLI_COLORS.reset);
            console.log(CLI_COLORS.cyan + "  npx cap open android" + CLI_COLORS.reset);
            console.log("");
            
            CLI_step(5, 5, "Done!");
            CLI_success("Android project ready in build/capacitor/");
            return;
        }
        
        // ================================================================
        // LINUX BUILD
        // ================================================================
        if (target === 'linux' || target === 'appimage') {
            CLI_step(1, 3, "Generating Linux project...");
            
            const linuxDir = path.join(buildDir, 'linux');
            if (!fs.existsSync(linuxDir)) {
                fs.mkdirSync(linuxDir, { recursive: true });
            }
            
            // Write desktop file
            const desktopEntry = `[Desktop Entry]
Name=${config.name}
Comment=${config.description}
Exec=omni
Icon=omni
Type=Application
Categories=Development;IDE;
`;
            fs.writeFileSync(path.join(linuxDir, config.name + '.desktop'), desktopEntry);
            
            // Write AppImage recipe
            const appImageYml = `app: ${config.name}
ingredients:
  dist: omni-installer
  script:
    - echo "Building Omni AppImage"

script:
  - mkdir -p AppDir/usr/bin
  - cp omni AppDir/usr/bin/
  - cp -r studio AppDir/usr/share/omni/
`;
            fs.writeFileSync(path.join(linuxDir, 'AppImageBuilder.yml'), appImageYml);
            
            CLI_step(2, 3, "Generated Linux files");
            CLI_step(3, 3, "Done!");
            
            console.log("");
            CLI_info("To build AppImage:");
            console.log(CLI_COLORS.dim + "  cd build/linux" + CLI_COLORS.reset);
            console.log(CLI_COLORS.dim + "  appimage-builder --recipe AppImageBuilder.yml" + CLI_COLORS.reset);
            
            CLI_success("Linux project ready in build/linux/");
            return;
        }
        
        // Unknown target
        CLI_error("Unknown target: " + target);
        CLI_info("Available targets: windows, android, linux");
    
}

module.exports = { AppConfig_default, detect_platform, detect_build_tools, generate_tauri_config, generate_capacitor_config, cmd_package_app };


class TUIState {
    constructor(data = {}) {
        this.screen = data.screen;
        this.cursor = data.cursor;
        this.items = data.items;
        this.selected = data.selected;
        this.message = data.message;
        this.running = data.running;
    }
}
function TUIState_new() {
    return new TUIState({ screen: "main", cursor: 0, items: [], selected: [], message: "", running: true });
}
function tui_enable_raw_mode() {
    
        if (process.stdin.isTTY) {
            process.stdin.setRawMode(true);
        }
        process.stdin.resume();
        process.stdin.setEncoding('utf8');
    
}
function tui_disable_raw_mode() {
    
        if (process.stdin.isTTY) {
            process.stdin.setRawMode(false);
        }
    
}
function tui_clear_screen() {
    
        console.clear();
        process.stdout.write('\x1B[2J\x1B[0f');
    
}
function tui_move_cursor(row, col) {
    
        process.stdout.write(`\x1B[${row};${col}H`);
    
}
function tui_hide_cursor() {
    
        process.stdout.write('\x1B[?25l');
    
}
function tui_show_cursor() {
    
        process.stdout.write('\x1B[?25h');
    
}
function tui_render_header(title, subtitle) {
    
        const width = process.stdout.columns || 80;
        const line = ''.repeat(width - 2);
        
        console.log(CLI_COLORS.cyan + '' + line + '' + CLI_COLORS.reset);
        console.log(CLI_COLORS.cyan + '' + CLI_COLORS.reset + 
                    CLI_COLORS.bold + '  OMNI ' + title.padEnd(width - 12) + 
                    CLI_COLORS.reset + CLI_COLORS.cyan + '' + CLI_COLORS.reset);
        console.log(CLI_COLORS.cyan + '' + CLI_COLORS.reset + 
                    CLI_COLORS.dim + '   ' + subtitle.padEnd(width - 6) + 
                    CLI_COLORS.reset + CLI_COLORS.cyan + '' + CLI_COLORS.reset);
        console.log(CLI_COLORS.cyan + '' + line + '' + CLI_COLORS.reset);
    
}
function tui_render_menu(state) {
    
        for (let i = 0; i < state.items.length; i++) {
            const item = state.items[i];
            const selected = i === state.cursor;
            const prefix = selected ? CLI_COLORS.cyan + '  ' : '   ';
            const suffix = CLI_COLORS.reset;
            
            if (selected) {
                console.log(prefix + CLI_COLORS.bold + item.label + suffix);
            } else {
                console.log(prefix + CLI_COLORS.dim + item.label + suffix);
            }
        }
    
}
function tui_render_footer(state) {
    
        const width = process.stdout.columns || 80;
        const line = ''.repeat(width - 2);
        
        console.log('');
        console.log(CLI_COLORS.dim + '' + line + '' + CLI_COLORS.reset);
        
        if (state.message) {
            console.log(CLI_COLORS.dim + ' ' + CLI_COLORS.reset + 
                        state.message.padEnd(width - 4) + 
                        CLI_COLORS.dim + ' ' + CLI_COLORS.reset);
        }
        
        console.log(CLI_COLORS.dim + ' / Navigate   Enter Select   q Quit' + 
                    ''.padEnd(width - 42) + ' ' + CLI_COLORS.reset);
        console.log(CLI_COLORS.dim + '' + line + '' + CLI_COLORS.reset);
    
}
function tui_render_file_list(state) {
    
        console.log('');
        console.log(CLI_COLORS.cyan + '  Select files to convert:' + CLI_COLORS.reset);
        console.log('');
        
        for (let i = 0; i < state.items.length; i++) {
            const item = state.items[i];
            const isSelected = state.selected.includes(i);
            const isCursor = i === state.cursor;
            
            const checkbox = isSelected ? CLI_COLORS.green + '[]' : CLI_COLORS.dim + '[ ]';
            const prefix = isCursor ? CLI_COLORS.cyan + '  ' : '   ';
            
            console.log(prefix + checkbox + CLI_COLORS.reset + ' ' + 
                        (isCursor ? CLI_COLORS.bold : CLI_COLORS.dim) + 
                        item.name + CLI_COLORS.reset);
        }
    
}
function tui_render_target_select(state) {
    
        console.log('');
        console.log(CLI_COLORS.cyan + '  Select target language:' + CLI_COLORS.reset);
        console.log('');
        
        for (let i = 0; i < state.items.length; i++) {
            const item = state.items[i];
            const isCursor = i === state.cursor;
            
            const prefix = isCursor ? CLI_COLORS.cyan + '  ' : '   ';
            const icon = item.icon || '';
            
            console.log(prefix + icon + ' ' + 
                        (isCursor ? CLI_COLORS.bold : '') + 
                        item.label + CLI_COLORS.reset);
            
            if (isCursor && item.description) {
                console.log('      ' + CLI_COLORS.dim + item.description + CLI_COLORS.reset);
            }
        }
    
}
function tui_main_menu() {
    return [null, id, null, "convert", label, null, " Convert Legacy Code", description, null, "Transform PHP, Java, Python to Omni", null, null, id, null, "install", label, null, " Install Package", description, null, "Install from GitHub", null, null, id, null, "studio", label, null, " Open Studio", description, null, "Visual programming environment", null, null, id, null, "build", label, null, " Build Project", description, null, "Compile current project", null, null, id, null, "run", label, null, "  Run Project", description, null, "Execute main file", null, null, id, null, "doctor", label, null, " System Doctor", description, null, "Check installation health", null, null, id, null, "quit", label, null, " Quit", description, null, "", null];
}
function tui_target_menu() {
    return [null, id, null, "js", label, null, "JavaScript (Node.js)", icon, null, "", description, null, "CommonJS module", null, null, id, null, "python", label, null, "Python 3", icon, null, "", description, null, "Python 3.8+ compatible", null, null, id, null, "c", label, null, "C Native", icon, null, "", description, null, "Portable C99 code", null, null, id, null, "lua", label, null, "Lua 5.4", icon, null, "", description, null, "Lua script", null, null, id, null, "wasm", label, null, "WebAssembly", icon, null, "", description, null, "WASM binary", null, null, id, null, "back", label, null, " Back", icon, null, "", description, null, "", null];
}
function tui_scan_legacy_files(dir) {
    let files = [];
    
        
        const extensions = ['.php', '.java', '.py', '.js', '.ts'];
        
        const scan = (d) => {
            try {
                const entries = fs.readdirSync(d, { withFileTypes: true });
                for (const entry of entries) {
                    if (entry.name.startsWith('.') || entry.name === 'node_modules') continue;
                    
                    const fullPath = path.join(d, entry.name);
                    
                    if (entry.isDirectory()) {
                        scan(fullPath);
                    } else if (extensions.some(ext => entry.name.endsWith(ext))) {
                        files.push({
                            name: path.relative(dir, fullPath),
                            path: fullPath,
                            ext: path.extname(entry.name)
                        });
                    }
                }
            } catch (e) {
                // Skip inaccessible directories
            }
        };
        
        scan(dir);
    
    return files;
}
function cmd_tui() {
    let state = TUIState_new();
    
        state.items = tui_main_menu();
    
    tui_enable_raw_mode();
    tui_hide_cursor();
    
        
        const render = () => {
            tui_clear_screen();
            tui_render_header('INTERACTIVE', 'v1.1.0 - Use arrow keys to navigate');
            
            if (state.screen === 'main') {
                tui_render_menu(state);
            } else if (state.screen === 'files') {
                tui_render_file_list(state);
            } else if (state.screen === 'targets') {
                tui_render_target_select(state);
            }
            
            tui_render_footer(state);
        };
        
        const handleAction = (action) => {
            if (action === 'convert') {
                state.screen = 'files';
                state.items = tui_scan_legacy_files(process.cwd());
                state.cursor = 0;
                state.selected = [];
                state.message = 'Space to select, Enter to continue';
            } else if (action === 'install') {
                state.message = 'Use: omni install github:user/repo';
                setTimeout(() => { state.message = ''; render(); }, 2000);
            } else if (action === 'studio') {
                tui_show_cursor();
                tui_disable_raw_mode();
                console.log('\nStarting Omni Studio...');
                require('child_process').execSync('node dist/main.js studio', { stdio: 'inherit' });
                process.exit(0);
            } else if (action === 'build') {
                tui_show_cursor();
                tui_disable_raw_mode();
                console.log('\nBuilding project...');
                require('child_process').execSync('node dist/main.js build', { stdio: 'inherit' });
                process.exit(0);
            } else if (action === 'run') {
                tui_show_cursor();
                tui_disable_raw_mode();
                console.log('\nRunning project...');
                require('child_process').execSync('node dist/main.js run main.omni', { stdio: 'inherit' });
                process.exit(0);
            } else if (action === 'doctor') {
                tui_show_cursor();
                tui_disable_raw_mode();
                cmd_doctor();
                process.exit(0);
            } else if (action === 'quit') {
                state.running = false;
            } else if (action === 'select_target') {
                state.screen = 'targets';
                state.items = tui_target_menu();
                state.cursor = 0;
                state.message = 'Select output target';
            } else if (action === 'back') {
                state.screen = 'main';
                state.items = tui_main_menu();
                state.cursor = 0;
            } else if (action.startsWith('target:')) {
                const target = action.split(':')[1];
                tui_show_cursor();
                tui_disable_raw_mode();
                console.log('\nConverting ' + state.selected.length + ' files to ' + target + '...');
                // Here would call ingest for each selected file
                process.exit(0);
            }
        };
        
        process.stdin.on('data', (key) => {
            // Handle key presses
            if (key === '\u001B[A') { // Up arrow
                state.cursor = Math.max(0, state.cursor - 1);
            } else if (key === '\u001B[B') { // Down arrow
                state.cursor = Math.min(state.items.length - 1, state.cursor + 1);
            } else if (key === ' ' && state.screen === 'files') { // Space - toggle select
                const idx = state.selected.indexOf(state.cursor);
                if (idx >= 0) {
                    state.selected.splice(idx, 1);
                } else {
                    state.selected.push(state.cursor);
                }
            } else if (key === '\r' || key === '\n') { // Enter
                const item = state.items[state.cursor];
                if (state.screen === 'main') {
                    handleAction(item.id);
                } else if (state.screen === 'files') {
                    if (state.selected.length > 0) {
                        handleAction('select_target');
                    } else {
                        state.message = 'Select at least one file';
                    }
                } else if (state.screen === 'targets') {
                    if (item.id === 'back') {
                        handleAction('back');
                    } else {
                        handleAction('target:' + item.id);
                    }
                }
            } else if (key === 'q' || key === '\u0003') { // q or Ctrl+C
                state.running = false;
            } else if (key === '\u001B' || key === 'b') { // Escape or b - back
                if (state.screen !== 'main') {
                    handleAction('back');
                }
            }
            
            if (state.running) {
                render();
            } else {
                tui_show_cursor();
                tui_disable_raw_mode();
                console.log('\nGoodbye! ');
                process.exit(0);
            }
        });
        
        // Initial render
        render();
    
}
function tui_quick_convert(files, target) {
    
        console.log(CLI_COLORS.cyan + ' Quick Convert' + CLI_COLORS.reset);
        console.log('');
        
        for (const file of files) {
            console.log(CLI_COLORS.dim + '  Converting: ' + file + CLI_COLORS.reset);
            // Would call ingest here
        }
        
        CLI_success('Conversion complete!');
    
}

module.exports = { TUIState_new, tui_enable_raw_mode, tui_disable_raw_mode, tui_clear_screen, tui_move_cursor, tui_hide_cursor, tui_show_cursor, tui_render_header, tui_render_menu, tui_render_footer, tui_render_file_list, tui_render_target_select, tui_main_menu, tui_target_menu, tui_scan_legacy_files, cmd_tui, tui_quick_convert };


function print(msg) {
     console.log(msg); 
    
}
function read_file(path) {
    let content = "";
    
        try {
            content = fs.readFileSync(path, "utf8");
        } catch (e) {
            console.error("Error reading file " + path + ": " + e.message);
            process.exit(1);
        }
    
    
    return content;
}
function write_file(path, content) {
    
        try {
            fs.writeFileSync(path, content);
        } catch (e) {
            console.error("Error writing file " + path + ": " + e.message);
            process.exit(1);
        }
    
    
}

module.exports = { print, read_file, write_file };


class Colors {
    constructor(data = {}) {
        this.reset = data.reset;
        this.bold = data.bold;
        this.dim = data.dim;
        this.underline = data.underline;
        this.black = data.black;
        this.red = data.red;
        this.green = data.green;
        this.yellow = data.yellow;
        this.blue = data.blue;
        this.magenta = data.magenta;
        this.cyan = data.cyan;
        this.white = data.white;
        this.bg_black = data.bg_black;
        this.bg_red = data.bg_red;
        this.bg_green = data.bg_green;
        this.bg_yellow = data.bg_yellow;
        this.bg_blue = data.bg_blue;
        this.bg_magenta = data.bg_magenta;
        this.bg_cyan = data.bg_cyan;
        this.bg_white = data.bg_white;
    }
}
function Colors_new() {
    let c = new Colors({ reset: "", bold: "", dim: "", underline: "", black: "", red: "", green: "", yellow: "", blue: "", magenta: "", cyan: "", white: "", bg_black: "", bg_red: "", bg_green: "", bg_yellow: "", bg_blue: "", bg_magenta: "", bg_cyan: "", bg_white: "" });
    
        // Check if terminal supports colors
        const supportsColor = process.stdout.isTTY && 
            (process.env.TERM !== 'dumb') && 
            !process.env.NO_COLOR;
        
        if (supportsColor) {
            c.reset = '\x1b[0m';
            c.bold = '\x1b[1m';
            c.dim = '\x1b[2m';
            c.underline = '\x1b[4m';
            
            c.black = '\x1b[30m';
            c.red = '\x1b[31m';
            c.green = '\x1b[32m';
            c.yellow = '\x1b[33m';
            c.blue = '\x1b[34m';
            c.magenta = '\x1b[35m';
            c.cyan = '\x1b[36m';
            c.white = '\x1b[37m';
            
            c.bg_black = '\x1b[40m';
            c.bg_red = '\x1b[41m';
            c.bg_green = '\x1b[42m';
            c.bg_yellow = '\x1b[43m';
            c.bg_blue = '\x1b[44m';
            c.bg_magenta = '\x1b[45m';
            c.bg_cyan = '\x1b[46m';
            c.bg_white = '\x1b[47m';
        }
    
    return c;
}
let CLI_COLORS_INIT = false;
let CLI_COLORS_CACHE = new Colors({ reset: "", bold: "", dim: "", underline: "", black: "", red: "", green: "", yellow: "", blue: "", magenta: "", cyan: "", white: "", bg_black: "", bg_red: "", bg_green: "", bg_yellow: "", bg_blue: "", bg_magenta: "", bg_cyan: "", bg_white: "" });
function CLI_COLORS() {
    if (CLI_COLORS_INIT == false) {
    CLI_COLORS_CACHE = Colors_new();
    CLI_COLORS_INIT = true;
}
    return CLI_COLORS_CACHE;
}
function CLI_success(msg) {
    
        const c = CLI_COLORS();
        console.log(c.green + '' + c.reset + ' ' + msg);
    
}
function CLI_error(msg) {
    
        const c = CLI_COLORS();
        console.error(c.red + '' + c.reset + ' ' + msg);
    
}
function CLI_warning(msg) {
    
        const c = CLI_COLORS();
        console.log(c.yellow + '' + c.reset + ' ' + msg);
    
}
function CLI_info(msg) {
    
        const c = CLI_COLORS();
        console.log(c.blue + '' + c.reset + ' ' + msg);
    
}
function CLI_step(step, total, msg) {
    
        const c = CLI_COLORS();
        const prefix = c.cyan + '[' + step + '/' + total + ']' + c.reset;
        console.log(prefix + ' ' + msg);
    
}
function CLI_header(title) {
    
        const c = CLI_COLORS();
        console.log('');
        console.log(c.bold + c.cyan + ' ' + title + ' ' + c.reset);
        console.log('');
    
}
function CLI_dim(msg) {
    let result = "";
    
        const c = CLI_COLORS();
        result = c.dim + msg + c.reset;
    
    return result;
}
function CLI_bold(msg) {
    let result = "";
    
        const c = CLI_COLORS();
        result = c.bold + msg + c.reset;
    
    return result;
}
function CLI_green(msg) {
    let result = "";
    
        const c = CLI_COLORS();
        result = c.green + msg + c.reset;
    
    return result;
}
function CLI_red(msg) {
    let result = "";
    
        const c = CLI_COLORS();
        result = c.red + msg + c.reset;
    
    return result;
}
function CLI_yellow(msg) {
    let result = "";
    
        const c = CLI_COLORS();
        result = c.yellow + msg + c.reset;
    
    return result;
}
function CLI_cyan(msg) {
    let result = "";
    
        const c = CLI_COLORS();
        result = c.cyan + msg + c.reset;
    
    return result;
}
class Spinner {
    constructor(data = {}) {
        this.frames = data.frames;
        this.current = data.current;
        this.interval = data.interval;
        this.message = data.message;
        this.running = data.running;
    }
}
function Spinner_new(message) {
    let spinner = new Spinner({ frames: "", current: 0, interval: 0, message: message, running: false });
    return spinner;
}
function Spinner_start(self) {
    
        if (self.running) return;
        self.running = true;
        const frames = self.frames.split('');
        const c = CLI_COLORS();
        
        self.interval = setInterval(() => {
            process.stdout.write('\r' + c.cyan + 
                frames[self.current % frames.length] + c.reset + 
                ' ' + self.message);
            self.current = (self.current + 1) % frames.length;
        }, 80);
    
}
function Spinner_stop(self, success) {
    
        if (!self.running) return;
        
        clearInterval(self.interval);
        self.running = false;
        const c = CLI_COLORS();
        
        const icon = success 
            ? c.green + '' + c.reset 
            : c.red + '' + c.reset;
        
        process.stdout.write('\r' + icon + ' ' + self.message + '\n');
    
}
function CLI_progress_bar(current, total, width) {
    let result = "";
    
        const c = CLI_COLORS();
        const percent = Math.floor((current / total) * 100);
        const filled = Math.floor((current / total) * width);
        const empty = width - filled;
        
        const bar = c.green + ''.repeat(filled) + 
                    c.dim + ''.repeat(empty) + c.reset;
        
        result = bar + ' ' + percent + '%';
    
    return result;
}
class ParsedArgs {
    constructor(data = {}) {
        this.command = data.command;
        this.arg1 = data.arg1;
        this.arg2 = data.arg2;
        this.arg3 = data.arg3;
        this.flag_help = data.flag_help;
        this.flag_version = data.flag_version;
        this.flag_verbose = data.flag_verbose;
        this.flag_global = data.flag_global;
        this.flag_app = data.flag_app;
        this.flag_tui = data.flag_tui;
        this.opt_target = data.opt_target;
        this.opt_port = data.opt_port;
        this.opt_framework = data.opt_framework;
    }
}
function ParsedArgs_new() {
    let args = new ParsedArgs({ command: "", arg1: "", arg2: "", arg3: "", flag_help: false, flag_version: false, flag_verbose: false, flag_global: false, flag_app: false, flag_tui: false, opt_target: "js", opt_port: "3000", opt_framework: "" });
    
        const argv = process.argv.slice(2);
        
        let positional = [];
        for (let i = 0; i < argv.length; i++) {
            const arg = argv[i];
            
            if (arg === '--help' || arg === '-h') {
                args.flag_help = true;
            } else if (arg === '--version' || arg === '-v') {
                args.flag_version = true;
            } else if (arg === '--verbose' || arg === '-V') {
                args.flag_verbose = true;
            } else if (arg === '--global' || arg === '-g') {
                args.flag_global = true;
            } else if (arg === '--app') {
                args.flag_app = true;
            } else if (arg === '--tui') {
                args.flag_tui = true;
            } else if (arg === '--target' && argv[i + 1]) {
                args.opt_target = argv[++i];
            } else if (arg === '--port' && argv[i + 1]) {
                args.opt_port = argv[++i];
            } else if (arg === '--framework' && argv[i + 1]) {
                args.opt_framework = argv[++i];
            } else if (!arg.startsWith('-')) {
                positional.push(arg);
            }
        }
        
        args.command = positional[0] || '';
        args.arg1 = positional[1] || '';
        args.arg2 = positional[2] || '';
        args.arg3 = positional[3] || '';
    
    return args;
}
function CLI_table_simple(col1, col2) {
    
        const c = CLI_COLORS();
        console.log('  ' + c.cyan + col1.padEnd(20) + c.reset + col2);
    
}
function CLI_table_header(title) {
    
        const c = CLI_COLORS();
        console.log('');
        console.log(c.bold + title + c.reset);
        console.log(''.repeat(50));
    
}
function CLI_banner() {
    
        const c = CLI_COLORS();
        console.log('');
        console.log(c.cyan + c.bold + '   ____  __  __ _   _ ___ ' + c.reset);
        console.log(c.cyan + '  / __ \\|  \\/  | \\ | |_ _|' + c.reset);
        console.log(c.cyan + ' | |  | | |\\/| |  \\| || | ' + c.reset);
        console.log(c.cyan + ' | |__| | |  | | |\\  || | ' + c.reset);
        console.log(c.cyan + '  \\____/|_|  |_|_| \\_|___|' + c.reset);
        console.log('');
        console.log(c.dim + '  Hybrid Metamorphosis Compiler' + c.reset);
        console.log('');
    
}
function CLI_version() {
    return "1.2.0";
}

module.exports = { Colors_new, CLI_COLORS, CLI_success, CLI_error, CLI_warning, CLI_info, CLI_step, CLI_header, CLI_dim, CLI_bold, CLI_green, CLI_red, CLI_yellow, CLI_cyan, Spinner_new, Spinner_start, Spinner_stop, CLI_progress_bar, ParsedArgs_new, CLI_table_simple, CLI_table_header, CLI_banner, CLI_version };


function get_omni_home() {
    let home = "";
    
        
        // Priority 1: OMNI_HOME environment variable
        if (process.env.OMNI_HOME) {
            home = process.env.OMNI_HOME;
        }
        // Priority 2: Executable directory
        else if (__dirname) {
            home = path.dirname(__dirname);
        }
        // Priority 3: Users home directory
        else {
            const platform = os.platform();
            if (platform === 'win32') {
                home = path.join(os.homedir(), 'AppData', 'Local', 'Omni');
            } else {
                home = path.join(os.homedir(), '.local', 'share', 'omni');
            }
        }
    
    return home;
}
function resolve_resource_path(name) {
    let resolved = "";
    
        
        // Strategy 1: Local project path (./targets/, ./packages/, ./patterns/)
        const localPath = path.join(process.cwd(), name);
        if (fs.existsSync(localPath)) {
            resolved = localPath;
            return;
        }
        
        // Strategy 2: Relative to executable (dist/../)
        const execPath = path.join(__dirname, '..', name);
        if (fs.existsSync(execPath)) {
            resolved = execPath;
            return;
        }
        
        // Strategy 3: OMNI_HOME
        const omniHome = get_omni_home();
        const homePath = path.join(omniHome, name);
        if (fs.existsSync(homePath)) {
            resolved = homePath;
            return;
        }
        
        // Strategy 4: Global installation
        const platform = os.platform();
        let globalPath;
        
        if (platform === 'win32') {
            globalPath = path.join(os.homedir(), 'AppData', 'Local', 'Omni', name);
        } else {
            globalPath = path.join(os.homedir(), '.local', 'share', 'omni', name);
        }
        
        if (fs.existsSync(globalPath)) {
            resolved = globalPath;
            return;
        }
        
        // Not found - return local path for error messages
        resolved = localPath;
    
    return resolved;
}
function cmd_setup(is_global) {
    CLI_banner();
    CLI_header("Omni Setup");
    
        const { execSync } = require('child_process');
        
        const platform = os.platform();
        const isWindows = platform === 'win32';
        const omniDir = path.dirname(path.dirname(__filename));
        
        terminal.CLI_info("Platform: " + platform + " (" + os.arch() + ")");
        terminal.CLI_info("Omni directory: " + omniDir);
        terminal.CLI_info("Mode: " + (is_global ? "GLOBAL" : "LOCAL"));
        
        console.log("");
        
        if (is_global) {
            // ============================================================
            // GLOBAL INSTALLATION
            // ============================================================
            terminal.CLI_step(1, 4, "Detecting global installation path...");
            
            let globalDir;
            if (isWindows) {
                // Windows: Use %AppData%\Omni
                globalDir = path.join(os.homedir(), 'AppData', 'Local', 'Omni');
            } else {
                // Unix: Use ~/.local/bin or /usr/local/bin
                globalDir = path.join(os.homedir(), '.local', 'share', 'omni');
            }
            
            CLI_info("Global directory: " + globalDir);
            
            CLI_step(2, 4, "Copying Omni files...");
            
            // Ensure directory exists
            if (!fs.existsSync(globalDir)) {
                fs.mkdirSync(globalDir, { recursive: true });
            }
            
            // Copy dist folder
            const srcDist = path.join(omniDir, 'dist');
            const dstDist = path.join(globalDir, 'dist');
            
            if (fs.existsSync(srcDist)) {
                if (!fs.existsSync(dstDist)) {
                    fs.mkdirSync(dstDist, { recursive: true });
                }
                
                const files = fs.readdirSync(srcDist);
                for (const file of files) {
                    fs.copyFileSync(
                        path.join(srcDist, file),
                        path.join(dstDist, file)
                    );
                }
                CLI_success("Copied " + files.length + " files");
            }
            
            // Copy lib folder
            const srcLib = path.join(omniDir, 'src', 'lib');
            const dstLib = path.join(globalDir, 'lib');
            
            if (fs.existsSync(srcLib)) {
                if (!fs.existsSync(dstLib)) {
                    fs.mkdirSync(dstLib, { recursive: true });
                }
                
                const walkAndCopy = (src, dst) => {
                    const entries = fs.readdirSync(src, { withFileTypes: true });
                    for (const entry of entries) {
                        const srcPath = path.join(src, entry.name);
                        const dstPath = path.join(dst, entry.name);
                        if (entry.isDirectory()) {
                            if (!fs.existsSync(dstPath)) fs.mkdirSync(dstPath);
                            walkAndCopy(srcPath, dstPath);
                        } else {
                            fs.copyFileSync(srcPath, dstPath);
                        }
                    }
                };
                walkAndCopy(srcLib, dstLib);
                CLI_success("Copied standard library");
            }
            
            CLI_step(3, 4, "Creating executable wrapper...");
            
            if (isWindows) {
                // Windows: Create batch and PowerShell wrappers
                const cmdContent = `@echo off
node "%~dp0dist\\main.js" %*`;
                fs.writeFileSync(path.join(globalDir, 'omni.cmd'), cmdContent);
                
                const ps1Content = `#!/usr/bin/env pwsh
node "$PSScriptRoot\\dist\\main.js" @args`;
                fs.writeFileSync(path.join(globalDir, 'omni.ps1'), ps1Content);
                
                CLI_success("Created omni.cmd and omni.ps1");
            } else {
                // Unix: Create shell script
                const shContent = `#!/usr/bin/env bash
OMNI_DIR="$( cd "$( dirname "\${BASH_SOURCE[0]}" )" && pwd )"
node "$OMNI_DIR/dist/main.js" "$@"`;
                const shPath = path.join(globalDir, 'omni');
                fs.writeFileSync(shPath, shContent);
                fs.chmodSync(shPath, '755');
                
                CLI_success("Created omni executable");
            }
            
            CLI_step(4, 4, "Configuring PATH...");
            
            let binDir;
            if (isWindows) {
                binDir = globalDir;
                
                // Try to add to user PATH
                try {
                    const currentPath = execSync('echo %PATH%', { encoding: 'utf-8' }).trim();
                    if (!currentPath.includes(globalDir)) {
                        console.log("");
                        CLI_warning("Add this directory to your PATH:");
                        console.log(CLI_COLORS.cyan + "  " + globalDir + CLI_COLORS.reset);
                        console.log("");
                        console.log(CLI_COLORS.dim + "  PowerShell (admin):" + CLI_COLORS.reset);
                        console.log(CLI_COLORS.dim + "  [Environment]::SetEnvironmentVariable('Path', $env:Path + ';' + '" + globalDir + "', 'User')" + CLI_COLORS.reset);
                    } else {
                        CLI_success("Already in PATH");
                    }
                } catch (e) {}
            } else {
                binDir = path.join(os.homedir(), '.local', 'bin');
                
                // Create symlink in ~/.local/bin
                if (!fs.existsSync(binDir)) {
                    fs.mkdirSync(binDir, { recursive: true });
                }
                
                const linkPath = path.join(binDir, 'omni');
                try {
                    if (fs.existsSync(linkPath)) fs.unlinkSync(linkPath);
                    fs.symlinkSync(path.join(globalDir, 'omni'), linkPath);
                    CLI_success("Linked: " + linkPath);
                } catch (e) {
                    CLI_warning("Could not create symlink: " + e.message);
                }
                
                // Check if ~/.local/bin is in PATH
                const shellPath = process.env.PATH || '';
                if (!shellPath.includes(binDir)) {
                    console.log("");
                    CLI_warning("Add to your shell profile (~/.bashrc or ~/.zshrc):");
                    console.log(CLI_COLORS.cyan + '  export PATH="$HOME/.local/bin:$PATH"' + CLI_COLORS.reset);
                }
            }
            
            console.log("");
            CLI_success("Global installation complete!");
            console.log("");
            console.log(CLI_COLORS.green + "  Try: omni --version" + CLI_COLORS.reset);
            
        } else {
            // ============================================================
            // LOCAL INSTALLATION (./omni in current project)
            // ============================================================
            CLI_step(1, 2, "Creating local wrapper...");
            
            const cwd = process.cwd();
            
            if (isWindows) {
                const cmdContent = `@echo off
node "${path.join(omniDir, 'dist', 'main.js')}" %*`;
                fs.writeFileSync(path.join(cwd, 'omni.cmd'), cmdContent);
                CLI_success("Created: omni.cmd");
            } else {
                const shContent = `#!/usr/bin/env bash
node "${path.join(omniDir, 'dist', 'main.js')}" "$@"`;
                const shPath = path.join(cwd, 'omni');
                fs.writeFileSync(shPath, shContent);
                fs.chmodSync(shPath, '755');
                CLI_success("Created: ./omni");
            }
            
            CLI_step(2, 2, "Done!");
            
            console.log("");
            CLI_success("Local installation complete!");
            console.log("");
            if (isWindows) {
                console.log(CLI_COLORS.green + "  Try: .\\omni.cmd --version" + CLI_COLORS.reset);
            } else {
                console.log(CLI_COLORS.green + "  Try: ./omni --version" + CLI_COLORS.reset);
            }
        }
    
}

module.exports = { get_omni_home, resolve_resource_path, cmd_setup };


function cmd_run() {
    let run_file = "";
     
        run_file = process.argv[3] || '';
    
    if (run_file == "") {
    CLI_error("Usage: omni run <file.omni> [--cmd|--app|--web|--web-app] [--port N]");
    CLI_info("Modes:");
    CLI_info("  --cmd      Terminal execution (default)");
    CLI_info("  --app      Native desktop app (Python/Tkinter)");
    CLI_info("  --web      Web server on port (default: 3000)");
    CLI_info("  --web-app  Web in native browser window");
    return true;
}
    let source = read_file(run_file);
    if (source == "") {
    CLI_error("Could not read file: " + run_file);
    return false;
}
    let l = new_lexer(source);
    let p = new_parser(l);
    let program = Parser_parse_program(p);
    
        const { spawnSync, exec } = require('child_process');
        
        let mode = "cmd";
        let target = "js";
        let port = 3000;
        
        // Mode detection from flags
        if (process.argv.includes("--cmd")) mode = "cmd";
        if (process.argv.includes("--app")) mode = "app";
        if (process.argv.includes("--web")) mode = "web";
        if (process.argv.includes("--web-app")) mode = "web-app";
        
        // Framework/Target shortcuts
        if (process.argv.includes("--php")) {
             target = "php";
             mode = "cmd"; 
        }
        if (process.argv.includes("--laravel")) {
             target = "php";
             mode = "cmd"; // For now, run as cmd script, detection logic inside codegen will handle specifics
        }
        if (process.argv.includes("--react")) {
             target = "js";
             mode = "web";
        }
        
        // Check custom target
        let t_idx = process.argv.indexOf("--target");
        if (t_idx > -1 && process.argv[t_idx+1]) {
            target = process.argv[t_idx+1];
        }
        
        // Check custom port
        let p_idx = process.argv.indexOf("--port");
        if (p_idx > -1 && process.argv[p_idx+1]) {
            port = parseInt(process.argv[p_idx+1]);
        }
        
        // Auto-detect mode from omni.conf.json if no explicit flag
        const hasExplicitMode = ["--cmd", "--app", "--web", "--web-app"].some(f => process.argv.includes(f));
        
        if (!hasExplicitMode) {
            const dir = path.dirname(run_file);
            const possibleConfigs = [
                path.join(dir, 'omni.conf.json'),
                path.join(dir, '..', 'omni.conf.json')
            ];
            
            for (const confPath of possibleConfigs) {
                if (fs.existsSync(confPath)) {
                    try {
                        const conf = JSON.parse(fs.readFileSync(confPath, 'utf-8'));
                        if (conf.defaultMode) {
                            mode = conf.defaultMode;
                        } else if (conf.targets && conf.targets.length > 0) {
                            mode = conf.targets[0];
                        }
                        CLI_info("Auto-detected mode: " + mode);
                    } catch(e) {}
                    break;
                }
            }
        }
        
        // Set target based on mode
        if (mode === "app") {
            target = "python";
        } else if (target !== "php" && target !== "js") {
            target = "js";
        }
        
        CLI_info("Mode: " + mode + " | Target: " + target);
        
        // Generate code
        const gen = new_code_generator(target);
        const code = CodeGenerator_generate(gen, program);
        
        const ext = target === "python" ? ".py" : ".js";
        const outFile = run_file.replace(".omni", ext);
        const htmlFile = run_file.replace(".omni", ".html");
        
        // ========== CMD MODE ==========
        if (mode === "cmd") {
            CLI_info("Running in terminal...");
            
            let finalCode = code;
            /*
                var nl = String.fromCharCode(10);
                if (target === "js") {
                    finalCode += nl + "if (typeof main === 'function') main();" + nl;
                } else if (target === "python") {
                    finalCode += nl + "if __name__ == '__main__':" + nl + "    main()" + nl;
                } else if (target === "php") {
                    finalCode += nl + "if (function_exists('main')) { main(); }" + nl;
                }
            */
            
            fs.writeFileSync(outFile, finalCode);
            
            let cmd = "node";
            if (target === "python") cmd = "python";
            if (target === "php") cmd = "php";
            
            spawnSync(cmd, [outFile], { stdio: 'inherit' });
        }
        
        // ========== APP MODE ==========
        else if (mode === "app") {
            CLI_info("Launching native app...");
            
            let finalCode = code;
            // var nl = String.fromCharCode(10);
            // finalCode += nl + "if __name__ == '__main__':" + nl + "    main()" + nl;
            
            fs.writeFileSync(outFile, finalCode);
            spawnSync("python", [outFile], { stdio: 'inherit' });
        }
        
        
        // Shared Web Server Logic
        
        const startWebServer = (p, openBrowser) => {
            // Re-write HTML/JS files based on current mode/target
            // (Assumed already written by caller or we write them here? 
            // Better to write them before calling this to allow title customization if needed, 
            // but for simplicity we rely on files existing)
            
            const tryServer = http.createServer((req, res) => {
                let filePath;
                if (req.url === '/' || req.url === '/index.html') {
                    filePath = htmlFile;
                } else {
                    filePath = path.join(path.dirname(run_file), req.url);
                }
                
                const extName = path.extname(filePath);
                const mimeTypes = {
                    '.html': 'text/html',
                    '.js': 'text/javascript',
                    '.css': 'text/css',
                    '.json': 'application/json',
                    '.png': 'image/png',
                    '.jpg': 'image/jpeg',
                    '.ico': 'image/x-icon'
                };
                
                fs.readFile(filePath, (err, data) => {
                    if (err) {
                        res.writeHead(404);
                        res.end('Not Found: ' + filePath);
                        return;
                    }
                    res.writeHead(200, { 'Content-Type': mimeTypes[extName] || 'text/plain' });
                    res.end(data);
                });
            });

            tryServer.on('error', (e) => {
                if (e.code === 'EADDRINUSE') {
                    CLI_warning("Port " + p + " is already in use.");
                    
                    const rl = readline.createInterface({
                        input: process.stdin,
                        output: process.stdout
                    });
                    
                    CLI_info("Options:");
                    CLI_info(" [y/s] Kill process and restart");
                    CLI_info(" [number] Start on different port");
                    CLI_info(" [n] Cancel");
                    
                    process.stdout.write("> ");
                    
                    rl.question('', (answer) => {
                        rl.close();
                        const ans = answer.trim().toLowerCase();
                        
                        if (ans === 'y' || ans === 's') {
                            CLI_info("Killing process on port " + p + "...");
                            try {
                                if (process.platform === 'win32') {
                                    spawnSync("powershell", ["-Command", `Get-NetTCPConnection -LocalPort ${p} -ErrorAction SilentlyContinue | ForEach-Object { Stop-Process -Id $_.OwningProcess -Force }`], { stdio: 'inherit' });
                                } else {
                                    spawnSync("sh", ["-c", `lsof -ti:${p} | xargs kill -9`], { stdio: 'inherit' });
                                }
                                startWebServer(p, openBrowser); // Retry same port
                            } catch(err) {
                                CLI_error("Failed to kill process: " + err.message);
                            }
                        } else if (!isNaN(parseInt(ans))) {
                            const newPort = parseInt(ans);
                            startWebServer(newPort, openBrowser);
                        } else {
                            CLI_error("Aborted.");
                            process.exit(1);
                        }
                    });
                } else {
                    CLI_error("Server error: " + e.message);
                    process.exit(1);
                }
            });
            
            tryServer.listen(p, () => {
                CLI_success("Server running at http://localhost:" + p);
                
                if (openBrowser) {
                     const url = "http://localhost:" + p;
                     CLI_info("Opening browser in App Mode: " + url);
                     const platform = process.platform;
                     let openCmd;
                     
                     if (platform === 'win32') {
                         // Try to find Edge or Chrome for "App Mode" (--app=url)
                         // This gives a native window feel without address bar
                         const edgePath = "C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe";
                         const chromePath = "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe";
                         
                         if (fs.existsSync(edgePath)) {
                             openCmd = `"${edgePath}" --app="${url}"`;
                         } else if (fs.existsSync(chromePath)) {
                             openCmd = `"${chromePath}" --app="${url}"`;
                         } else {
                             // Fallback to default browser
                             openCmd = 'start "" "' + url + '"';
                         }
                     } else if (platform === 'darwin') {
                         // macOS: open -n -a "Google Chrome" --args --app=...
                         openCmd = 'open -n -a "Google Chrome" --args --app="' + url + '"'; 
                     } else {
                         // Linux: google-chrome --app=...
                         openCmd = 'google-chrome --app="' + url + '" || xdg-open "' + url + '"';
                     }
                     
                     exec(openCmd, (err) => {
                         if (err) {
                             // Fallback to standard open if app mode fails
                             CLI_warning("Could not open in App Mode, falling back to default browser...");
                             const fallback = (platform === 'win32') ? 'start "" "' + url + '"' : 
                                            (platform === 'darwin') ? 'open "' + url + '"' : 
                                            'xdg-open "' + url + '"';
                             exec(fallback);
                         }
                     });
                }
                
                CLI_info("Press Ctrl+C to stop");
            });
        };

        // ========== WEB MODE ==========
        if (mode === "web") {
            CLI_info("Starting web server...");
            fs.writeFileSync(outFile, code);
            
            const baseName = path.basename(outFile);
            const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Omni Web - ${baseName}</title>
    <style>
        body { margin: 0; font-family: system-ui, sans-serif; background: #1a1a2e; color: #eee; }
        #app { padding: 20px; }
        canvas { display: block; margin: 0 auto; }
    </style>
</head>
<body>
    <div id="app"></div>
    <script src="${baseName}"></script>
    <script>if (typeof main === 'function') main();</script>
</body>
</html>`;
            fs.writeFileSync(htmlFile, html);
            startWebServer(port, false);
        }
        
        // ========== WEB-APP MODE ==========
        else if (mode === "web-app") {
            CLI_info("Starting web server with browser...");
            fs.writeFileSync(outFile, code);
            
            const baseName = path.basename(outFile);
            const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Omni Web App - ${baseName}</title>
    <style>
        body { margin: 0; font-family: system-ui, sans-serif; background: #1a1a2e; color: #eee; }
        #app { padding: 20px; }
        canvas { display: block; margin: 0 auto; }
    </style>
</head>
<body>
    <div id="app"></div>
    <script src="${baseName}"></script>
    <script>if (typeof main === 'function') main();</script>
</body>
</html>`;
            fs.writeFileSync(htmlFile, html);
            startWebServer(port, true);
        }
    
    return true;
}

module.exports = { cmd_run };


function cmd_build() {
    CLI_info("Building from omni.config.json...");
}

module.exports = { cmd_build };


function cmd_test_all() {
    CLI_banner();
    CLI_header("Testing All Examples");
    
        
        // Find examples directory
        const possiblePaths = [
            path.join(process.cwd(), 'examples'),
            path.join(__dirname, '..', '..', 'examples'),
            path.join(__dirname, '..', 'examples')
        ];
        
        let examplesDir = null;
        for (const p of possiblePaths) {
            if (fs.existsSync(p)) {
                examplesDir = p;
                break;
            }
        }
        
        if (!examplesDir) {
            CLI_error("Examples directory not found");
            CLI_info("Run from project root: .\\omni test-all");
            return 1;
        }
        
        CLI_info("Examples directory: " + examplesDir);
        console.log("");
        
        // Find all example folders (with omni.conf.json)
        const entries = fs.readdirSync(examplesDir, { withFileTypes: true });
        const examples = [];
        
        for (const entry of entries) {
            if (entry.isDirectory()) {
                const confPath = path.join(examplesDir, entry.name, 'omni.conf.json');
                if (fs.existsSync(confPath)) {
                    try {
                        const conf = JSON.parse(fs.readFileSync(confPath, 'utf-8'));
                        examples.push({
                            name: entry.name,
                            conf: conf,
                            entryPath: path.join(examplesDir, entry.name, conf.entry || 'src/main.omni'),
                            modes: conf.targets || ['cmd']
                        });
                    } catch(e) {
                        console.log(CLI_COLORS().yellow + "   " + CLI_COLORS().reset + entry.name + " (invalid config)");
                    }
                }
            }
        }
        
        // Sort by name
        examples.sort((a, b) => a.name.localeCompare(b.name));
        
        CLI_info("Found " + examples.length + " example folders");
        console.log("");
        
        let passed = 0;
        let failed = 0;
        const failures = [];
        const results = {};
        
        for (const ex of examples) {
            const modeResults = [];
            
            for (const mode of ex.modes) {
                try {
                    // Read and parse
                    if (!fs.existsSync(ex.entryPath)) {
                        throw new Error("Entry file not found: " + ex.entryPath);
                    }
                    
                    const source = fs.readFileSync(ex.entryPath, 'utf-8');
                    const l = new_lexer(source);
                    const p = new_parser(l);
                    const program = Parser_parse_program(p);
                    
                    // Determine target based on mode
                    let target = "js";
                    if (mode === "app") target = "python";
                    
                    // Generate code
                    const gen = HybridCodeGenerator_new(target);
                    const code = HybridCodeGenerator_generate(gen, program);
                    
                    // Check if code was generated
                    if (code && code.length > 0) {
                        modeResults.push({ mode, success: true });
                    } else {
                        modeResults.push({ mode, success: false, error: "Empty output" });
                    }
                } catch (e) {
                    modeResults.push({ mode, success: false, error: e.message });
                }
            }
            
            // Report results for this example
            const allPassed = modeResults.every(r => r.success);
            const modeStr = modeResults.map(r => 
                r.success ? CLI_COLORS().green + r.mode + CLI_COLORS().reset 
                          : CLI_COLORS().red + r.mode + CLI_COLORS().reset
            ).join(", ");
            
            if (allPassed) {
                passed++;
                console.log(CLI_COLORS().green + "   " + CLI_COLORS().reset + ex.name + CLI_COLORS().dim + " [" + modeStr + "]" + CLI_COLORS().reset);
            } else {
                failed++;
                const failedModes = modeResults.filter(r => !r.success);
                failures.push({ name: ex.name, errors: failedModes });
                console.log(CLI_COLORS().red + "   " + CLI_COLORS().reset + ex.name + CLI_COLORS().dim + " [" + modeStr + "]" + CLI_COLORS().reset);
            }
        }
        
        console.log("");
        console.log("");
        console.log("Results: " + CLI_COLORS().green + passed + " passed" + CLI_COLORS().reset + ", " + 
            (failed > 0 ? CLI_COLORS().red + failed + " failed" + CLI_COLORS().reset : "0 failed"));
        console.log("");
        
        if (failed > 0) {
            CLI_warning("Some examples failed to compile");
            for (const f of failures) {
                console.log(CLI_COLORS().dim + "  " + f.name + ":" + CLI_COLORS().reset);
                for (const err of f.errors) {
                    console.log(CLI_COLORS().dim + "    [" + err.mode + "] " + err.error.substring(0, 60) + CLI_COLORS().reset);
                }
            }
            return 1;
        } else {
            CLI_success("All examples compiled successfully!");
            return 0;
        }
    
    return true;
}

module.exports = { cmd_test_all };


function cmd_package_self() {
    CLI_header("Self-Package");
    
        const { execSync } = require('child_process');
        
        const omniDir = path.dirname(path.dirname(__filename));
        const version = CLI_version();
        const platform = process.platform;
        
        terminal.CLI_step(1, 4, "Collecting source files...");
        
        // Files to include
        const distDir = path.join(omniDir, 'dist');
        const targetsDir = path.join(omniDir, 'targets');
        
        terminal.CLI_step(2, 4, "Creating package manifest...");
        
        const manifest = {
            name: 'omni-compiler',
            version: version,
            platform: platform,
            created: new Date().toISOString(),
            files: []
        };
        
        // List dist files
        if (fs.existsSync(distDir)) {
            const files = fs.readdirSync(distDir, { recursive: true });
            manifest.files.push(...files.map(f => 'dist/' + f));
        }
        
        // List target profiles
        if (fs.existsSync(targetsDir)) {
            const files = fs.readdirSync(targetsDir);
            manifest.files.push(...files.map(f => 'targets/' + f));
        }
        
        CLI_step(3, 4, "Writing package...");
        
        const packageName = `omni-${version}-${platform}`;
        const packageDir = path.join(omniDir, 'packages');
        
        if (!fs.existsSync(packageDir)) {
            fs.mkdirSync(packageDir, { recursive: true });
        }
        
        // Write manifest
        fs.writeFileSync(
            path.join(packageDir, packageName + '.json'),
            JSON.stringify(manifest, null, 2)
        );
        
        CLI_step(4, 4, "Creating executable wrapper...");
        
        // Create .run file (Unix) or .cmd (Windows)
        if (platform === 'win32') {
            const runContent = `@echo off
set OMNI_HOME=%~dp0
node "%OMNI_HOME%dist\\main.js" %*`;
            fs.writeFileSync(path.join(packageDir, packageName + '.cmd'), runContent);
            CLI_success("Package created: packages/" + packageName + ".cmd");
        } else {
            const runContent = `#!/bin/bash
OMNI_HOME="$(dirname "$(readlink -f "$0")")"
node "$OMNI_HOME/dist/main.js" "$@"`;
            const runPath = path.join(packageDir, packageName + '.run');
            fs.writeFileSync(runPath, runContent);
            fs.chmodSync(runPath, '755');
            CLI_success("Package created: packages/" + packageName + ".run");
        }
        
        console.log("");
        CLI_info("Package manifest: packages/" + packageName + ".json");
        CLI_info("Total files: " + manifest.files.length);
    
}

module.exports = { cmd_package_self };


function cmd_contracts() {
    
        const registry = ContractRegistry_new();
        ContractRegistry_list_interfaces(registry);
    
}

module.exports = { cmd_contracts };


function cmd_studio_cli() {
    let port = 3000;
    let open_app = false;
    let run_tui = false;
    
        // Parse port option
        for (let i = 3; i < process.argv.length; i++) {
            if (process.argv[i] === '--port' && process.argv[i + 1]) {
                port = parseInt(process.argv[i + 1]);
            }
            if (process.argv[i] === '--app') {
                open_app = true;
            }
            if (process.argv[i] === '--tui') {
                run_tui = true;
            }
        }
    
    if (run_tui) {
    cmd_tui();
} else {
    cmd_studio(port, open_app);
}
}

module.exports = { cmd_studio_cli };


function cmd_version() {
    CLI_banner();
    print("Version: " + CLI_version());
    print("");
    
        console.log(CLI_COLORS.dim + "Node.js: " + process.version + CLI_COLORS.reset);
        console.log(CLI_COLORS.dim + "Platform: " + process.platform + CLI_COLORS.reset);
        console.log(CLI_COLORS.dim + "Arch: " + process.arch + CLI_COLORS.reset);
    
}
function main() {
    let args_len = 0;
    
        args_len = process.argv.length;
    
    let command = "";
    
        command = process.argv[2] || '';
    
    if (command == "setup") {
    let is_global = false;
    
            for (let i = 3; i < process.argv.length; i++) {
                if (process.argv[i] === '--global' || process.argv[i] === '-g') {
                    is_global = true;
                }
            }
        
    cmd_setup(is_global);
    return 0;
}
    if (command == "--version" || command == "-v" || command == "version") {
    cmd_version();
    return 0;
}
    if (command == "package") {
    let self_package = false;
     self_package = process.argv[3] === '--self'; 
    if (self_package) {
    cmd_package_self();
    return 0;
}
}
    if (command == "install") {
    let package_spec = "";
     package_spec = process.argv[3] || ''; 
    cmd_install(package_spec);
    return 0;
}
    if (command == "uninstall") {
    let package_name = "";
     package_name = process.argv[3] || ''; 
    if (package_name == "") {
    CLI_error("Usage: omni uninstall <package_name>");
    return 1;
}
    cmd_uninstall(package_name);
    return 0;
}
    if (command == "list") {
    cmd_list();
    return 0;
}
    if (command == "update") {
    let package_name = "";
     package_name = process.argv[3] || ''; 
    cmd_update(package_name);
    return 0;
}
    if (command == "search") {
    let query = "";
     query = process.argv[3] || ''; 
    cmd_search(query);
    return 0;
}
    if (command == "doctor") {
    cmd_doctor();
    return 0;
}
    if (command == "contracts") {
    cmd_contracts();
    return 0;
}
    if (command == "graph") {
    let input_file = "";
    let output_file = "";
     
            input_file = process.argv[3] || '';
            output_file = process.argv[4] || '';
        
    if (input_file == "") {
    CLI_error("Usage: omni graph <input.omni> [output.md]");
    CLI_info("Generates architecture diagrams in Mermaid format");
    return 1;
}
    if (output_file == "") {
    
                output_file = path.basename(input_file, '.omni') + '_architecture.md';
            
}
    cmd_graph(input_file, output_file);
    return 0;
}
    if (command == "bootstrap") {
    cmd_bootstrap();
    return 0;
}
    if (command == "studio") {
    cmd_studio_cli();
    return 0;
}
    if (command == "ui") {
    cmd_tui();
    return 0;
}
    if (command == "package") {
    let target = "";
    
            for (let i = 3; i < process.argv.length; i++) {
                if (process.argv[i] === '--app' && process.argv[i + 1]) {
                    target = process.argv[i + 1];
                }
            }
            if (!target) {
                const platform = process.platform;
                if (platform === 'win32') target = 'windows';
                else if (platform === 'darwin') target = 'macos';
                else if (platform === 'linux') target = 'linux';
                else target = 'windows';
            }
        
    let config = AppConfig_default();
    
            const configPath = path.join(process.cwd(), 'omni.config.json');
            
            if (fs.existsSync(configPath)) {
                const cfg = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
                if (cfg.app) {
                    config.name = cfg.app.name || config.name;
                    config.version = cfg.app.version || config.version;
                    config.bundle_id = cfg.app.bundle_id || config.bundle_id;
                    config.description = cfg.app.description || config.description;
                }
            }
        
    cmd_package_app(target, config);
    return 0;
}
    if (command == "ingest") {
    let input_file = "";
    let output_file = "";
     
            input_file = process.argv[3] || '';
            output_file = process.argv[4] || '';
        
    if (input_file == "") {
    CLI_error("Usage: omni ingest <legacy_file> <output.omni>");
    return 1;
}
    if (output_file == "") {
    
                output_file = path.basename(input_file).replace(/\.[^.]+$/, '.omni');
            
}
    cmd_ingest(input_file, output_file);
    return 0;
}
    if (command == "run") {
    cmd_run();
    return 0;
}
    if (command == "build") {
    cmd_build();
    return 0;
}
    if (command == "test-all") {
    cmd_test_all();
    return 0;
}
    let show_help = false;
     
        show_help = command === 'help' || command === '--help' || command === '-h'; 
    
    if (command == "" || args_len < 3) {
    CLI_info("Launching interactive mode...");
    cmd_tui();
    return 0;
}
    if (show_help) {
    CLI_banner();
    print("Commands:");
    print("  setup                          Start Global Setup Wizard");
    print("  run <file.omni>                Execute instantly via VM");
    print("  build                          Build from omni.config.json");
    print("  test-all                       Validate all examples compile");
    print("  package --self                 Create self-contained package");
    print("  <input> <output> [options]     Compile to target");
    print("");
    print("Options:");
    print("  --target <lang>     Target language (js, python)");
    print("  --package <path>    Load external language package (.omni-pkg)");
    print("  --framework <name>  Framework adapter (nextjs, laravel, android)");
    print("  --coverage          Show AST coverage report");
    print("  --version, -v       Show version");
    print("");
    return 0;
}
    let input_path = "";
    let output_path = "";
    let target_lang = "js";
    let package_path = "";
    let framework = "";
    let show_coverage = false;
    
        input_path = process.argv[2];
        output_path = process.argv[3];
        
        for (let i = 4; i < process.argv.length; i++) {
            const arg = process.argv[i];
            if (arg === "--target" && (i + 1 < process.argv.length)) {
                target_lang = process.argv[++i];
            } else if (arg === "--package" && (i + 1 < process.argv.length)) {
                package_path = process.argv[++i];
            } else if (arg === "--framework" && (i + 1 < process.argv.length)) {
                framework = process.argv[++i];
            } else if (arg === "--coverage") {
                show_coverage = true;
            }
        }
        
        if (!output_path && input_path) {
             const ext = target_lang === "python" ? ".py" : ".js";
             output_path = input_path.replace(path.extname(input_path), ext);
        }
    
    CLI_info("Compiling: " + input_path);
    CLI_info("Target: " + target_lang);
    
        if (package_path) {
            
            if (fs.existsSync(package_path)) {
                CLI_info("Loading package: " + package_path);
                
                const grammarPath = fs.statSync(package_path).isDirectory() 
                    ? path.join(package_path, 'grammar.json')
                    : package_path;
                    
                if (fs.existsSync(grammarPath)) {
                    const targetDir = path.join(__dirname, '..', 'targets');
                    if (!fs.existsSync(targetDir)) {
                        fs.mkdirSync(targetDir, { recursive: true });
                    }
                    
                    const profile = JSON.parse(fs.readFileSync(grammarPath, 'utf-8'));
                    const profileName = profile.name || path.basename(package_path, '.omni-pkg');
                    fs.writeFileSync(
                        path.join(targetDir, profileName + '.json'),
                        JSON.stringify(profile, null, 2)
                    );
                    
                    target_lang = profileName;
                    CLI_success("Loaded profile: " + profileName);
                }
            } else {
                CLI_warning("Package not found: " + package_path);
            }
        }
    
    let source = read_file(input_path);
    let l = new_lexer(source);
    let p = new_parser(l);
    let program = Parser_parse_program(p);
    let gen = new_code_generator(target_lang);
    
        if (framework) {
            gen.framework = framework;
        }
    
    let code = CodeGenerator_generate(gen, program);
    
        if (show_coverage || gen.ast_node_count > 0) {
            const coverage = gen.ast_node_count > 0 
                ? (gen.generated_count / gen.ast_node_count * 100).toFixed(1)
                : 100;
            CLI_info("AST Coverage: " + coverage + "% (" + 
                gen.generated_count + "/" + gen.ast_node_count + " nodes)");
                
            if (coverage < 100) {
                CLI_warning("Some AST nodes were not generated");
            }
        }
    
    write_file(output_path, code);
    CLI_success("Output: " + output_path);
    CLI_success("Compiled successfully!");
}

    if (require.main === module) {
        if (typeof main === 'function') {
            main();
        }
    }


module.exports = { cmd_version, main };

