
// Generated by Omni Compiler
'use strict';

const token = require('./token.js');

function char_at(s, i) {
if (i >= s.length) return "\0";
        return s.charAt(i);
}

function is_letter(ch) {
return /[a-zA-Z_]/.test(ch);
}

function is_digit(ch) {
return /\d/.test(ch);
}

class Lexer {
    constructor(data = {}) {
        this.input = data.input;
        this.position = data.position;
        this.read_position = data.read_position;
        this.ch = data.ch;
        this.line = data.line;
    }
}

function new_lexer(input) {
    const l = new Lexer({ input: input, position: 0, read_position: 0, ch: "\0", line: 1 });
    Lexer_read_char(l);
    return l;
}

function Lexer_read_char(l) {
    if ((l.read_position >= 999999)) {
    l.ch = "\0";
}
 else {
    l.ch = char_at(l.input, l.read_position);
}

    let is_eof = false;
is_eof = l.ch === "\0";
    if (is_eof) {
    l.ch = "\0";
}
 else {
    l.position = l.read_position;
    l.read_position = (l.read_position + 1);
}

}

function Lexer_skip_whitespace(l) {
    let is_ws = false;
is_ws = l.ch === ' ' || l.ch === '\t' || l.ch === '\n' || l.ch === '\r';
    while (is_ws) {
    if ((l.ch === "\n")) {
    l.line = (l.line + 1);
}

    Lexer_read_char(l);
is_ws = l.ch === ' ' || l.ch === '\t' || l.ch === '\n' || l.ch === '\r';
}

}

function Lexer_read_identifier(l) {
    const start_pos = l.position;
    while (is_letter(l.ch) || is_digit(l.ch)) {
    Lexer_read_char(l);
}

    let ident = "";
    ident = l.input.substring(Number(start_pos), Number(l.position));
    if (ident === "fn") {
        // console.log("READ IDENTIFIER: " + ident + " (fn) at POS " + l.position);
    }
    return ident;
}

function Lexer_read_number(l) {
    const start_pos = l.position;
    while (is_digit(l.ch)) {
    Lexer_read_char(l);
}

    let num_str = "";
num_str = l.input.substring(Number(start_pos), Number(l.position));
    return num_str;
}

function Lexer_lookup_ident(ident) {
    if ((ident === "fn")) {
        // console.log("Lexer lookup fn. TOKEN_FN is: " + TOKEN_FN);
    return TOKEN_FN;
}

    if ((ident === "let")) {
    return TOKEN_LET;
}

    if ((ident === "struct")) {
    return TOKEN_STRUCT;
}

    if ((ident === "if")) {
    return TOKEN_IF;
}

    if ((ident === "else")) {
    return TOKEN_ELSE;
}

    if ((ident === "return")) {
    return TOKEN_RETURN;
}

    if ((ident === "true")) {
    return TOKEN_TRUE;
}

    if ((ident === "false")) {
    return TOKEN_FALSE;
}

    if ((ident === "native")) {
    return TOKEN_NATIVE;
}

    if ((ident === "import")) {
    return 90;
}

    if ((ident === "while")) {
    return TOKEN_WHILE;
}

    return TOKEN_IDENTIFIER;
}

function Lexer_next_token(l) {
    Lexer_skip_whitespace(l);

    // Skip comments
    if (l.ch === '/' && char_at(l.input, l.read_position) === '/') {
        while (l.ch !== '\n' && l.ch !== '\0') {
            Lexer_read_char(l);
        }
        Lexer_skip_whitespace(l);
    }

    const tok = new_token(TOKEN_ILLEGAL, l.ch, l.line);
    tok.start = l.position;
    if ((l.ch === "\0")) {
    tok.kind = TOKEN_EOF;
    tok.lexeme = "";
    return tok;
}

    if ((l.ch === "=")) {
        if (char_at(l.input, l.read_position) === '=') {
            Lexer_read_char(l);
            tok.kind = 28; // TOKEN_EQ
            tok.lexeme = "==";
        } else {
            tok.kind = TOKEN_ASSIGN;
            tok.lexeme = "=";
        }
    } else if (l.ch === "!") {
        if (char_at(l.input, l.read_position) === '=') {
            Lexer_read_char(l);
            tok.kind = 29; // TOKEN_NOT_EQ
            tok.lexeme = "!=";
        } else {
            tok.kind = 23; // TOKEN_BANG
            tok.lexeme = "!";
        }
    } else if (l.ch === "&") {
        if (char_at(l.input, l.read_position) === '&') {
            Lexer_read_char(l); // eat &
            tok.kind = 32; // TOKEN_AND
            tok.lexeme = "&&";
        } else {
            tok.kind = TOKEN_ILLEGAL;
            tok.lexeme = "&";
        }
    } else if (l.ch === "|") {
        if (char_at(l.input, l.read_position) === '|') {
            Lexer_read_char(l); // eat |
            tok.kind = 33; // TOKEN_OR
            tok.lexeme = "||";
        } else {
             tok.kind = TOKEN_ILLEGAL;
             tok.lexeme = "|";
        }
    } else {
        if ((l.ch === ";")) {
    tok.kind = TOKEN_SEMICOLON;
    tok.lexeme = ";";
}
 else {
    if ((l.ch === "(")) {
    tok.kind = TOKEN_LPAREN;
    tok.lexeme = "(";
}
 else {
    if ((l.ch === ")")) {
    tok.kind = TOKEN_RPAREN;
    tok.lexeme = ")";
}
 else {
    if ((l.ch === "{")) {
    tok.kind = TOKEN_LBRACE;
    tok.lexeme = "{";
}
 else {
    if ((l.ch === "}")) {
    tok.kind = TOKEN_RBRACE;
    tok.lexeme = "}";
}
 else {
    if ((l.ch === ",")) {
    tok.kind = TOKEN_COMMA;
    tok.lexeme = ",";
}
 else {
    if ((l.ch === ":")) {
    tok.kind = 30;
    tok.lexeme = ":";
}
 else {
    if ((l.ch === "[")) {
        tok.kind = 46; // TOKEN_LBRACKET
        tok.lexeme = "[";
    } else if ((l.ch === "]")) {
        tok.kind = 47; // TOKEN_RBRACKET
        tok.lexeme = "]";
    } else if ((l.ch === ".")) {
    tok.kind = 31;
    tok.lexeme = ".";
}
 else {
    if ((l.ch === "+")) {
    tok.kind = TOKEN_PLUS;
    tok.lexeme = "+";
}
 else {
    if ((l.ch === "\"")) {
    let str_val = "";
    Lexer_read_char(l);
    const start = l.position;
    while ((l.ch !== "\"")) {
    Lexer_read_char(l);
}

    const end = l.position;
str_val = l.input.substring(Number(start), Number(end));
    tok.kind = TOKEN_STRING;
    tok.lexeme = str_val;
}
 else {
    if (is_letter(l.ch)) {
    let literal = Lexer_read_identifier(l);
    tok.kind = Lexer_lookup_ident(literal);
    tok.lexeme = literal;
    return tok;
}
 else {
    if (is_digit(l.ch)) {
    tok.kind = TOKEN_INT;
    tok.lexeme = Lexer_read_number(l);
    return tok;
}
 else {
    tok.kind = TOKEN_ILLEGAL;
    tok.lexeme = l.ch;
}

}

}

}

}

}

}

}

}

}

}

}

}

    Lexer_read_char(l);
    return tok;
}






module.exports = { char_at, is_letter, is_digit, new_lexer, Lexer_read_char, Lexer_skip_whitespace, Lexer_read_identifier, Lexer_read_number, Lexer_lookup_ident, Lexer_next_token, Lexer };

Object.assign(global, token);
