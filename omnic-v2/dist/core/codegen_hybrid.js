// Generated by Omni Compiler
'use strict';

const ast = require('./ast.js');
const token = require('./token.js');

class CodeGenerator {
    constructor(data = {}) {
        this.target = data.target;
        this.indent = data.indent;
    }
}

const HybridCodeGenerator_new = new_code_generator;
const HybridCodeGenerator_generate = CodeGenerator_generate;

function new_code_generator(target) {
    return new CodeGenerator({ target: target, indent: 0 });
}

function CodeGenerator_generate(self, program) {
    if ((self.target === "python")) {
    return CodeGenerator_generate_python(self, program);
}

    let output = "";
if (program && program.statements) {
            for (const stmt of program.statements) {
                output = output + CodeGenerator_gen_statement(self, stmt) + "\n";
            }
        }
    let exports = [];
if (program && program.statements) {
             for (const stmt of program.statements) {
                 if (stmt.is_exported && stmt.name) {
                     exports.push(stmt.name);
                 }
             }
        }
        if (exports.length > 0) {
            output += "\nmodule.exports = { " + exports.join(", ") + " };\n";
        }
    return output;
}

function CodeGenerator_generate_python(self, program) {
    let output = "";
if (program && program.statements) {
            for (const stmt of program.statements) {
                self.indent = 0; // Reset indent for each top-level statement
                output = output + CodeGenerator_gen_stmt_py(self, stmt) + "\n";
            }
        }
    let py_exports = [];
if (program && program.statements) {
             for (const stmt of program.statements) {
                 if (stmt.is_exported && stmt.name) {
                     py_exports.push("'" + stmt.name + "'");
                 }
             }
        }
        if (py_exports.length > 0) {
            output += "\n__all__ = [" + py_exports.join(", ") + "]\n";
        }
    return output;
}

function CodeGenerator_gen_stmt_py(self, stmt) {
    let indent_str = "";
indent_str = "    ".repeat(self.indent);
    if ((stmt.kind === 91)) {
    return "";
}

    if ((stmt.kind === 10)) { // NODE_IMPORT
    let path = stmt.path;
    let name = "";
path = path.replace(".omni", "");
             path = path.replace(/\//g, "."); // core/token -> core.token
             if (path.startsWith(".")) path = path.substring(1); // ./core -> /core -> core (fix logic later if needed)
             if (path.startsWith(".")) path = path.substring(1);
             name = path.split(".").pop();
    return ((((indent_str + "import ") + path) + " as ") + name);
}

    if ((stmt.kind === 80)) {
    if ((((stmt.lang === "py") || stmt.lang) === "python")) {
    return stmt.code;
}

    return "";
}

    if ((stmt.kind === 2)) { // NODE_LET
    return (((indent_str + stmt.name) + " = ") + CodeGenerator_gen_expr_py(self, stmt.value));
}

    if ((stmt.kind === 7)) { // NODE_RETURN
    return ((indent_str + "return ") + CodeGenerator_gen_expr_py(self, stmt.value));
}

    if ((stmt.kind === 4)) { // NODE_FUNCTION
    let params = "";
params = stmt.params.join(", ");
    let decl = (((((indent_str + "def ") + stmt.name) + "(") + params) + "):\n");
    self.indent = (self.indent + 1);
    let body = CodeGenerator_gen_block_py(self, stmt.body);
    self.indent = (self.indent - 1);
    return (decl + body);
}

    if ((stmt.kind === 70)) { // NODE_STRUCT
    let decl = (((indent_str + "class ") + stmt.name) + ":\n");
    self.indent = (self.indent + 1);
    let init_indent = "";
init_indent = "    ".repeat(self.indent);
    let assignments = "";
if (stmt.fields.length == 0) {
                 assignments = init_indent + "    pass";
             } else {
                 for(let f of stmt.fields) {
                     assignments += init_indent + "    self." + f.name + " = data.get('" + f.name + "')\n";
                 }
             }
    let init_fn = (init_indent + "def __init__(self, data=None):\n");
    init_fn = ((init_fn + init_indent) + "    if data is None: data = {}\n");
    init_fn = ((init_fn + assignments) + "\n");
    self.indent = (self.indent - 1);
    return (decl + init_fn);
}

    if ((stmt.kind === 13)) { // NODE_IF
    let cond = CodeGenerator_gen_expr_py(self, stmt.condition);
    let out = (((indent_str + "if ") + cond) + ":\n");
    self.indent = (self.indent + 1);
    out = (out + CodeGenerator_gen_block_py(self, stmt.consequence));
    self.indent = (self.indent - 1);
    if (stmt.alternative) {
    out = (((out + "\n") + indent_str) + "else:\n");
    self.indent = (self.indent + 1);
    out = (out + CodeGenerator_gen_block_py(self, stmt.alternative));
    self.indent = (self.indent - 1);
}

    return out;
}

    if ((stmt.kind === 14)) { // NODE_WHILE
    let cond = CodeGenerator_gen_expr_py(self, stmt.condition);
    let out = (((indent_str + "while ") + cond) + ":\n");
    self.indent = (self.indent + 1);
    out = (out + CodeGenerator_gen_block_py(self, stmt.body));
    self.indent = (self.indent - 1);
    return out;
}

    if (stmt.expr) {
    return (indent_str + CodeGenerator_gen_expr_py(self, stmt.expr));
}

    return ((indent_str + "# Unknown stmt: ") + stmt.kind);
}

function CodeGenerator_gen_block_py(self, block) {
    let out = "";
if (!block.statements || block.statements.length == 0) {
             out = "    ".repeat(self.indent) + "pass";
        } else {
             for (const s of block.statements) {
                  out = out + CodeGenerator_gen_stmt_py(self, s) + "\n";
             }
        }
    return out;
}

function CodeGenerator_gen_capsule(self, stmt) {
    let name = stmt.name;
    let body = "";
    // We treat Capsules as Classes with static members for now
    let properties = "";
    let methods = "";
    
    // Custom block generation to separate props and methods if needed
    // But for simplicity, we just iterate stmt.body.statements
    if (stmt.body && stmt.body.statements) {
         for (const s of stmt.body.statements) {
             if (s.kind === 2) { // NODE_LET (Capsule property)
                 // static name = value;
                 properties += "    static " + s.name + " = " + CodeGenerator_gen_expression(self, s.value) + ";\n";
             } else if (s.kind === 21) {
                 methods += "    " + CodeGenerator_gen_flow(self, s) + "\n";
             } else {
                 // Other statements? Init block?
                 // For now ignore
             }
         }
    }

    return "class " + name + " {\n" + properties + methods + "}\n";
}

function CodeGenerator_gen_flow(self, stmt) {
    let params = stmt.params.join(", ");
    let body = CodeGenerator_gen_block(self, stmt.body);
    // Flow is a static method
    return "static " + stmt.name + "(" + params + ") " + body;
}

function CodeGenerator_gen_expr_py(self, expr) {
    if ((expr === 0)) {
    return "None";
}

    if ((expr.kind === 3)) { // NODE_LITERAL
    if ((expr.value === "true")) {
    return "True";
}

    if ((expr.value === "false")) {
    return "False";
}

    if ((expr.value === "null")) {
    return "None";
}

    return expr.value;
}

    if ((expr.kind === 17)) { // NODE_STRING
    return (("\"" + expr.value) + "\"");
}

    if ((expr.kind === 18)) { // NODE_BOOL
    if (expr.value) {
    return "True";
}

    return "False";
}

    if ((expr.kind === 8)) { // NODE_BINARY
    let op = expr.op;
    if ((op === "&&")) {
    op = "and";
}

    if ((op === "||")) {
    op = "or";
}

    if ((op === "!")) {
    op = "not ";
}

    return ((((CodeGenerator_gen_expr_py(self, expr.left) + " ") + op) + " ") + CodeGenerator_gen_expr_py(self, expr.right));
}

    if ((expr.kind === 6)) { // NODE_CALL
    let callee = CodeGenerator_gen_expr_py(self, expr.function);
    let args = "";
let list = [];
            for(let a of expr.args) list.push(CodeGenerator_gen_expr_py(self, a));
            args = list.join(", ");
    return (((callee + "(") + args) + ")");
}

    if ((expr.kind === 9)) { // NODE_MEMBER
    return ((CodeGenerator_gen_expr_py(self, expr.target) + ".") + expr.property);
}

    if ((expr.kind === 12)) { // NODE_STRUCT_INIT
    let fields = "";
let list = [];
              for(let f of expr.fields) {
                   list.push("'" + f.name + "': " + CodeGenerator_gen_expr_py(self, f.value));
              }
              fields = list.join(", ");
    return (((expr.name + "({ ") + fields) + " })");
}

    if ((expr.kind === 11)) { // NODE_ARRAY
    let elems = "";
let list = [];
             for (let e of expr.elements) list.push(CodeGenerator_gen_expr_py(self, e));
             elems = list.join(", ");
    return (("[" + elems) + "]");
}

    if ((expr.kind === 15)) { // NODE_IDENTIFIER
    return expr.value;
}

    if ((expr.kind === 16)) { // NODE_ASSIGNMENT
    return ((CodeGenerator_gen_expr_py(self, expr.left) + " = ") + CodeGenerator_gen_expr_py(self, expr.right));
}

if (typeof(expr) == "string") return expr;
    return "None";
}

function CodeGenerator_gen_statement(self, stmt) {
    if ((stmt.kind === 10)) { // NODE_IMPORT
    return CodeGenerator_gen_import(self, stmt);
}

    if ((stmt.kind === 80)) { // NODE_NATIVE
        if ((stmt.lang === "js" || stmt.lang === "javascript")) {
            return stmt.code;
        }
        return "";
    }

    if ((stmt.kind === 2)) { // NODE_LET
    return (((("let " + stmt.name) + " = ") + CodeGenerator_gen_expression(self, stmt.value)) + ";");
}

    if ((stmt.kind === 7)) { // NODE_RETURN
    return (("return " + CodeGenerator_gen_expression(self, stmt.value)) + ";");
}

    if ((stmt.kind === 4)) { // NODE_FUNCTION
    let params = "";
params = stmt.params.join(", ");
    let body = CodeGenerator_gen_block(self, stmt.body);
    return ((((("function " + stmt.name) + "(") + params) + ") ") + body);
}

    if ((stmt.kind === 70)) { // NODE_STRUCT
    return CodeGenerator_gen_struct(self, stmt);
}

    if ((stmt.kind === 13)) { // NODE_IF
    let cond = CodeGenerator_gen_expression(self, stmt.condition);
    let cons = CodeGenerator_gen_block(self, stmt.consequence);
    let alt = "";
    if (stmt.alternative) {
    alt = (" else " + CodeGenerator_gen_block(self, stmt.alternative));
}

    return (((("if (" + cond) + ") ") + cons) + alt);
}

    if ((stmt.kind === 14)) { // NODE_WHILE
    let cond = CodeGenerator_gen_expression(self, stmt.condition);
    let body = CodeGenerator_gen_block(self, stmt.body);
    return ((("while (" + cond) + ") ") + body);
}

    if ((stmt.kind === 20)) { // NODE_CAPSULE
        return CodeGenerator_gen_capsule(self, stmt);
    }
    
    if ((stmt.kind === 21)) { // NODE_FLOW
        return CodeGenerator_gen_flow(self, stmt);
    }

    if (stmt.expr) {
    return (CodeGenerator_gen_expression(self, stmt.expr) + ";");
}

    // DEBUG: Log unknown statement content
    console.error("UNKNOWN STMT: " + JSON.stringify(stmt));
    return ("// Unknown stmt kind: " + stmt.kind + " type: " + typeof(stmt.kind));
}

function CodeGenerator_gen_import(self, stmt) {
    let path = stmt.path;
path = path.replace(".omni", ".js");
        if (path.startsWith(".") == false) path = "./" + path;
        // Extrai nome do arquivo para vari├â┬ível: "./core/token.js" -> "token"
        let name = path.split("/").pop().replace(".js", "");
        // Gera: const token = require("./token.js");
        return "const " + name + " = require(\"" + path + "\");\n" +
               "if (typeof global !== 'undefined') Object.assign(global, " + name + ");";
    return "";
}

function CodeGenerator_gen_struct(self, stmt) {
    let name = stmt.name;
    let assignments = "";
for (const field of stmt.fields) {
             assignments = assignments + "        this." + field.name + " = data." + field.name + ";\n";
        }
    return (((("class " + name) + " {\n    constructor(data = {}) {\n") + assignments) + "    }\n}");
}

function CodeGenerator_gen_block(self, block) {
    let out = "{\n";
if (block && block.statements) {
            for (const s of block.statements) {
                out = out + "    " + CodeGenerator_gen_statement(self, s) + "\n";
            }
        }
    out = (out + "}");
    return out;
}

function CodeGenerator_gen_expression(self, expr) {
    if ((expr === 0)) {
    return "null";
}

    if ((expr.kind === 3)) { // NODE_LITERAL
    return expr.value;
}

    if ((expr.kind === 17)) { // NODE_STRING
    return (("\"" + expr.value) + "\"");
}

    if ((expr.kind === 18)) { // NODE_BOOL
    if (expr.value) {
    return "true";
}

    return "false";
}

    if ((expr.kind === 8)) { // NODE_BINARY
    return ((((CodeGenerator_gen_expression(self, expr.left) + " ") + expr.op) + " ") + CodeGenerator_gen_expression(self, expr.right));
}

    if ((expr.kind === 6)) { // NODE_CALL
    let args = "";
let list = [];
             for(let a of expr.args) list.push(CodeGenerator_gen_expression(self, a));
             args = list.join(", ");
    let callee = CodeGenerator_gen_expression(self, expr.function);
    let is_class = false;
if (typeof expr.function.value === 'string') {
                 let val = expr.function.value;
                 let first = val.charAt(0);
                 is_class = (first >= "A" && first <= "Z") && (val.indexOf("_") == -1);
             }
    if (is_class) {
    return (((("new " + callee) + "(") + args) + ")");
}

    return (((callee + "(") + args) + ")");
}

    if ((expr.kind === 9)) { // NODE_MEMBER
    return ((CodeGenerator_gen_expression(self, expr.target) + ".") + expr.property);
}

    if ((expr.kind === 12)) { // NODE_STRUCT_INIT
    let fields = "";
let list = [];
            for(let f of expr.fields) {
                list.push(f.name + ": " + CodeGenerator_gen_expression(self, f.value));
            }
            fields = list.join(", ");
    return (((("new " + expr.name) + "({ ") + fields) + " })");
}

    if ((expr.kind === 11)) { // NODE_ARRAY
    let elems = "";
let list = [];
            for (let e of expr.elements) {
                list.push(CodeGenerator_gen_expression(self, e));
            }
            elems = list.join(", ");
    return (("[" + elems) + "]");
}

    if ((expr.kind === 15)) { // NODE_IDENTIFIER
    return expr.value;
}

    if ((expr.kind === 19)) { // NODE_PREFIX
        return expr.op + CodeGenerator_gen_expression(self, expr.right);
    }

    if ((expr.kind === 16)) { // NODE_ASSIGNMENT
    let left = CodeGenerator_gen_expression(self, expr.left);
    let right = CodeGenerator_gen_expression(self, expr.right);
    let code = "";
code = left + " = " + right;
    return code;
}

if (typeof(expr) == "string") return expr;
    return expr;
}


module.exports = {
    new_code_generator,
    CodeGenerator,
    CodeGenerator_generate,
    HybridCodeGenerator_new,
    HybridCodeGenerator_generate,
    CodeGenerator_generate_python,
    CodeGenerator_gen_statement,
    CodeGenerator_gen_expression,
    CodeGenerator_gen_block,
    CodeGenerator_gen_import,
    CodeGenerator_gen_struct,
    CodeGenerator_gen_stmt_py,
    CodeGenerator_gen_block_py,
    CodeGenerator_gen_expr_py
};
Object.assign(global, module.exports);
