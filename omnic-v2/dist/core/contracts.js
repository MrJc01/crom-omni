// Generated by Omni Compiler
'use strict';


class CanonicalInterface {
    constructor(data = {}) {
        this.name = data.name;
        this.category = data.category;
        this.methods = data.methods;
        this.version = data.version;
    }
}

class ContractMethod {
    constructor(data = {}) {
        this.name = data.name;
        this.signature = data.signature;
        this.params = data.params;
        this.return_type = data.return_type;
        this.description = data.description;
    }
}

class ContractRegistry {
    constructor(data = {}) {
        this.interfaces = data.interfaces;
        this.implementations = data.implementations;
        this.active_target = data.active_target;
    }
}

function ContractRegistry_new() {
    let registry = new ContractRegistry({ interfaces: {  }, implementations: {  }, active_target: "js" });
registry.interfaces = {
            // ============================================================
            // std.io - Input/Output operations
            // ============================================================
            'std.io': {
                name: 'std.io',
                category: 'io',
                version: '1.0.0',
                methods: {
                    print: { signature: 'fn print(msg: string)', params: ['msg'], return_type: 'void' },
                    println: { signature: 'fn println(msg: string)', params: ['msg'], return_type: 'void' },
                    input: { signature: 'fn input(prompt: string) -> string', params: ['prompt'], return_type: 'string' },
                    error: { signature: 'fn error(msg: string)', params: ['msg'], return_type: 'void' }
                }
            },
            
            // ============================================================
            // std.fs - File System operations
            // ============================================================
            'std.fs': {
                name: 'std.fs',
                category: 'fs',
                version: '1.0.0',
                methods: {
                    read_file: { signature: 'fn read_file(path: string) -> string', params: ['path'], return_type: 'string' },
                    write_file: { signature: 'fn write_file(path: string, content: string)', params: ['path', 'content'], return_type: 'void' },
                    exists: { signature: 'fn exists(path: string) -> bool', params: ['path'], return_type: 'bool' },
                    delete: { signature: 'fn delete(path: string)', params: ['path'], return_type: 'void' },
                    list_dir: { signature: 'fn list_dir(path: string) -> string[]', params: ['path'], return_type: 'string[]' },
                    mkdir: { signature: 'fn mkdir(path: string)', params: ['path'], return_type: 'void' }
                }
            },
            
            // ============================================================
            // std.http - HTTP Client operations
            // ============================================================
            'std.http': {
                name: 'std.http',
                category: 'http',
                version: '1.0.0',
                methods: {
                    get: { signature: 'fn get(url: string) -> HttpResponse', params: ['url'], return_type: 'HttpResponse' },
                    post: { signature: 'fn post(url: string, body: any) -> HttpResponse', params: ['url', 'body'], return_type: 'HttpResponse' },
                    put: { signature: 'fn put(url: string, body: any) -> HttpResponse', params: ['url', 'body'], return_type: 'HttpResponse' },
                    delete: { signature: 'fn delete(url: string) -> HttpResponse', params: ['url'], return_type: 'HttpResponse' }
                }
            },
            
            // ============================================================
            // std.sql - Database operations
            // ============================================================
            'std.sql': {
                name: 'std.sql',
                category: 'sql',
                version: '1.0.0',
                methods: {
                    connect: { signature: 'fn connect(dsn: string) -> Connection', params: ['dsn'], return_type: 'Connection' },
                    query: { signature: 'fn query(conn: Connection, sql: string) -> Result[]', params: ['conn', 'sql'], return_type: 'Result[]' },
                    execute: { signature: 'fn execute(conn: Connection, sql: string) -> i64', params: ['conn', 'sql'], return_type: 'i64' },
                    close: { signature: 'fn close(conn: Connection)', params: ['conn'], return_type: 'void' }
                }
            },
            
            // ============================================================
            // std.3d - 3D Visual Sandbox
            // ============================================================
            'std.3d': {
                name: 'std.3d',
                category: '3d',
                version: '1.0.0',
                methods: {
                    Scene_new: { signature: 'fn Scene_new() -> Scene', params: [], return_type: 'Scene' },
                    Mesh_create_cube: { signature: 'fn Mesh_create_cube(size: f64) -> Mesh', params: ['size'], return_type: 'Mesh' },
                    Scene_add: { signature: 'fn Scene_add(scene: Scene, mesh: Mesh)', params: ['scene', 'mesh'], return_type: 'void' },
                    Mesh_set_position: { signature: 'fn Mesh_set_position(mesh: Mesh, x: f64, y: f64, z: f64)', params: ['mesh', 'x', 'y', 'z'], return_type: 'void' }
                }
            },

            // ============================================================
            // std.gui - Native App Windowing
            // ============================================================
            'std.gui': {
                name: 'std.gui',
                category: 'gui',
                version: '1.0.0',
                methods: {
                    Window_create: { signature: 'fn Window_create(title: string, width: i32, height: i32) -> Window', params: ['title', 'width', 'height'], return_type: 'Window' },
                    App_run: { signature: 'fn App_run()', params: [], return_type: 'void' }
                }
            },
            
            // ============================================================
            // std.json - JSON operations
            // ============================================================
            'std.json': {
                name: 'std.json',
                category: 'json',
                version: '1.0.0',
                methods: {
                    parse: { signature: 'fn parse(json: string) -> any', params: ['json'], return_type: 'any' },
                    stringify: { signature: 'fn stringify(obj: any) -> string', params: ['obj'], return_type: 'string' }
                }
            },
            
            // ============================================================
            // std.crypto - Cryptography operations
            // ============================================================
            'std.crypto': {
                name: 'std.crypto',
                category: 'crypto',
                version: '1.0.0',
                methods: {
                    hash_sha256: { signature: 'fn hash_sha256(data: string) -> string', params: ['data'], return_type: 'string' },
                    hash_md5: { signature: 'fn hash_md5(data: string) -> string', params: ['data'], return_type: 'string' },
                    random_bytes: { signature: 'fn random_bytes(len: i64) -> string', params: ['len'], return_type: 'string' }
                }
            },
            
            // ============================================================
            // std.time - Time operations
            // ============================================================
            'std.time': {
                name: 'std.time',
                category: 'time',
                version: '1.0.0',
                methods: {
                    now: { signature: 'fn now() -> i64', params: [], return_type: 'i64' },
                    sleep: { signature: 'fn sleep(ms: i64)', params: ['ms'], return_type: 'void' },
                    format: { signature: 'fn format(timestamp: i64, fmt: string) -> string', params: ['timestamp', 'fmt'], return_type: 'string' }
                }
            },
            
            // ============================================================
            // std.gui - Native GUI operations
            // ============================================================
            'std.gui': {
                name: 'std.gui',
                category: 'gui',
                version: '1.0.0',
                methods: {
                    create_window: { signature: 'fn create_window(title: string, width: i64, height: i64) -> Window', params: ['title', 'width', 'height'], return_type: 'Window' },
                    open_webview: { signature: 'fn open_webview(url: string, width: i64, height: i64)', params: ['url', 'width', 'height'], return_type: 'void' },
                    file_dialog: { signature: 'fn file_dialog(title: string, filter: string) -> string', params: ['title', 'filter'], return_type: 'string' },
                    folder_dialog: { signature: 'fn folder_dialog(title: string) -> string', params: ['title'], return_type: 'string' },
                    message_box: { signature: 'fn message_box(title: string, message: string, type: string)', params: ['title', 'message', 'type'], return_type: 'void' },
                    notification: { signature: 'fn notification(title: string, message: string)', params: ['title', 'message'], return_type: 'void' },
                    canvas_create: { signature: 'fn canvas_create(width: i64, height: i64) -> Canvas', params: ['width', 'height'], return_type: 'Canvas' },
                    canvas_draw_rect: { signature: 'fn canvas_draw_rect(canvas: Canvas, x: f64, y: f64, w: f64, h: f64, color: string)', params: ['canvas', 'x', 'y', 'w', 'h', 'color'], return_type: 'void' },
                    canvas_draw_text: { signature: 'fn canvas_draw_text(canvas: Canvas, text: string, x: f64, y: f64, size: i64)', params: ['canvas', 'text', 'x', 'y', 'size'], return_type: 'void' }
                }
            },
            
            // ============================================================
            // std.3d - 3D Graphics operations
            // ============================================================
            'std.3d': {
                name: 'std.3d',
                category: '3d',
                version: '1.0.0',
                methods: {
                    create_scene: { signature: 'fn create_scene(width: i64, height: i64) -> Scene', params: ['width', 'height'], return_type: 'Scene' },
                    add_cube: { signature: 'fn add_cube(scene: Scene, x: f64, y: f64, z: f64, size: f64, color: string) -> Object3D', params: ['scene', 'x', 'y', 'z', 'size', 'color'], return_type: 'Object3D' },
                    add_sphere: { signature: 'fn add_sphere(scene: Scene, x: f64, y: f64, z: f64, radius: f64, color: string) -> Object3D', params: ['scene', 'x', 'y', 'z', 'radius', 'color'], return_type: 'Object3D' },
                    add_plane: { signature: 'fn add_plane(scene: Scene, width: f64, height: f64, color: string) -> Object3D', params: ['scene', 'width', 'height', 'color'], return_type: 'Object3D' },
                    add_light: { signature: 'fn add_light(scene: Scene, type: string, intensity: f64, color: string) -> Light', params: ['scene', 'type', 'intensity', 'color'], return_type: 'Light' },
                    set_camera: { signature: 'fn set_camera(scene: Scene, x: f64, y: f64, z: f64)', params: ['scene', 'x', 'y', 'z'], return_type: 'void' },
                    rotate: { signature: 'fn rotate(obj: Object3D, rx: f64, ry: f64, rz: f64)', params: ['obj', 'rx', 'ry', 'rz'], return_type: 'void' },
                    animate: { signature: 'fn animate(scene: Scene, flow: fn())', params: ['scene', 'flow'], return_type: 'void' },
                    render: { signature: 'fn render(scene: Scene)', params: ['scene'], return_type: 'void' }
                }
            },
            
            // ============================================================
            // std.system - Native OS integration
            // ============================================================
            'std.system': {
                name: 'std.system',
                category: 'system',
                version: '1.0.0',
                methods: {
                    // Platform detection
                    get_platform: { signature: 'fn get_platform() -> string', params: [], return_type: 'string' },
                    get_arch: { signature: 'fn get_arch() -> string', params: [], return_type: 'string' },
                    get_home_dir: { signature: 'fn get_home_dir() -> string', params: [], return_type: 'string' },
                    get_temp_dir: { signature: 'fn get_temp_dir() -> string', params: [], return_type: 'string' },
                    
                    // Process control
                    exec: { signature: 'fn exec(command: string) -> string', params: ['command'], return_type: 'string' },
                    exec_async: { signature: 'fn exec_async(command: string) -> Process', params: ['command'], return_type: 'Process' },
                    exit: { signature: 'fn exit(code: i64)', params: ['code'], return_type: 'void' },
                    
                    // Environment
                    get_env: { signature: 'fn get_env(name: string) -> string', params: ['name'], return_type: 'string' },
                    set_env: { signature: 'fn set_env(name: string, value: string)', params: ['name', 'value'], return_type: 'void' },
                    
                    // Desktop integration
                    notify: { signature: 'fn notify(title: string, body: string, icon: string)', params: ['title', 'body', 'icon'], return_type: 'void' },
                    tray_create: { signature: 'fn tray_create(icon: string, tooltip: string) -> Tray', params: ['icon', 'tooltip'], return_type: 'Tray' },
                    tray_set_menu: { signature: 'fn tray_set_menu(tray: Tray, items: any)', params: ['tray', 'items'], return_type: 'void' },
                    
                    // Clipboard
                    clipboard_read: { signature: 'fn clipboard_read() -> string', params: [], return_type: 'string' },
                    clipboard_write: { signature: 'fn clipboard_write(text: string)', params: ['text'], return_type: 'void' },
                    
                    // Path manipulation
                    path_join: { signature: 'fn path_join(parts: any) -> string', params: ['parts'], return_type: 'string' },
                    path_resolve: { signature: 'fn path_resolve(path: string) -> string', params: ['path'], return_type: 'string' },
                    path_dirname: { signature: 'fn path_dirname(path: string) -> string', params: ['path'], return_type: 'string' },
                    path_basename: { signature: 'fn path_basename(path: string) -> string', params: ['path'], return_type: 'string' }
                }
            }
        };
        
        // Define target-specific implementations
        registry.implementations = {
            // ============================================================
            // JAVASCRIPT IMPLEMENTATIONS
            // ============================================================
            js: {
                'std.io.print': 'console.log({0})',
                'std.io.println': 'console.log({0})',
                'std.io.input': 'require("readline-sync").question({0})',
                'std.io.error': 'console.error({0})',
                
                'std.fs.read_file': 'require("fs").readFileSync({0}, "utf-8")',
                'std.fs.write_file': 'require("fs").writeFileSync({0}, {1})',
                'std.fs.exists': 'require("fs").existsSync({0})',
                'std.fs.delete': 'require("fs").unlinkSync({0})',
                'std.fs.list_dir': 'require("fs").readdirSync({0})',
                'std.fs.mkdir': 'require("fs").mkdirSync({0}, { recursive: true })',
                
                'std.http.get': 'await fetch({0}).then(r => r.json())',
                'std.http.post': 'await fetch({0}, { method: "POST", body: JSON.stringify({1}) }).then(r => r.json())',
                'std.http.put': 'await fetch({0}, { method: "PUT", body: JSON.stringify({1}) }).then(r => r.json())',
                'std.http.delete': 'await fetch({0}, { method: "DELETE" }).then(r => r.json())',
                
                'std.json.parse': 'JSON.parse({0})',
                'std.json.stringify': 'JSON.stringify({0})',
                
                'std.crypto.hash_sha256': 'require("crypto").createHash("sha256").update({0}).digest("hex")',
                'std.crypto.hash_md5': 'require("crypto").createHash("md5").update({0}).digest("hex")',
                'std.crypto.random_bytes': 'require("crypto").randomBytes({0}).toString("hex")',
                
                'std.time.now': 'Date.now()',
                'std.time.sleep': 'await new Promise(r => setTimeout(r, {0}))',
                'std.time.format': 'new Date({0}).toLocaleString()',
                
                'std.gui.create_window': '(console.log("[gui] Window not supported in Node.js"), null)',
                'std.gui.open_webview': 'require("open")({0})',
                'std.gui.file_dialog': '(console.log("[gui] File dialog not supported in Node.js"), "")',
                'std.gui.folder_dialog': '(console.log("[gui] Folder dialog not supported in Node.js"), "")',
                'std.gui.message_box': 'console.log("[" + {0} + "] " + {1})',
                'std.gui.notification': 'console.log("├░┼©ÔÇØÔÇØ " + {0} + ": " + {1})',
                'std.gui.canvas_create': 'document.createElement("canvas")',
                'std.gui.canvas_draw_rect': '{0}.getContext("2d").fillRect({1}, {2}, {3}, {4})',
                'std.gui.canvas_draw_text': '{0}.getContext("2d").fillText({1}, {2}, {3})',
                
                'std.3d.create_scene': 'new THREE.Scene()',
                'std.3d.add_cube': '(() => { const g = new THREE.BoxGeometry({3}, {3}, {3}); const m = new THREE.MeshStandardMaterial({color: {4}}); const c = new THREE.Mesh(g, m); c.position.set({0}, {1}, {2}); {5}.add(c); return c; })()',
                'std.3d.add_sphere': '(() => { const g = new THREE.SphereGeometry({3}); const m = new THREE.MeshStandardMaterial({color: {4}}); const s = new THREE.Mesh(g, m); s.position.set({0}, {1}, {2}); {5}.add(s); return s; })()',
                'std.3d.add_plane': '(() => { const g = new THREE.PlaneGeometry({0}, {1}); const m = new THREE.MeshStandardMaterial({color: {2}}); const p = new THREE.Mesh(g, m); return p; })()',
                'std.3d.add_light': '(() => { const l = new THREE.DirectionalLight({2}, {1}); {0}.add(l); return l; })()',
                'std.3d.set_camera': 'camera.position.set({1}, {2}, {3})',
                'std.3d.rotate': '{0}.rotation.set({1}, {2}, {3})',
                'std.3d.animate': 'requestAnimationFrame(() => { {1}(); renderer.render({0}, camera); })',
                'std.3d.render': 'renderer.render({0}, camera)',
                
                'std.system.get_platform': 'process.platform',
                'std.system.get_arch': 'process.arch',
                'std.system.get_home_dir': 'require("os").homedir()',
                'std.system.get_temp_dir': 'require("os").tmpdir()',
                'std.system.exec': 'require("child_process").execSync({0}, { encoding: "utf-8" })',
                'std.system.exec_async': 'require("child_process").spawn({0}, { shell: true })',
                'std.system.exit': 'process.exit({0})',
                'std.system.get_env': 'process.env[{0}] || ""',
                'std.system.set_env': 'process.env[{0}] = {1}',
                'std.system.notify': 'console.log("├░┼©ÔÇØÔÇØ " + {0} + ": " + {1})',
                'std.system.clipboard_read': '""',
                'std.system.clipboard_write': 'console.log("[clipboard] " + {0})',
                'std.system.path_join': 'require("path").join(...{0})',
                'std.system.path_resolve': 'require("path").resolve({0})',
                'std.system.path_dirname': 'require("path").dirname({0})',
                'std.system.path_basename': 'require("path").basename({0})'
            },
            
            // ============================================================
            // PYTHON IMPLEMENTATIONS
            // ============================================================
            python: {
                'std.io.print': 'print({0})',
                'std.io.println': 'print({0})',
                'std.io.input': 'input({0})',
                'std.io.error': 'print({0}, file=sys.stderr)',
                
                'std.fs.read_file': 'open({0}).read()',
                'std.fs.write_file': 'open({0}, "w").write({1})',
                'std.fs.exists': 'os.path.exists({0})',
                'std.fs.delete': 'os.remove({0})',
                'std.fs.list_dir': 'os.listdir({0})',
                'std.fs.mkdir': 'os.makedirs({0}, exist_ok=True)',
                
                'std.http.get': 'requests.get({0}).json()',
                'std.http.post': 'requests.post({0}, json={1}).json()',
                'std.http.put': 'requests.put({0}, json={1}).json()',
                'std.http.delete': 'requests.delete({0}).json()',
                
                'std.json.parse': 'json.loads({0})',
                'std.json.stringify': 'json.dumps({0})',
                
                'std.crypto.hash_sha256': 'hashlib.sha256({0}.encode()).hexdigest()',
                'std.crypto.hash_md5': 'hashlib.md5({0}.encode()).hexdigest()',
                'std.crypto.random_bytes': 'secrets.token_hex({0})',
                
                'std.time.now': 'int(time.time() * 1000)',
                'std.time.sleep': 'time.sleep({0} / 1000)',
                'std.time.format': 'datetime.fromtimestamp({0} / 1000).strftime({1})',
                
                'std.gui.create_window': 'webview.create_window({0}, width={1}, height={2})',
                'std.gui.open_webview': 'webbrowser.open({0})',
                'std.gui.file_dialog': 'tkinter.filedialog.askopenfilename(title={0}, filetypes={1})',
                'std.gui.folder_dialog': 'tkinter.filedialog.askdirectory(title={0})',
                'std.gui.message_box': 'tkinter.messagebox.showinfo({0}, {1})',
                'std.gui.notification': 'plyer.notification.notify(title={0}, message={1})'
            },
            
            // ============================================================
            // C NATIVE IMPLEMENTATIONS
            // ============================================================
            c_native: {
                'std.io.print': 'printf("%s", {0})',
                'std.io.println': 'printf("%s\\n", {0})',
                'std.io.input': 'fgets(buffer, sizeof(buffer), stdin)',
                'std.io.error': 'fprintf(stderr, "%s\\n", {0})',
                
                'std.fs.read_file': 'omni_read_file({0})',
                'std.fs.write_file': 'omni_write_file({0}, {1})',
                'std.fs.exists': 'access({0}, F_OK) == 0',
                'std.fs.delete': 'remove({0})',
                'std.fs.list_dir': 'omni_list_dir({0})',
                'std.fs.mkdir': 'mkdir({0}, 0755)',
                
                'std.http.get': 'curl_get({0})',
                'std.http.post': 'curl_post({0}, {1})',
                'std.http.put': 'curl_put({0}, {1})',
                'std.http.delete': 'curl_delete({0})',
                
                'std.json.parse': 'cJSON_Parse({0})',
                'std.json.stringify': 'cJSON_Print({0})',
                
                'std.crypto.hash_sha256': 'openssl_sha256({0})',
                'std.crypto.hash_md5': 'openssl_md5({0})',
                'std.crypto.random_bytes': 'omni_random_bytes({0})',
                
                'std.time.now': '(long long)(time(NULL) * 1000)',
                'std.time.sleep': 'usleep({0} * 1000)',
                'std.time.format': 'strftime(buffer, sizeof(buffer), {1}, localtime(&{0}))',
                
                'std.gui.create_window': 'webview_create({1}, {2}, {0})',
                'std.gui.open_webview': 'webview_navigate(wv, {0})',
                'std.gui.file_dialog': 'nfd_open_dialog({0}, {1})',
                'std.gui.folder_dialog': 'nfd_pick_folder({0})',
                'std.gui.message_box': 'MessageBox(NULL, {1}, {0}, MB_OK)',
                'std.gui.notification': 'omni_notify({0}, {1})'
            },
            
            // ============================================================
            // LUA IMPLEMENTATIONS
            // ============================================================
            lua: {
                'std.io.print': 'print({0})',
                'std.io.println': 'print({0})',
                'std.io.input': 'io.read()',
                'std.io.error': 'io.stderr:write({0})',
                
                'std.fs.read_file': 'io.open({0}, "r"):read("*a")',
                'std.fs.write_file': 'local f = io.open({0}, "w"); f:write({1}); f:close()',
                'std.fs.exists': 'io.open({0}, "r") ~= nil',
                'std.fs.delete': 'os.remove({0})',
                
                'std.json.parse': 'cjson.decode({0})',
                'std.json.stringify': 'cjson.encode({0})',
                
                'std.time.now': 'os.time() * 1000',
                'std.time.sleep': 'os.execute("sleep " .. ({0} / 1000))'
            }
        };
    return registry;
}

function ContractRegistry_set_target(self, target) {
self.active_target = target;
        console.log("[contract] Active target: " + target);
}

function ContractRegistry_resolve(self, contract_path, args) {
    let result = "";
const impl = self.implementations[self.active_target];
        if (!impl) {
            result = "/* UNKNOWN TARGET: " + self.active_target + " */";
            return;
        }
        
        let template = impl[contract_path];
        if (!template) {
            // Fallback to JS implementation
            template = self.implementations['js'][contract_path];
            if (!template) {
                result = "/* UNIMPLEMENTED: " + contract_path + " */";
                return;
            }
        }
        
        // Replace placeholders with arguments
        result = template;
        for (let i = 0; i < args.length; i++) {
            result = result.replace(new RegExp('\\{' + i + '\\}', 'g'), args[i]);
        }
    return result;
}

function ContractRegistry_list_interfaces(self) {
console.log("\n├óÔÇØ┼Æ├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØ┬É");
        console.log("├óÔÇØÔÇÜ              CANONICAL INTERFACES (Hollow Core)             ├óÔÇØÔÇÜ");
        console.log("├óÔÇØ┼ô├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØ┬ñ");
        
        for (const [name, iface] of Object.entries(self.interfaces)) {
            const methodCount = Object.keys(iface.methods).length;
            console.log("├óÔÇØÔÇÜ " + name.padEnd(20) + " ├óÔÇØÔÇÜ " + 
                        iface.category.padEnd(10) + " ├óÔÇØÔÇÜ " +
                        (methodCount + " methods").padEnd(15) + " ├óÔÇØÔÇÜ");
        }
        
        console.log("├óÔÇØÔÇØ├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØÔé¼├óÔÇØ╦£");
}

function ContractRegistry_verify_target(self, target) {
    let is_complete = true;
    let missing = 0;
const impl = self.implementations[target];
        if (!impl) {
            CLI_error("Target '" + target + "' has no implementations");
            is_complete = false;
            return;
        }
        
        // Check all interfaces
        for (const [ifaceName, iface] of Object.entries(self.interfaces)) {
            for (const methodName of Object.keys(iface.methods)) {
                const contractPath = ifaceName + '.' + methodName;
                if (!impl[contractPath]) {
                    missing++;
                }
            }
        }
        
        if (missing > 0) {
            CLI_warning("Target '" + target + "' has " + missing + " missing implementations");
            is_complete = false;
        }
    return is_complete;
}

let GLOBAL_CONTRACTS = ContractRegistry_new();


// Auto-exports
if (typeof exports !== 'undefined') {
    exports.ContractRegistry_new = ContractRegistry_new;
    exports.ContractRegistry_set_target = ContractRegistry_set_target;
    exports.ContractRegistry_resolve = ContractRegistry_resolve;
    exports.ContractRegistry_list_interfaces = ContractRegistry_list_interfaces;
    exports.ContractRegistry_verify_target = ContractRegistry_verify_target;
    exports.CanonicalInterface = CanonicalInterface;
    exports.ContractMethod = ContractMethod;
    exports.ContractRegistry = ContractRegistry;
    exports.GLOBAL_CONTRACTS = GLOBAL_CONTRACTS;
}
