// Generated by Omni Compiler
'use strict';


let TOKEN_EOF = 0;

let TOKEN_ILLEGAL = 1;

let TOKEN_IDENTIFIER = 10;

let TOKEN_INT = 11;

let TOKEN_STRING = 12;

let TOKEN_ASSIGN = 20;

let TOKEN_PLUS = 21;

let TOKEN_MINUS = 22;

let TOKEN_BANG = 23;

let TOKEN_ASTERISK = 24;

let TOKEN_SLASH = 25;

let TOKEN_LT = 26;

let TOKEN_GT = 27;

let TOKEN_EQ = 28;

let TOKEN_NOT_EQ = 29;

let TOKEN_COLON = 30;

let TOKEN_DOT = 31;

let TOKEN_AND = 32;

let TOKEN_OR = 33;

let TOKEN_LE = 34;

let TOKEN_GE = 35;

let TOKEN_COMMA = 40;

let TOKEN_SEMICOLON = 41;

let TOKEN_LPAREN = 42;

let TOKEN_RPAREN = 43;

let TOKEN_LBRACE = 44;

let TOKEN_RBRACE = 45;

let TOKEN_LBRACKET = 46;

let TOKEN_RBRACKET = 47;

let TOKEN_FN = 60;

let TOKEN_LET = 61;

let TOKEN_TRUE = 62;

let TOKEN_FALSE = 63;

let TOKEN_IF = 64;

let TOKEN_ELSE = 65;

let TOKEN_RETURN = 66;

let TOKEN_WHILE = 67;

let TOKEN_STRUCT = 70;

let TOKEN_NATIVE = 80;

let TOKEN_IMPORT = 90;

let TOKEN_PACKAGE = 91;

let TOKEN_EXPORT = 92;

let TOKEN_AT = 95;

class Token {
    constructor(data = {}) {
        this.kind = data.kind;
        this.lexeme = data.lexeme;
        this.line = data.line;
        this.start = data.start;
        this.end = data.end;
    }
}

function new_token(kind, lexeme, line) {
    return new Token({ kind: kind, lexeme: lexeme, line: line, start: 0, end: 0 });
}



// Auto-exports
if (typeof exports !== 'undefined') {
    exports.new_token = new_token;
    exports.Token = Token;
    exports.TOKEN_EOF = TOKEN_EOF;
    exports.TOKEN_ILLEGAL = TOKEN_ILLEGAL;
    exports.TOKEN_IDENTIFIER = TOKEN_IDENTIFIER;
    exports.TOKEN_INT = TOKEN_INT;
    exports.TOKEN_STRING = TOKEN_STRING;
    exports.TOKEN_ASSIGN = TOKEN_ASSIGN;
    exports.TOKEN_PLUS = TOKEN_PLUS;
    exports.TOKEN_MINUS = TOKEN_MINUS;
    exports.TOKEN_BANG = TOKEN_BANG;
    exports.TOKEN_ASTERISK = TOKEN_ASTERISK;
    exports.TOKEN_SLASH = TOKEN_SLASH;
    exports.TOKEN_LT = TOKEN_LT;
    exports.TOKEN_GT = TOKEN_GT;
    exports.TOKEN_EQ = TOKEN_EQ;
    exports.TOKEN_NOT_EQ = TOKEN_NOT_EQ;
    exports.TOKEN_COLON = TOKEN_COLON;
    exports.TOKEN_DOT = TOKEN_DOT;
    exports.TOKEN_AND = TOKEN_AND;
    exports.TOKEN_OR = TOKEN_OR;
    exports.TOKEN_LE = TOKEN_LE;
    exports.TOKEN_GE = TOKEN_GE;
    exports.TOKEN_COMMA = TOKEN_COMMA;
    exports.TOKEN_SEMICOLON = TOKEN_SEMICOLON;
    exports.TOKEN_LPAREN = TOKEN_LPAREN;
    exports.TOKEN_RPAREN = TOKEN_RPAREN;
    exports.TOKEN_LBRACE = TOKEN_LBRACE;
    exports.TOKEN_RBRACE = TOKEN_RBRACE;
    exports.TOKEN_LBRACKET = TOKEN_LBRACKET;
    exports.TOKEN_RBRACKET = TOKEN_RBRACKET;
    exports.TOKEN_FN = TOKEN_FN;
    exports.TOKEN_LET = TOKEN_LET;
    exports.TOKEN_TRUE = TOKEN_TRUE;
    exports.TOKEN_FALSE = TOKEN_FALSE;
    exports.TOKEN_IF = TOKEN_IF;
    exports.TOKEN_ELSE = TOKEN_ELSE;
    exports.TOKEN_RETURN = TOKEN_RETURN;
    exports.TOKEN_WHILE = TOKEN_WHILE;
    exports.TOKEN_STRUCT = TOKEN_STRUCT;
    exports.TOKEN_NATIVE = TOKEN_NATIVE;
    exports.TOKEN_IMPORT = TOKEN_IMPORT;
    exports.TOKEN_PACKAGE = TOKEN_PACKAGE;
    exports.TOKEN_EXPORT = TOKEN_EXPORT;
    exports.TOKEN_AT = TOKEN_AT;
}
