BlockLoop: 61 (let)
BlockLoop: 60 (fn)
BlockLoop: 61 (let)
BlockLoop: 67 (while)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_EOF)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 64 (if)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 64 (if)
BlockLoop: 29 (!=)
BlockLoop: 11 (0)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 80 (native)
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 11 (95)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 61 (let)
BlockLoop: 67 (while)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 11 (95)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 80 (native)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (lexeme)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 10 (TOKEN_SEMICOLON)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 67 (while)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_SEMICOLON)
BlockLoop: 32 (&&)
BlockLoop: 10 (p)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_EOF)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (lexeme)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 11 (30)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 10 (TOKEN_SEMICOLON)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (lexeme)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 67 (while)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_RPAREN)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 80 (native)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 11 (30)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (lexeme)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 67 (while)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_RBRACE)
BlockLoop: 32 (&&)
BlockLoop: 10 (p)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_EOF)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 10 (TOKEN_RBRACE)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (break)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 10 (TOKEN_STRING)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (lang)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (lexeme)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 10 (TOKEN_LBRACE)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 67 (while)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_RBRACE)
BlockLoop: 32 (&&)
BlockLoop: 10 (p)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_EOF)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 80 (native)
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 80 (native)
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 10 (TOKEN_SEMICOLON)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 66 (return)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 10 (TOKEN_ASSIGN)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 66 (return)
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 67 (while)
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 64 (if)
BlockLoop: 32 (&&)
BlockLoop: 10 (k)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_NOT_EQ)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (break)
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (lexeme)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 10 (left)
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 67 (while)
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 64 (if)
BlockLoop: 32 (&&)
BlockLoop: 10 (k)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_GT)
BlockLoop: 32 (&&)
BlockLoop: 10 (k)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_LE)
BlockLoop: 32 (&&)
BlockLoop: 10 (k)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_GE)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (break)
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (lexeme)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 10 (left)
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 67 (while)
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 64 (if)
BlockLoop: 32 (&&)
BlockLoop: 10 (k)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_OR)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (break)
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (lexeme)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 10 (left)
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 67 (while)
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 64 (if)
BlockLoop: 32 (&&)
BlockLoop: 10 (k)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_MINUS)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (break)
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (lexeme)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 10 (left)
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 67 (while)
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 64 (if)
BlockLoop: 32 (&&)
BlockLoop: 10 (k)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_SLASH)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (break)
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (lexeme)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 10 (left)
BlockLoop: 61 (let)
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 10 (TOKEN_INT)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 61 (let)
BlockLoop: 80 (native)
BlockLoop: 10 (node)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 11 (31)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (lexeme)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 10 (node)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 10 (TOKEN_ELSE)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 10 (TOKEN_IF)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 80 (native)
BlockLoop: 10 (alt)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 42 (()
BlockLoop: 66 (return)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (lexeme)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 61 (let)
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 10 (TOKEN_LPAREN)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 67 (while)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_RPAREN)
BlockLoop: 32 (&&)
BlockLoop: 10 (p)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 29 (!=)
BlockLoop: 10 (TOKEN_EOF)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 61 (let)
BlockLoop: 61 (let)
BlockLoop: 61 (let)
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 10 (TOKEN_IDENTIFIER)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 64 (if)
BlockLoop: 31 (.)
BlockLoop: 10 (kind)
BlockLoop: 28 (==)
BlockLoop: 10 (TOKEN_ASSIGN)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 10 (is_named)
BlockLoop: 10 (arg_name)
BlockLoop: 31 (.)
BlockLoop: 10 (cur_token)
BlockLoop: 31 (.)
BlockLoop: 10 (lexeme)
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 10 (Parser_next_token)
BlockLoop: 42 (()
BlockLoop: 10 (arg_val)
BlockLoop: 42 (()
BlockLoop: 10 (arg_val)
BlockLoop: 42 (()
const lexer = require("./lexer.js");
const token = require("./token.js");
const ast = require("./ast.js");
class Parser {
    constructor(data = {}) {
        this.lexer = data.lexer;
        this.cur_token = data.cur_token;
        this.peek_token = data.peek_token;
    }
}
function new_parser(l) {
    const p = new Parser({ lexer: l, cur_token: new_token, (: null, : 0, ): peek_token, :: 0, : 0, ): null, Parser_next_token: p, ): Parser_next_token, (: null, ;: p, ;: null, Parser_next_token: p, :: null, {: null, cur_token: p, .: null, p: peek_token = Lexer_next_token, (: null, lexer: null });
    function Parser_parse_program(p) {
    const stmts = [];
    while (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_EOF;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    const stmt = Parser_parse_statement;
    p;
    if (stmt) {
    0;
}
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    if (stmt) {
    kind;
}
    // Unknown stmt kind: 0
    0;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
     stmts.push(stmt); 
}
}
// Unknown stmt kind: undefined
return new Program({ statements: stmts });
// Unknown stmt kind: undefined
function Parser_parse_statement(p) {
    if (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    95;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    const decorators = [];
    while (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    95;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
     decorators.push(Parser_parse_decorator(p)); 
}
const stmt = Parser_parse_statement;
 if (stmt) stmt.decorators = decorators; 
return stmt;
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
const stmt = Parser_parse_statement;
 if (stmt) stmt.is_exported = true; 
return stmt;
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
return Parser_parse_package;
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
return Parser_parse_import;
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
return 0;
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
return Parser_parse_if;
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
return Parser_parse_while;
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
return Parser_parse_let;
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
return Parser_parse_fn;
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
return Parser_parse_struct;
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
return Parser_parse_return;
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
return Parser_parse_native_block;
// Unknown stmt kind: undefined
return Parser_parse_expr_stmt;
// Unknown stmt kind: undefined
function Parser_parse_import(p) {
    Parser_next_token;
    p;
    const path = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    lexeme;
    Parser_next_token;
    p;
    if (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_SEMICOLON;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    Parser_next_token;
    p;
}
return new ImportDecl({ kind: NODE_IMPORT, path: path });
// Unknown stmt kind: undefined
function Parser_parse_package(p) {
    Parser_next_token;
    p;
    while (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_SEMICOLON;
    // Unknown stmt kind: 0
    p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_EOF;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    Parser_next_token;
    p;
}
if (p) {
    cur_token;
}
// Unknown stmt kind: undefined
return 0;
// Unknown stmt kind: undefined
function Parser_parse_let(p) {
    Parser_next_token;
    p;
    const name = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    lexeme;
    Parser_next_token;
    p;
    if (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    30;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    Parser_next_token;
    p;
    Parser_next_token;
    p;
}
const val = Parser_parse_expression;
if (p) {
    cur_token;
}
// Unknown stmt kind: undefined
return new LetStmt({ kind: NODE_LET, name: name, value: val, is_exported: false });
// Unknown stmt kind: undefined
function Parser_parse_return(p) {
    Parser_next_token;
    p;
    const val = Parser_parse_expression;
    p;
    if (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_SEMICOLON;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    Parser_next_token;
    p;
}
return new ReturnStmt({ kind: NODE_RETURN, value: val });
// Unknown stmt kind: undefined
function Parser_parse_fn(p) {
    Parser_next_token;
    p;
    const name = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    lexeme;
    Parser_next_token;
    p;
    Parser_next_token;
    p;
    const params = [];
    while (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_RPAREN;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
     params.push(p.cur_token.lexeme); 
    Parser_next_token;
    p;
    if (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    30;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    Parser_next_token;
    p;
    Parser_next_token;
    p;
}
if (p) {
    cur_token;
}
// Unknown stmt kind: undefined
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
// Unknown stmt kind: undefined
const body = Parser_parse_block;
return new FunctionDecl({ kind: NODE_FUNCTION, name: name, params: params, body: body, is_exported: false, decorators: [] });
// Unknown stmt kind: undefined
function Parser_parse_struct(p) {
    Parser_next_token;
    p;
    const name = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    lexeme;
    Parser_next_token;
    p;
    Parser_next_token;
    p;
    const fields = [];
    while (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_RBRACE;
    // Unknown stmt kind: 0
    p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_EOF;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    if (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_RBRACE;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    break;
}
const field_name = p;
const field_type = p;
const f = new_struct_field;
 fields.push(f); 
if (p) {
    cur_token;
}
// Unknown stmt kind: undefined
// Unknown stmt kind: undefined
return new StructDecl({ kind: NODE_STRUCT, name: name, fields: fields, is_exported: false, decorators: [] });
// Unknown stmt kind: undefined
function Parser_parse_native_block(p) {
    Parser_next_token;
    p;
    const lang = "js";
    if (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_STRING;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    lang = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    lexeme;
    Parser_next_token;
    p;
}
if (p) {
    cur_token;
}
return new NativeStmt({ kind: 0, lang: "", code: "" });
// Unknown stmt kind: undefined
const start_pos = p;
const code = "";
const end_pos = 0;

        const input = p.lexer.input;
        let pos = Number(start_pos) + 1;
        let brace_count = 1;
        let start_extract = pos;
        
        while (pos < input.length && brace_count > 0) {
            const char = input[pos];
            if (char === '{') brace_count++;
            if (char === '}') brace_count--;
            pos++;
        }
        
        end_pos = pos;
        if (brace_count == 0) {
            code = input.substring(start_extract, pos - 1);
        }
        p.lexer.read_position = end_pos;
        Lexer_read_char(p.lexer);
        p.cur_token = Lexer_next_token(p.lexer);
        p.peek_token = Lexer_next_token(p.lexer);
    
return new NativeStmt({ kind: NODE_NATIVE, lang: lang, code: code });
// Unknown stmt kind: undefined
function Parser_parse_block(p) {
    const stmts = [];
    if (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_LBRACE;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    Parser_next_token;
    p;
    while (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_RBRACE;
    // Unknown stmt kind: 0
    p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_EOF;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
     console.log("BlockLoop: " + p.cur_token.kind + " (" + p.cur_token.lexeme + ")"); 
    const stmt = Parser_parse_statement;
    p;
     stmts.push(stmt); 
}
// Unknown stmt kind: undefined
const stmt = Parser_parse_statement;
 stmts.push(stmt); 
// Unknown stmt kind: undefined
return new Block({ kind: NODE_BLOCK, statements: stmts });
// Unknown stmt kind: undefined
function Parser_parse_expr_stmt(p) {
    const expr = Parser_parse_expression;
    p;
    if (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_SEMICOLON;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    Parser_next_token;
    p;
}
return new ExpressionStmt({ kind: 0, expr: expr });
// Unknown stmt kind: undefined
function Parser_parse_expression(p) {
    return Parser_parse_assignment;
    p;
}
function Parser_parse_assignment(p) {
    const left = Parser_parse_logic;
    p;
    if (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_ASSIGN;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    Parser_next_token;
    p;
    const right = Parser_parse_assignment;
    p;
    return new AssignmentExpr({ kind: NODE_ASSIGNMENT, left: left, right: right });
}
return left;
// Unknown stmt kind: undefined
function Parser_parse_equality(p) {
    const left = Parser_parse_relational;
    p;
    while (true) {
    const k = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    kind;
    if (k) {
    TOKEN_EQ;
}
    // Unknown stmt kind: 0
    k;
    // Unknown stmt kind: 0
    TOKEN_NOT_EQ;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    break;
}
    const op = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    lexeme;
    Parser_next_token;
    p;
    const right = Parser_parse_relational;
    p;
    left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
}
return left;
// Unknown stmt kind: undefined
function Parser_parse_relational(p) {
    const left = Parser_parse_term;
    p;
    while (true) {
    const k = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    kind;
    if (k) {
    TOKEN_LT;
}
    // Unknown stmt kind: 0
    k;
    // Unknown stmt kind: 0
    TOKEN_GT;
    // Unknown stmt kind: 0
    k;
    // Unknown stmt kind: 0
    TOKEN_LE;
    // Unknown stmt kind: 0
    k;
    // Unknown stmt kind: 0
    TOKEN_GE;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    break;
}
    const op = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    lexeme;
    Parser_next_token;
    p;
    const right = Parser_parse_term;
    p;
    left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
}
return left;
// Unknown stmt kind: undefined
function Parser_parse_logic(p) {
    const left = Parser_parse_equality;
    p;
    while (true) {
    const k = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    kind;
    if (k) {
    TOKEN_AND;
}
    // Unknown stmt kind: 0
    k;
    // Unknown stmt kind: 0
    TOKEN_OR;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    break;
}
    const op = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    lexeme;
    Parser_next_token;
    p;
    const right = Parser_parse_equality;
    p;
    left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
}
return left;
// Unknown stmt kind: undefined
function Parser_parse_term(p) {
    const left = Parser_parse_multiplication;
    p;
    while (true) {
    const k = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    kind;
    if (k) {
    TOKEN_PLUS;
}
    // Unknown stmt kind: 0
    k;
    // Unknown stmt kind: 0
    TOKEN_MINUS;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    break;
}
    const op = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    lexeme;
    Parser_next_token;
    p;
    const right = Parser_parse_multiplication;
    p;
    left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
}
return left;
// Unknown stmt kind: undefined
function Parser_parse_multiplication(p) {
    const left = Parser_parse_factor;
    p;
    while (true) {
    const k = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    kind;
    if (k) {
    TOKEN_ASTERISK;
}
    // Unknown stmt kind: 0
    k;
    // Unknown stmt kind: 0
    TOKEN_SLASH;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    break;
}
    const op = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    lexeme;
    Parser_next_token;
    p;
    const right = Parser_parse_factor;
    p;
    left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
}
return left;
// Unknown stmt kind: undefined
function Parser_parse_factor(p) {
    const node = 0;
    if (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_INT;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    const val = 0;
     val = parseInt(p.cur_token.lexeme); 
    node = new IntegerLiteral({ kind: NODE_LITERAL, value: val });
    Parser_next_token;
    p;
}
if (p) {
    cur_token;
}
const name = p;
if (p) {
    cur_token;
}
const init_fields = [];
while (p) {
    cur_token;
}
const field_name = p;
const field_val = Parser_parse_expression;
const field = new StructInitField({ name: field_name, value: field_val });
 init_fields.push(field); 
if (p) {
    cur_token;
}
// Unknown stmt kind: undefined
// Unknown stmt kind: undefined
// Unknown stmt kind: undefined
// Unknown stmt kind: undefined
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
const str_val = p;
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
// Unknown stmt kind: undefined
if (p) {
    cur_token;
}
const elements = [];
while (p) {
    cur_token;
}
 elements.push(Parser_parse_expression(p)); 
if (p) {
    cur_token;
}
// Unknown stmt kind: undefined
// Unknown stmt kind: undefined
 node = { kind: NODE_ARRAY, elements: elements }; 
// Unknown stmt kind: undefined
 console.error("Unexpected token in expression: Kind " + p.cur_token.kind + ", Lexeme: " + p.cur_token.lexeme); 
return 0;
// Unknown stmt kind: undefined
const continue_loop = true;
while (continue_loop) {
    if (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    31;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    Parser_next_token;
    p;
    const prop = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    lexeme;
    Parser_next_token;
    p;
    node = new MemberExpr({ kind: NODE_MEMBER, target: node, property: prop });
}
if (p) {
    cur_token;
}
const args = [];
while (p) {
    cur_token;
}
 args.push(Parser_parse_expression(p)); 
if (p) {
    cur_token;
}
// Unknown stmt kind: undefined
// Unknown stmt kind: undefined
// Unknown stmt kind: undefined
// Unknown stmt kind: undefined
// Unknown stmt kind: undefined
return node;
// Unknown stmt kind: undefined
function Parser_parse_if(p) {
    Parser_next_token;
    p;
    const cond = Parser_parse_expression;
    p;
    const cons = Parser_parse_block;
    p;
    const alt = 0;
    if (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_ELSE;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    Parser_next_token;
    p;
    if (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_IF;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    const if_stmt = Parser_parse_if;
    p;
    const stmts = [];
     stmts.push(if_stmt); 
    alt = new Block({ kind: NODE_BLOCK, statements: stmts });
}
// Unknown stmt kind: undefined
// Unknown stmt kind: undefined
return new IfStmt({ kind: NODE_IF, condition: cond, consequence: cons, alternative: alt });
// Unknown stmt kind: undefined
function Parser_parse_while(p) {
    Parser_next_token;
    p;
    const cond = Parser_parse_expression;
    p;
    const body = Parser_parse_block;
    p;
    return new WhileStmt({ kind: NODE_WHILE, condition: cond, body: body });
}
function Parser_parse_decorator(p) {
    Parser_next_token;
    p;
    const name = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    lexeme;
    Parser_next_token;
    p;
    const args = [];
    if (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_LPAREN;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    Parser_next_token;
    p;
    while (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_RPAREN;
    // Unknown stmt kind: 0
    p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_EOF;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    const arg_name = "";
    const arg_val = 0;
    const is_named = false;
    if (p) {
    cur_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_IDENTIFIER;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    if (p) {
    peek_token;
}
    // Unknown stmt kind: 0
    kind;
    // Unknown stmt kind: 0
    TOKEN_ASSIGN;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    is_named = true;
}
// Unknown stmt kind: undefined
if (is_named) {
    arg_name = p;
    // Unknown stmt kind: 0
    cur_token;
    // Unknown stmt kind: 0
    lexeme;
    Parser_next_token;
    p;
    Parser_next_token;
    p;
    arg_val = Parser_parse_expression;
    p;
} else {
    arg_val = Parser_parse_expression;
    p;
}
const field = new StructInitField({ name: arg_name, value: arg_val });
 args.push(field); 
if (p) {
    cur_token;
}
// Unknown stmt kind: undefined
// Unknown stmt kind: undefined
// Unknown stmt kind: undefined
return new Decorator({ name: name, args: args });
// Unknown stmt kind: undefined


// Auto-exports
if (typeof exports !== 'undefined') {
    exports.new_parser = new_parser;
    exports.Parser_next_token = Parser_next_token;
    exports.Parser_parse_program = Parser_parse_program;
    exports.Parser_parse_statement = Parser_parse_statement;
    exports.Parser_parse_import = Parser_parse_import;
    exports.Parser_parse_package = Parser_parse_package;
    exports.Parser_parse_let = Parser_parse_let;
    exports.Parser_parse_return = Parser_parse_return;
    exports.Parser_parse_fn = Parser_parse_fn;
    exports.Parser_parse_struct = Parser_parse_struct;
    exports.Parser_parse_native_block = Parser_parse_native_block;
    exports.Parser_parse_block = Parser_parse_block;
    exports.Parser_parse_expr_stmt = Parser_parse_expr_stmt;
    exports.Parser_parse_expression = Parser_parse_expression;
    exports.Parser_parse_assignment = Parser_parse_assignment;
    exports.Parser_parse_equality = Parser_parse_equality;
    exports.Parser_parse_relational = Parser_parse_relational;
    exports.Parser_parse_logic = Parser_parse_logic;
    exports.Parser_parse_term = Parser_parse_term;
    exports.Parser_parse_multiplication = Parser_parse_multiplication;
    exports.Parser_parse_factor = Parser_parse_factor;
    exports.Parser_parse_if = Parser_parse_if;
    exports.Parser_parse_while = Parser_parse_while;
    exports.Parser_parse_decorator = Parser_parse_decorator;
    exports.Parser = Parser;
}
