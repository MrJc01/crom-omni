// Generated by Omni Compiler
'use strict';

const lexer = require('./lexer.js');
const token = require('./token.js');
const ast = require('./ast.js');

class Parser {
    constructor(data = {}) {
        this.lexer = data.lexer;
        this.cur_token = data.cur_token;
        this.peek_token = data.peek_token;
    }
}

function new_parser(l) {
    const p = new Parser({ lexer: l, cur_token: new_token(0, "", 0), peek_token: new_token(0, "", 0) });
    Parser_next_token(p);
    Parser_next_token(p);
    return p;
}

function Parser_next_token(p) {
    p.cur_token = p.peek_token;
    p.peek_token = Lexer_next_token(p.lexer);
    // if (p.cur_token.line > 0) console.log("Next Token: " + p.cur_token.kind + " (" + p.cur_token.lexeme + ") Line: " + p.cur_token.line);
}

function Parser_parse_program(p) {
    const stmts = [];
    while ((p.cur_token.kind !== TOKEN_EOF)) {
    const stmt = Parser_parse_statement(p);
    if ((stmt.kind !== 0)) {
stmts.push(stmt);
}

}

    return new Program({ statements: stmts });
}

function Parser_parse_statement(p) {
    // console.log("Pars Stmt: " + p.cur_token.kind + " " + p.cur_token.lexeme + " at line " + p.cur_token.line);
    // console.log("TOKEN_FN is: " + TOKEN_FN);

    if (p.cur_token.kind === TOKEN_FN) { // TOKEN_FN
        return Parser_parse_fn(p);
    }

    if (p.cur_token.kind === TOKEN_FN) { // TOKEN_FN
        return Parser_parse_fn(p);
    }

    if ((p.cur_token.kind === 90)) {
    return Parser_parse_import(p);
}

    if ((p.cur_token.kind === TOKEN_LET)) {
    return Parser_parse_let(p);
}

    if ((p.cur_token.kind === TOKEN_FN)) {
    return Parser_parse_fn(p);
}

    if ((p.cur_token.kind === TOKEN_STRUCT)) {
    return Parser_parse_struct(p);
}

    if ((p.cur_token.kind === TOKEN_RETURN)) {
    return Parser_parse_return(p);
}

    if ((p.cur_token.kind === TOKEN_NATIVE)) {
    return Parser_parse_native_block(p);
}

    if (p.cur_token.kind === 67) { // TOKEN_WHILE
        return Parser_parse_while(p);
    }

    return Parser_parse_expr_stmt(p);
}

function Parser_parse_import(p) {
    Parser_next_token(p);
    const path = p.cur_token.lexeme;
    Parser_next_token(p);
    if ((p.cur_token.kind === TOKEN_SEMICOLON)) {
    Parser_next_token(p);
}

    return new ImportDecl({ kind: NODE_IMPORT, path: path });
}

function Parser_parse_let(p) {
    Parser_next_token(p);
    const name = p.cur_token.lexeme;
    Parser_next_token(p);
    if ((p.cur_token.kind === 30)) {
    Parser_next_token(p);
    Parser_next_token(p);
}

    Parser_next_token(p);
    const val = Parser_parse_expression(p);
    if ((p.cur_token.kind === TOKEN_SEMICOLON)) {
    Parser_next_token(p);
}

    return new LetStmt({ kind: NODE_LET, name: name, value: val });
}

function Parser_parse_return(p) {
    Parser_next_token(p);
    const val = Parser_parse_expression(p);
    if ((p.cur_token.kind === TOKEN_SEMICOLON)) {
    Parser_next_token(p);
}

    return new ReturnStmt({ kind: NODE_RETURN, value: val });
}

function Parser_parse_fn(p) {
    Parser_next_token(p);
    const name = p.cur_token.lexeme;
    Parser_next_token(p);
    Parser_next_token(p);
    const params = [];
    while ((p.cur_token.kind !== TOKEN_RPAREN)) {
params.push(p.cur_token.lexeme);
    Parser_next_token(p);
    if ((p.cur_token.kind === 30)) {
    Parser_next_token(p);
    Parser_next_token(p);
}

    if ((p.cur_token.kind === TOKEN_COMMA)) {
    Parser_next_token(p);
}

}

    Parser_next_token(p);
    if ((p.cur_token.lexeme === "-")) {
    Parser_next_token(p);
    Parser_next_token(p);
    Parser_next_token(p);
}

    const body = Parser_parse_block(p);
    return new FunctionDecl({ kind: NODE_FUNCTION, name: name, params: params, body: body });
}

function Parser_parse_struct(p) {
    Parser_next_token(p);
    const name = p.cur_token.lexeme;
    Parser_next_token(p);
    Parser_next_token(p);
    const fields = [];
    while (p.cur_token.kind !== TOKEN_RBRACE && p.cur_token.kind !== TOKEN_EOF) {
    const field_name = p.cur_token.lexeme;
    Parser_next_token(p);
    Parser_next_token(p);
    const field_type = p.cur_token.lexeme;
    Parser_next_token(p);
    const f = new_struct_field(field_name, field_type);
fields.push(f);
    if ((p.cur_token.kind === TOKEN_COMMA)) {
    Parser_next_token(p);
}

}

    Parser_next_token(p); // Consume RBRACE
    return new StructDecl({ kind: NODE_STRUCT, name: name, fields: fields });
}

function Parser_parse_native_block(p) {
    Parser_next_token(p);
    let lang = "js";
    if ((p.cur_token.kind === TOKEN_STRING)) {
    lang = p.cur_token.lexeme;
    Parser_next_token(p);
}

    if ((p.cur_token.kind !== TOKEN_LBRACE)) {
    return new NativeStmt({ kind: 0, lang: "", code: "" });
}

    const start_pos = p.cur_token.start;
    let code = "";
    let end_pos = 0;
const input = p.lexer.input;
        let pos = Number(start_pos) + 1;
        let brace_count = 1;
        let start_extract = pos;
        
        while (pos < input.length && brace_count > 0) {
            const char = input[pos];
            if (char === '{') brace_count++;
            if (char === '}') brace_count--;
            pos++;
        }
        
        end_pos = pos;
        if (brace_count === 0) {
            code = input.substring(start_extract, pos - 1);
        }
    p.lexer.read_position = end_pos;
    Lexer_read_char(p.lexer);
    p.cur_token = Lexer_next_token(p.lexer);
    p.peek_token = Lexer_next_token(p.lexer);
    return new NativeStmt({ kind: NODE_NATIVE, lang: lang, code: code });
}

function Parser_parse_block(p) {
    Parser_next_token(p);
    const stmts = [];
    while (p.cur_token.kind !== TOKEN_RBRACE && p.cur_token.kind !== TOKEN_EOF) {
    const stmt = Parser_parse_statement(p);
stmts.push(stmt);
}

    Parser_next_token(p); // Consume RBRACE
    return new Block({ kind: NODE_BLOCK, statements: stmts });
}

function Parser_parse_expr_stmt(p) {
    const expr = Parser_parse_expression(p);
    if ((p.cur_token.kind === TOKEN_SEMICOLON)) {
    Parser_next_token(p);
}
    return new ExpressionStmt({ kind: 0, expr: expr });
}

function Parser_parse_expression(p) {
    return Parser_parse_logic(p);
}

function Parser_parse_equality(p) {
    let left = Parser_parse_relational(p);
    while (p.cur_token.kind === TOKEN_EQ || p.cur_token.kind === TOKEN_NOT_EQ) {
        const op = p.cur_token.kind;
        Parser_next_token(p);
        const right = Parser_parse_relational(p);
        left = new BinaryExpr({ kind: NODE_BINARY, left: left, operator: op, right: right });
    }
    return left;
}

function Parser_parse_term(p) {
    let left = Parser_parse_factor(p);
    while (p.cur_token.kind === TOKEN_PLUS || p.cur_token.kind === TOKEN_MINUS) {
        const op = p.cur_token.kind;
        Parser_next_token(p);
        const right = Parser_parse_factor(p);
        left = new BinaryExpr({ kind: NODE_BINARY, left: left, operator: op, right: right });
    }
    return left;
}

function Parser_parse_factor(p) {
    let node = 0;
    if ((p.cur_token.kind === TOKEN_INT)) {
    let val = 0;
val = parseInt(p.cur_token.lexeme);
    node = new IntegerLiteral({ kind: NODE_LITERAL, value: val });
    Parser_next_token(p);
}
 else {
    if ((p.cur_token.kind === TOKEN_IDENTIFIER)) {
    const name = p.cur_token.lexeme;
    Parser_next_token(p);
    if ((p.cur_token.kind === TOKEN_LPAREN)) {
    Parser_next_token(p);
    const args = [];
    while ((p.cur_token.kind !== TOKEN_RPAREN)) {
args.push(Parser_parse_expression(p));
    if ((p.cur_token.kind === TOKEN_COMMA)) {
    Parser_next_token(p);
}

}

    Parser_next_token(p);
    node = new CallExpr({ kind: NODE_CALL, function: name, args: args });
}
 else {
    if ((p.cur_token.kind === TOKEN_LBRACE)) {
    // console.log("Entering Struct Init (Check): " + name + " Cur: " + p.cur_token.kind);
    Parser_next_token(p);
    const init_fields = [];
    while (p.cur_token.kind !== TOKEN_RBRACE && p.cur_token.kind !== TOKEN_EOF) {
        const field_name = p.cur_token.lexeme;
        Parser_next_token(p); // eat name
        Parser_next_token(p); // eat colon
        const field_val = Parser_parse_expression(p);
        init_fields.push({ name: field_name, value: field_val });
        if ((p.cur_token.kind === TOKEN_COMMA)) {
            Parser_next_token(p);
        }
    }

    Parser_next_token(p);
node = { kind: NODE_STRUCT_INIT, name: name, fields: init_fields };
}
 else {
    node = new Identifier({ kind: NODE_IDENTIFIER, value: name });
}

}

}
 else {
    if ((p.cur_token.kind === TOKEN_LPAREN)) {
    Parser_next_token(p);
    node = Parser_parse_expression(p);
    Parser_next_token(p);
}
 else {
    if ((p.cur_token.kind === TOKEN_STRING)) {
node = { kind: NODE_LITERAL, value: `"${p.cur_token.lexeme}"` };
    Parser_next_token(p);
}
 else {
    if (p.cur_token.kind === TOKEN_TRUE || p.cur_token.kind === TOKEN_FALSE) {
        node = { kind: NODE_LITERAL, value: p.cur_token.lexeme };
        Parser_next_token(p);
    }
 else {
    if ((p.cur_token.kind === TOKEN_LBRACKET)) {
    Parser_next_token(p);
    const elements = [];
    while (p.cur_token.kind !== TOKEN_RBRACKET && p.cur_token.kind !== TOKEN_EOF) {
elements.push(Parser_parse_expression(p));
    if ((p.cur_token.kind === TOKEN_COMMA)) {
    Parser_next_token(p);
}

}

    Parser_next_token(p);
node = { kind: NODE_ARRAY, elements: elements };
}
}
}
}
}

}

    let kind = p.cur_token.kind;
    while ((kind === TOKEN_DOT)) {
    Parser_next_token(p);
    const prop = p.cur_token.lexeme;
    Parser_next_token(p);
    node = new MemberExpr({ kind: NODE_MEMBER, target: node, property: prop });
    kind = p.cur_token.kind;
}
    return node;
}






function Parser_parse_if(p) {
    Parser_next_token(p); // skip if
    
    const cond = Parser_parse_expression(p);
    const cons = Parser_parse_block(p);
    
    let alt = null;
    if (p.cur_token.kind === 65) { // TOKEN_ELSE
        Parser_next_token(p); // skip else
        
        if (p.cur_token.kind === 64) { // else if ...
             const if_stmt = Parser_parse_if(p);
             alt = new Block({ kind: NODE_BLOCK, statements: [if_stmt] });
        } else {
             alt = Parser_parse_block(p);
        }
    }
    
    return new IfStmt({ kind: NODE_IF, condition: cond, consequence: cons, alternative: alt });
}

function Parser_parse_while(p) {
    Parser_next_token(p); // skip while
    const cond = Parser_parse_expression(p);
    const body = Parser_parse_block(p);
    return new WhileStmt({ kind: NODE_WHILE, condition: cond, body: body });
}


function Parser_parse_relational(p) {
    let left = Parser_parse_term(p);
    while (p.cur_token.kind === 26 || p.cur_token.kind === 27) { // LT=26, GT=27
        const op = p.cur_token.lexeme;
        Parser_next_token(p);
        const right = Parser_parse_term(p);
        left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
    }
    return left;
}


function Parser_parse_logic(p) {
    let left = Parser_parse_equality(p);
    while (p.cur_token.kind === 32 || p.cur_token.kind === 33) { // AND=32, OR=33
        const op = p.cur_token.lexeme;
        Parser_next_token(p);
        const right = Parser_parse_equality(p);
        left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
    }
    return left;
}

module.exports = { new_parser, Parser_next_token, Parser_parse_program, Parser_parse_statement, Parser_parse_import, Parser_parse_let, Parser_parse_return, Parser_parse_fn, Parser_parse_struct, Parser_parse_native_block, Parser_parse_block, Parser_parse_expr_stmt, Parser_parse_expression, Parser_parse_logic, Parser_parse_equality, Parser_parse_relational, Parser_parse_term, Parser_parse_factor, Parser };


Object.assign(global, lexer);
Object.assign(global, token);
Object.assign(global, ast);
