// Generated by Omni Compiler
'use strict';

let lexer = require('./lexer.js');
let token = require('./token.js');
let ast = require('./ast.js');

class Parser {
    constructor(data = {}) {
        this.lexer = data.lexer;
        this.cur_token = data.cur_token;
        this.peek_token = data.peek_token;
    }
}

function new_parser(l) {
    let p = new Parser({ lexer: l, cur_token: new_token(0, "", 0), peek_token: new_token(0, "", 0) });
    Parser_next_token(p);
    Parser_next_token(p);
    return p;
}

function Parser_next_token(p) {
    p.cur_token = p.peek_token;
    p.peek_token = Lexer_next_token(p.lexer);
}

function Parser_parse_program(p) {
    let stmts = [];
    while ((p.cur_token.kind !== TOKEN_EOF)) {
    let stmt = Parser_parse_statement(p);
    if ((stmt.kind !== 0)) {
stmts.push(stmt);
}

}

    return new Program({ statements: stmts });
}

function Parser_parse_statement(p) {
    if ((p.cur_token.kind === 92)) { // TOKEN_EXPORT
    Parser_next_token(p); // consume 'export'
    let stmt = Parser_parse_statement(p);
    if (stmt) stmt.is_exported = true;
    return stmt;
}

    if ((p.cur_token.kind === 90)) {
    return Parser_parse_import(p);
}

    if ((p.cur_token.kind === TOKEN_RBRACE)) {
    Parser_next_token(p);
    return 0;
}

    if ((p.cur_token.kind === TOKEN_IF)) {
    return Parser_parse_if(p);
}

    if ((p.cur_token.kind === TOKEN_WHILE)) {
    return Parser_parse_while(p);
}

    if ((p.cur_token.kind === TOKEN_LET)) {
    return Parser_parse_let(p);
}

    if ((p.cur_token.kind === TOKEN_FN)) {
    return Parser_parse_fn(p);
}

    if ((p.cur_token.kind === TOKEN_STRUCT)) {
    return Parser_parse_struct(p);
}

    if ((p.cur_token.kind === TOKEN_RETURN)) {
    return Parser_parse_return(p);
}

    if ((p.cur_token.kind === TOKEN_NATIVE)) {
    return Parser_parse_native_block(p);
}

    if ((p.cur_token.kind === 93)) { // TOKEN_INTERFACE
    return Parser_parse_interface(p);
}

    if ((p.cur_token.kind === 94)) { // TOKEN_IMPL
    return Parser_parse_impl(p);
}

    if ((p.cur_token.kind === 96)) { // TOKEN_AT - attribute
    let attribute = Parser_parse_attribute(p);
    // Attach attribute to next statement (interface, struct, fn)
    let stmt = Parser_parse_statement(p);
    if (stmt) {
        if (!stmt.attributes) stmt.attributes = [];
        stmt.attributes.push(attribute);
    }
    return stmt;
}

    if ((p.cur_token.kind === 97)) { // TOKEN_SPAWN
    Parser_next_token(p); // skip 'spawn'
    // Parse the function call that follows
    let call = Parser_parse_expression(p);
    return { kind: 92, call: call }; // NODE_SPAWN = 92
}

    if ((p.cur_token.kind === 98)) { // TOKEN_CAPSULE
    return Parser_parse_capsule(p);
}

    return Parser_parse_expr_stmt(p);
}

function Parser_parse_import(p) {
    Parser_next_token(p);
    let path = p.cur_token.lexeme;
    Parser_next_token(p);
    if ((p.cur_token.kind === TOKEN_SEMICOLON)) {
    Parser_next_token(p);
}

    return new ImportDecl({ kind: NODE_IMPORT, path: path });
}

function Parser_parse_let(p) {
    Parser_next_token(p);
    let name = p.cur_token.lexeme;
    Parser_next_token(p);
    if ((p.cur_token.kind === 30)) {
    Parser_next_token(p);
    Parser_next_token(p);
}

    Parser_next_token(p);
    let val = Parser_parse_expression(p);
    if ((p.cur_token.kind === TOKEN_SEMICOLON)) {
    Parser_next_token(p);
}

    return new LetStmt({ kind: NODE_LET, name: name, value: val });
}

function Parser_parse_return(p) {
    Parser_next_token(p);
    let val = Parser_parse_expression(p);
    if ((p.cur_token.kind === TOKEN_SEMICOLON)) {
    Parser_next_token(p);
}

    return new ReturnStmt({ kind: NODE_RETURN, value: val });
}

function Parser_parse_fn(p) {
    Parser_next_token(p);
    let name = p.cur_token.lexeme;
    Parser_next_token(p);
    Parser_next_token(p);
    let params = [];
    while ((p.cur_token.kind !== TOKEN_RPAREN)) {
params.push(p.cur_token.lexeme);
    Parser_next_token(p);
    if ((p.cur_token.kind === 30)) {
    Parser_next_token(p);
    Parser_next_token(p);
}

    if ((p.cur_token.kind === TOKEN_COMMA)) {
    Parser_next_token(p);
}

}

    Parser_next_token(p);
    if ((p.cur_token.lexeme === "-")) {
    Parser_next_token(p);
    Parser_next_token(p);
    Parser_next_token(p);
}

    let body = Parser_parse_block(p);
    return new FunctionDecl({ kind: NODE_FUNCTION, name: name, params: params, body: body });
}

function Parser_parse_struct(p) {
    Parser_next_token(p);
    let name = p.cur_token.lexeme;
    Parser_next_token(p);
    Parser_next_token(p);
    let fields = [];
    while ((p.cur_token.kind !== TOKEN_RBRACE && p.cur_token.kind !== TOKEN_EOF)) {
    let field_name = p.cur_token.lexeme;
    Parser_next_token(p);
    Parser_next_token(p);
    let field_type = p.cur_token.lexeme;
    Parser_next_token(p);
    let f = new_struct_field(field_name, field_type);
fields.push(f);
    if ((p.cur_token.kind === TOKEN_COMMA)) {
    Parser_next_token(p);
}

}

    Parser_next_token(p);
    return new StructDecl({ kind: NODE_STRUCT, name: name, fields: fields });
}

function Parser_parse_native_block(p) {
    Parser_next_token(p);
    let lang = "js";
    if ((p.cur_token.kind === TOKEN_STRING)) {
    lang = p.cur_token.lexeme;
    Parser_next_token(p);
}

    if ((p.cur_token.kind !== TOKEN_LBRACE)) {
    return new NativeStmt({ kind: 0, lang: "", code: "" });
}

    let start_pos = p.cur_token.start;
    let code = "";
    let end_pos = 0;
let input = p.lexer.input;
        let pos = Number(start_pos) + 1;
        let brace_count = 1;
        let start_extract = pos;
        
        while (pos < input.length && brace_count > 0) {
            let char = input[pos];
            if (char === '{') brace_count++;
            if (char === '}') brace_count--;
            pos++;
        }
        
        end_pos = pos;
        if (brace_count == 0) {
            code = input.substring(start_extract, pos - 1);
        }
        p.lexer.read_position = end_pos;
        Lexer_read_char(p.lexer);
        p.cur_token = Lexer_next_token(p.lexer);
        p.peek_token = Lexer_next_token(p.lexer);
    return new NativeStmt({ kind: NODE_NATIVE, lang: lang, code: code });
}

function Parser_parse_block(p) {
    let stmts = [];
    if ((p.cur_token.kind === TOKEN_LBRACE)) {
    Parser_next_token(p);
    while ((p.cur_token.kind !== TOKEN_RBRACE && p.cur_token.kind !== TOKEN_EOF)) {
console.log("BlockLoop: " + p.cur_token.kind + " (" + p.cur_token.lexeme + ")");
    let stmt = Parser_parse_statement(p);
stmts.push(stmt);
}

    Parser_next_token(p);
}
 else {
    let stmt = Parser_parse_statement(p);
stmts.push(stmt);
}

    return new Block({ kind: NODE_BLOCK, statements: stmts });
}

function Parser_parse_expr_stmt(p) {
    let expr = Parser_parse_expression(p);
    if ((p.cur_token.kind === TOKEN_SEMICOLON)) {
    Parser_next_token(p);
}

    return new ExpressionStmt({ kind: 0, expr: expr });
}

function Parser_parse_expression(p) {
    return Parser_parse_assignment(p);
}

function Parser_parse_assignment(p) {
    let left = Parser_parse_logic(p);
    if ((p.cur_token.kind === TOKEN_ASSIGN)) {
    Parser_next_token(p);
    let right = Parser_parse_assignment(p);
    return new AssignmentExpr({ kind: NODE_ASSIGNMENT, left: left, right: right });
}

    return left;
}

function Parser_parse_equality(p) {
    let left = Parser_parse_relational(p);
    while (true) {
    let k = p.cur_token.kind;
    if ((k !== TOKEN_EQ && k !== TOKEN_NOT_EQ)) {
    break;
}

    let op = p.cur_token.lexeme;
    Parser_next_token(p);
    let right = Parser_parse_relational(p);
    left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
}

    return left;
}

function Parser_parse_relational(p) {
    let left = Parser_parse_term(p);
    while (true) {
    let k = p.cur_token.kind;
    if (k !== TOKEN_LT && k !== TOKEN_GT && k !== TOKEN_LE && k !== TOKEN_GE) {
    break;
}

    let op = p.cur_token.lexeme;
    Parser_next_token(p);
    let right = Parser_parse_term(p);
    left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
}

    return left;
}

function Parser_parse_logic(p) {
    let left = Parser_parse_equality(p);
    while (true) {
    let k = p.cur_token.kind;
    if ((k !== TOKEN_AND && k !== TOKEN_OR)) {
    break;
}

    let op = p.cur_token.lexeme;
    Parser_next_token(p);
    let right = Parser_parse_equality(p);
    left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
}

    return left;
}

function Parser_parse_term(p) {
    let left = Parser_parse_multiplication(p);
    while (true) {
    let k = p.cur_token.kind;
    if (k !== TOKEN_PLUS && k !== TOKEN_MINUS) {
    break;
}

    let op = p.cur_token.lexeme;
    Parser_next_token(p);
    let right = Parser_parse_multiplication(p);
    left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
}

    return left;
}

function Parser_parse_multiplication(p) {
    let left = Parser_parse_factor(p);
    while (true) {
    let k = p.cur_token.kind;
    if (k !== TOKEN_ASTERISK && k !== TOKEN_SLASH) {
    break;
}

    let op = p.cur_token.lexeme;
    Parser_next_token(p);
    let right = Parser_parse_factor(p);
    left = new BinaryExpr({ kind: NODE_BINARY, left: left, op: op, right: right });
}

    return left;
}

function Parser_parse_factor(p) {
    let node = 0;
    if ((p.cur_token.kind === TOKEN_INT)) {
    let val = 0;
val = parseInt(p.cur_token.lexeme);
    node = new IntegerLiteral({ kind: NODE_LITERAL, value: val });
    Parser_next_token(p);
}
 else {
    if ((p.cur_token.kind === TOKEN_IDENTIFIER)) {
    let name = p.cur_token.lexeme;
    Parser_next_token(p);
    if ((p.cur_token.kind === TOKEN_LBRACE)) {
    Parser_next_token(p);
    let init_fields = [];
    while ((p.cur_token.kind !== TOKEN_RBRACE && p.cur_token.kind !== TOKEN_EOF)) {
    let field_name = p.cur_token.lexeme;
    Parser_next_token(p);
    Parser_next_token(p);
    let field_val = Parser_parse_expression(p);
init_fields.push({ name: field_name, value: field_val });
    if ((p.cur_token.kind === TOKEN_COMMA)) {
    Parser_next_token(p);
}

}

    Parser_next_token(p);
node = { kind: NODE_STRUCT_INIT, name: name, fields: init_fields };
}
 else {
    node = new Identifier({ kind: NODE_IDENTIFIER, value: name });
}

}
 else {
    if ((p.cur_token.kind === TOKEN_LPAREN)) {
    Parser_next_token(p);
    node = Parser_parse_expression(p);
    Parser_next_token(p);
}
 else {
    if ((p.cur_token.kind === TOKEN_STRING)) {
node = { kind: NODE_LITERAL, value: `"${p.cur_token.lexeme}"` };
    Parser_next_token(p);
}
 else {
    if (p.cur_token.kind === TOKEN_TRUE || p.cur_token.kind === TOKEN_FALSE) {
node = { kind: NODE_LITERAL, value: p.cur_token.lexeme };
    Parser_next_token(p);
}
 else {
    if ((p.cur_token.kind === TOKEN_LBRACKET)) {
    Parser_next_token(p);
    let elements = [];
    while ((p.cur_token.kind !== TOKEN_RBRACKET && p.cur_token.kind !== TOKEN_EOF)) {
elements.push(Parser_parse_expression(p));
    if ((p.cur_token.kind === TOKEN_COMMA)) {
    Parser_next_token(p);
}

}

    Parser_next_token(p);
node = { kind: NODE_ARRAY, elements: elements };
}
 else {
console.error("Unexpected token in expression: Kind " + p.cur_token.kind + ", Lexeme: " + p.cur_token.lexeme);
    Parser_next_token(p);
    return 0;
}

}

}

}

}

}

    let continue_loop = true;
    while (continue_loop) {
    if ((p.cur_token.kind === 31)) {
    Parser_next_token(p);
    let prop = p.cur_token.lexeme;
    Parser_next_token(p);
    node = new MemberExpr({ kind: NODE_MEMBER, target: node, property: prop });
}
 else {
    if ((p.cur_token.kind === TOKEN_LPAREN)) {
    Parser_next_token(p);
    let args = [];
    while ((p.cur_token.kind !== TOKEN_RPAREN && p.cur_token.kind !== TOKEN_EOF)) {
args.push(Parser_parse_expression(p));
    if ((p.cur_token.kind === TOKEN_COMMA)) {
    Parser_next_token(p);
}

}

    Parser_next_token(p);
    node = new CallExpr({ kind: NODE_CALL, function: node, args: args });
}
 else {
    continue_loop = false;
}

}

}

    return node;
}

function Parser_parse_if(p) {
    Parser_next_token(p);
    let cond = Parser_parse_expression(p);
    let cons = Parser_parse_block(p);
    let alt = 0;
    if ((p.cur_token.kind === TOKEN_ELSE)) {
    Parser_next_token(p);
    if ((p.cur_token.kind === TOKEN_IF)) {
    let if_stmt = Parser_parse_if(p);
    let stmts = [];
stmts.push(if_stmt);
    alt = new Block({ kind: NODE_BLOCK, statements: stmts });
}
 else {
    alt = Parser_parse_block(p);
}

}

    return new IfStmt({ kind: NODE_IF, condition: cond, consequence: cons, alternative: alt });
}

function Parser_parse_while(p) {
    Parser_next_token(p);
    let cond = Parser_parse_expression(p);
    let body = Parser_parse_block(p);
    return new WhileStmt({ kind: NODE_WHILE, condition: cond, body: body });
}

// Parse interface declaration
// interface Name { fn method(param: type) -> return_type; }
function Parser_parse_interface(p) {
    Parser_next_token(p); // skip 'interface'
    let name = p.cur_token.lexeme;
    Parser_next_token(p); // skip name
    Parser_next_token(p); // skip {
    
    let methods = [];
    while (p.cur_token.kind !== TOKEN_RBRACE && p.cur_token.kind !== TOKEN_EOF) {
        if (p.cur_token.kind === TOKEN_FN) {
            Parser_next_token(p); // skip 'fn'
            let method_name = p.cur_token.lexeme;
            Parser_next_token(p); // skip method name
            Parser_next_token(p); // skip (
            
            let params = [];
            while (p.cur_token.kind !== TOKEN_RPAREN && p.cur_token.kind !== TOKEN_EOF) {
                let param_name = p.cur_token.lexeme;
                Parser_next_token(p); // skip param name
                Parser_next_token(p); // skip :
                let param_type = p.cur_token.lexeme;
                Parser_next_token(p); // skip type
                params.push({ name: param_name, type: param_type });
                if (p.cur_token.kind === TOKEN_COMMA) {
                    Parser_next_token(p);
                }
            }
            Parser_next_token(p); // skip )
            
            let return_type = "void";
            if (p.cur_token.lexeme === "-") {
                Parser_next_token(p); // skip -
                Parser_next_token(p); // skip >
                return_type = p.cur_token.lexeme;
                Parser_next_token(p); // skip return type
            }
            
            if (p.cur_token.kind === TOKEN_SEMICOLON) {
                Parser_next_token(p);
            }
            
            methods.push(new MethodSignature({ name: method_name, params: params, return_type: return_type }));
        } else {
            Parser_next_token(p); // skip unknown token
        }
    }
    Parser_next_token(p); // skip }
    
    return new InterfaceDecl({ kind: NODE_INTERFACE, name: name, methods: methods, is_exported: false });
}

// Parse impl declaration
// impl InterfaceName for StructName { fn method(...) { ... } }
function Parser_parse_impl(p) {
    Parser_next_token(p); // skip 'impl'
    let interface_name = p.cur_token.lexeme;
    Parser_next_token(p); // skip interface name
    Parser_next_token(p); // skip 'for' (token 95)
    let struct_name = p.cur_token.lexeme;
    Parser_next_token(p); // skip struct name
    Parser_next_token(p); // skip {
    
    let methods = [];
    while (p.cur_token.kind !== TOKEN_RBRACE && p.cur_token.kind !== TOKEN_EOF) {
        if (p.cur_token.kind === TOKEN_FN) {
            let fn_decl = Parser_parse_fn(p);
            methods.push(fn_decl);
        } else {
            Parser_next_token(p);
        }
    }
    Parser_next_token(p); // skip }
    
    return new ImplDecl({ kind: NODE_IMPL, interface_name: interface_name, struct_name: struct_name, methods: methods });
}

// Parse @attribute(param: value, ...)
function Parser_parse_attribute(p) {
    Parser_next_token(p); // skip @
    let name = p.cur_token.lexeme;
    Parser_next_token(p); // skip attribute name
    
    let params = {};
    if (p.cur_token.kind === TOKEN_LPAREN) {
        Parser_next_token(p); // skip (
        while (p.cur_token.kind !== TOKEN_RPAREN && p.cur_token.kind !== TOKEN_EOF) {
            let param_name = p.cur_token.lexeme;
            Parser_next_token(p); // skip param name
            Parser_next_token(p); // skip :
            let param_value = p.cur_token.lexeme;
            // Remove quotes if string
            if (param_value.startsWith('"') || param_value.startsWith("'")) {
                param_value = param_value.slice(1, -1);
            }
            params[param_name] = param_value;
            Parser_next_token(p); // skip value
            if (p.cur_token.kind === TOKEN_COMMA) {
                Parser_next_token(p);
            }
        }
        Parser_next_token(p); // skip )
    }
    
    return { name: name, params: params };
}

function Parser_parse_capsule(p) {
    Parser_next_token(p); // skip 'capsule'
    
    let name = p.cur_token.lexeme;
    Parser_next_token(p); // skip name
    
    Parser_next_token(p); // skip {
    
    let flows = [];
    
    // Parse flows inside capsule
    while (p.cur_token.kind !== TOKEN_RBRACE && p.cur_token.kind !== TOKEN_EOF) {
        if (p.cur_token.kind === 99) { // TOKEN_FLOW
            Parser_next_token(p); // skip 'flow'
            
            let flow_name = p.cur_token.lexeme;
            Parser_next_token(p); // skip flow name
            Parser_next_token(p); // skip (
            
            // Parse parameters
            let params = [];
            while (p.cur_token.kind !== TOKEN_RPAREN && p.cur_token.kind !== TOKEN_EOF) {
                let param_name = p.cur_token.lexeme;
                Parser_next_token(p); // skip param name
                Parser_next_token(p); // skip :
                let param_type = p.cur_token.lexeme;
                Parser_next_token(p); // skip type
                params.push({ name: param_name, typename: param_type });
                if (p.cur_token.kind === TOKEN_COMMA) {
                    Parser_next_token(p);
                }
            }
            Parser_next_token(p); // skip )
            
            // Parse return type
            let return_type = "void";
            if (p.cur_token.lexeme === "-" && p.peek_token.lexeme === ">") {
                Parser_next_token(p); // skip -
                Parser_next_token(p); // skip >
                return_type = p.cur_token.lexeme;
                Parser_next_token(p); // skip return type
            }
            
            // Skip semicolon
            if (p.cur_token.kind === TOKEN_SEMICOLON) {
                Parser_next_token(p);
            }
            
            flows.push({ name: flow_name, params: params, return_type: return_type });
        } else {
            Parser_next_token(p); // skip unknown
        }
    }
    
    Parser_next_token(p); // skip }
    
    return { kind: 93, name: name, flows: flows }; // NODE_CAPSULE = 93
}

module.exports = { new_parser, Parser_next_token, Parser_parse_program, Parser_parse_statement, Parser_parse_import, Parser_parse_let, Parser_parse_return, Parser_parse_fn, Parser_parse_struct, Parser_parse_native_block, Parser_parse_block, Parser_parse_expr_stmt, Parser_parse_expression, Parser_parse_assignment, Parser_parse_equality, Parser_parse_relational, Parser_parse_logic, Parser_parse_term, Parser_parse_multiplication, Parser_parse_factor, Parser_parse_if, Parser_parse_while, Parser_parse_interface, Parser_parse_impl, Parser_parse_attribute, Parser_parse_capsule, Parser };

Object.assign(global, lexer);
Object.assign(global, token);
Object.assign(global, ast);
