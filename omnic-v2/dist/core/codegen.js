// Generated by Omni Compiler
'use strict';

let ast = require('./ast.js');
let token = require('./token.js');

class CodeGenerator {
    constructor(data = {}) {
    }
}

function new_code_generator() {
    return new CodeGenerator({  });
}

function CodeGenerator_generate(self, program) {
    let output = "";
if (program && program.statements) {
            for (const stmt of program.statements) {
                output = output + CodeGenerator_gen_statement(self, stmt) + "\n";
            }
        }
    
    // Auto-Export Logic - based on is_exported flag
    let exports = [];
    if (program && program.statements) {
         for (const stmt of program.statements) {
             if (stmt.is_exported && stmt.name) {
                 exports.push(stmt.name);
             }
         }
    }
    if (exports.length > 0) {
        output += "\nmodule.exports = { " + exports.join(", ") + " };\n";
    }

    return output;
}

function CodeGenerator_gen_statement(self, stmt) {
    if ((stmt.kind === NODE_IMPORT)) {
    return CodeGenerator_gen_import(self, stmt);
}

    if ((stmt.kind === 80)) {
    // Only emit JS native blocks
    if (stmt.lang === "js" || stmt.lang === "javascript") {
        return stmt.code;
    }
    return "";
}

    if ((stmt.kind === NODE_LET)) {
    return (((("let " + stmt.name) + " = ") + CodeGenerator_gen_expression(self, stmt.value)) + ";");
}

    if ((stmt.kind === NODE_RETURN)) {
    return (("return " + CodeGenerator_gen_expression(self, stmt.value)) + ";");
}

    if ((stmt.kind === NODE_FUNCTION)) {
    let params = "";
params = stmt.params.join(", ");
    let body = CodeGenerator_gen_block(self, stmt.body);
    return ((((("function " + stmt.name) + "(") + params) + ") ") + body);
}

    if ((stmt.kind === NODE_STRUCT)) {
    return CodeGenerator_gen_struct(self, stmt);
}

    if ((stmt.kind === NODE_IF)) {
    let cond = CodeGenerator_gen_expression(self, stmt.condition);
    let cons = CodeGenerator_gen_block(self, stmt.consequence);
    let alt = "";
    if (stmt.alternative) {
    alt = (" else " + CodeGenerator_gen_block(self, stmt.alternative));
}

    return (((("if (" + cond) + ") ") + cons) + alt);
}

    if ((stmt.kind === NODE_WHILE)) {
    let cond = CodeGenerator_gen_expression(self, stmt.condition);
    let body = CodeGenerator_gen_block(self, stmt.body);
    return ((("while (" + cond) + ") ") + body);
}

    if (stmt.expr) {
    return (CodeGenerator_gen_expression(self, stmt.expr) + ";");
}

    // Interface declarations - check for @service attribute
    if (stmt.kind === NODE_INTERFACE) {
        // Check if this is a @service interface
        let is_service = false;
        let service_url = "";
        if (stmt.attributes) {
            for (const attr of stmt.attributes) {
                if (attr.name === "service") {
                    is_service = true;
                    service_url = attr.params.url || "";
                }
            }
        }
        
        if (is_service && service_url) {
            // Generate RPC client proxy
            let out = "// @service interface: " + stmt.name + " - RPC Client Proxy\n";
            out += "const " + stmt.name + " = {\n";
            if (stmt.methods) {
                for (const m of stmt.methods) {
                    let params_str = m.params ? m.params.map(p => p.name).join(", ") : "";
                    let args_obj = m.params ? m.params.map(p => p.name + ": " + p.name).join(", ") : "";
                    out += "    async " + m.name + "(" + params_str + ") {\n";
                    out += "        const response = await fetch(\"" + service_url + "/" + stmt.name + "/" + m.name + "\", {\n";
                    out += "            method: \"POST\",\n";
                    out += "            headers: { \"Content-Type\": \"application/json\" },\n";
                    out += "            body: JSON.stringify({ " + args_obj + " })\n";
                    out += "        });\n";
                    out += "        return await response.json();\n";
                    out += "    },\n";
                }
            }
            out += "};\n";
            return out;
        } else {
            // Generate JSDoc comments (normal interface)
            let methods_doc = "";
            if (stmt.methods) {
                for (const m of stmt.methods) {
                    let params_str = m.params ? m.params.map(p => p.name + ": " + p.type).join(", ") : "";
                    methods_doc += " * @method " + m.name + "(" + params_str + ") -> " + m.return_type + "\n";
                }
            }
            return "/**\n * @interface " + stmt.name + "\n" + methods_doc + " */";
        }
    }

    // Impl generates methods attached to struct prototype
    if (stmt.kind === NODE_IMPL) {
        // Check for @server attribute
        let is_server = false;
        let server_port = 3000;
        if (stmt.attributes) {
            for (const attr of stmt.attributes) {
                if (attr.name === "server") {
                    is_server = true;
                    server_port = attr.params.port || 3000;
                }
            }
        }
        
        let out = "// impl " + stmt.interface_name + " for " + stmt.struct_name + "\n";
        
        // Generate methods as prototype functions
        if (stmt.methods) {
            for (const m of stmt.methods) {
                let params = m.params ? m.params.join(", ") : "";
                let body = CodeGenerator_gen_block(self, m.body);
                out += stmt.struct_name + ".prototype." + m.name + " = function(" + params + ") " + body + "\n";
            }
        }
        
        // Generate server skeleton if @server
        if (is_server) {
            out += "\n// === Server Skeleton with FlightRecorder ===\n";
            out += "const http = require('http');\n";
            out += "const FlightRecorder = global.FlightRecorder || require('./lib/debug.js').FlightRecorder;\n\n";
            out += "const " + stmt.struct_name + "Instance = new " + stmt.struct_name + "();\n\n";
            out += "const server = http.createServer(async (req, res) => {\n";
            out += "    const url = new URL(req.url, `http://${req.headers.host}`);\n";
            out += "    const [, iface, method] = url.pathname.split('/');\n";
            out += "    \n";
            out += "    let body = '';\n";
            out += "    req.on('data', chunk => body += chunk);\n";
            out += "    req.on('end', async () => {\n";
            out += "        const traceId = FlightRecorder.start(iface + '.' + method);\n";
            out += "        try {\n";
            out += "            const args = JSON.parse(body || '{}');\n";
            out += "            const impl = " + stmt.struct_name + "Instance;\n";
            out += "            if (impl[method]) {\n";
            out += "                const result = await impl[method](...Object.values(args));\n";
            out += "                FlightRecorder.stop(traceId, { success: true });\n";
            out += "                res.writeHead(200, { 'Content-Type': 'application/json' });\n";
            out += "                res.end(JSON.stringify(result));\n";
            out += "            } else {\n";
            out += "                FlightRecorder.stop(traceId, { error: 'Method not found' });\n";
            out += "                res.writeHead(404);\n";
            out += "                res.end(JSON.stringify({ error: 'Method not found' }));\n";
            out += "            }\n";
            out += "        } catch (e) {\n";
            out += "            FlightRecorder.stop(traceId, { error: e.message });\n";
            out += "            res.writeHead(500);\n";
            out += "            res.end(JSON.stringify({ error: e.message }));\n";
            out += "        }\n";
            out += "    });\n";
            out += "});\n\n";
            out += "server.listen(" + server_port + ", () => {\n";
            out += "    console.log('[" + stmt.interface_name + " Server] Listening on port " + server_port + "');\n";
            out += "});\n\n";
            out += "// Save flight recorder on exit\n";
            out += "process.on('SIGINT', () => {\n";
            out += "    FlightRecorder.saveReport();\n";
            out += "    process.exit();\n";
            out += "});\n";
        }
        
        return out;
    }

    return ("// Unknown stmt kind: " + stmt.kind);
}

function CodeGenerator_gen_import(self, stmt) {
    let path = stmt.path;
path = path.replace(".omni", ".js");
        if (path.startsWith(".") == false) path = "./" + path;
        // Extrai nome do arquivo para variÃ¡vel: "./core/token.js" -> "token"
        let name = path.split("/").pop().replace(".js", "");
        // Gera: let token = require("./token.js");
        return "const " + name + " = require(\"" + path + "\");\nif (typeof global !== 'undefined') Object.assign(global, " + name + ");";
    return "";
}

function CodeGenerator_gen_struct(self, stmt) {
    let name = stmt.name;
    let assignments = "";
    for (const field of stmt.fields) {
        assignments = assignments + "        this." + field.name + " = data." + field.name + ";\n";
    }
    
    let out = "class " + name + " {\n    constructor(data = {}) {\n" + assignments + "    }\n}\n";
    
    // Check for @entity attribute
    let is_entity = false;
    let storage_name = "main_db";
    if (stmt.attributes) {
        for (const attr of stmt.attributes) {
            if (attr.name === "entity") {
                is_entity = true;
                storage_name = attr.params.storage || "main_db";
            }
        }
    }
    
    if (is_entity) {
        const fieldNames = stmt.fields.filter(f => f.name !== 'id').map(f => f.name);
        const placeholders = fieldNames.map(() => '?').join(', ');
        const updateSet = fieldNames.map(f => f + '=?').join(', ');
        
        out += "\n// @entity Repository: " + name + "\n";
        out += name + ".find = async (id) => {\n";
        out += "    const db = await Database.get('" + storage_name + "');\n";
        out += "    const row = await db.get('SELECT * FROM " + name + " WHERE id = ?', [id]);\n";
        out += "    return row ? new " + name + "(row) : null;\n";
        out += "};\n\n";
        
        out += name + ".save = async (obj) => {\n";
        out += "    const db = await Database.get('" + storage_name + "');\n";
        out += "    if (obj.id) {\n";
        out += "        await db.run('UPDATE " + name + " SET " + updateSet + " WHERE id=?', [" + fieldNames.map(f => 'obj.' + f).join(', ') + ", obj.id]);\n";
        out += "    } else {\n";
        out += "        const r = await db.run('INSERT INTO " + name + " (" + fieldNames.join(', ') + ") VALUES (" + placeholders + ")', [" + fieldNames.map(f => 'obj.' + f).join(', ') + "]);\n";
        out += "        obj.id = r.lastID;\n";
        out += "    }\n";
        out += "    return obj;\n";
        out += "};\n\n";
        
        out += name + ".all = async () => {\n";
        out += "    const db = await Database.get('" + storage_name + "');\n";
        out += "    return (await db.all('SELECT * FROM " + name + "')).map(r => new " + name + "(r));\n";
        out += "};\n\n";
        
        out += name + ".delete = async (id) => {\n";
        out += "    const db = await Database.get('" + storage_name + "');\n";
        out += "    await db.run('DELETE FROM " + name + " WHERE id = ?', [id]);\n";
        out += "};\n";
    }
    
    return out;
}

function CodeGenerator_gen_block(self, block) {
    let out = "{\n";
if (block && block.statements) {
            for (const s of block.statements) {
                out = out + "    " + CodeGenerator_gen_statement(self, s) + "\n";
            }
        }
    out = (out + "}");
    return out;
}

function CodeGenerator_gen_expression(self, expr) {
    if ((expr === 0)) {
    return "null";
}

    if ((expr.kind === NODE_LITERAL)) {
    return expr.value;
}

    if ((expr.kind === NODE_BINARY)) {
    return ((((CodeGenerator_gen_expression(self, expr.left) + " ") + expr.op) + " ") + CodeGenerator_gen_expression(self, expr.right));
}

    if ((expr.kind === NODE_CALL)) {
    let args = "";
let list = [];
             for(let a of expr.args) list.push(CodeGenerator_gen_expression(self, a));
             args = list.join(", ");
    let callee = CodeGenerator_gen_expression(self, expr.function);
    let is_class = false;
if (typeof expr.function.value === 'string') {
                 let val = expr.function.value;
                 let first = val.charAt(0);
                 is_class = (first >= "A" && first <= "Z") && (val.indexOf("_") == -1);
             }
    if (is_class) {
    return (((("new " + callee) + "(") + args) + ")");
}

    return (((callee + "(") + args) + ")");
}

    if ((expr.kind === NODE_MEMBER)) {
    return ((CodeGenerator_gen_expression(self, expr.target) + ".") + expr.property);
}

    if ((expr.kind === NODE_STRUCT_INIT)) {
    let fields = "";
let list = [];
            for(let f of expr.fields) {
                list.push(f.name + ": " + CodeGenerator_gen_expression(self, f.value));
            }
            fields = list.join(", ");
    return (((("new " + expr.name) + "({ ") + fields) + " })");
}

    if ((expr.kind === NODE_ARRAY)) {
    let elems = "";
let list = [];
            for (let e of expr.elements) {
                list.push(CodeGenerator_gen_expression(self, e));
            }
            elems = list.join(", ");
    return (("[" + elems) + "]");
}

    if ((expr.kind === NODE_IDENTIFIER)) {
    return expr.value;
}

    if ((expr.kind === NODE_ASSIGNMENT)) {
    let left = CodeGenerator_gen_expression(self, expr.left);
    let right = CodeGenerator_gen_expression(self, expr.right);
    let code = "";
code = left + " = " + right;
    return code;
}

if (typeof(expr) == "string") return expr;
    return expr;
}

function CodeGenerator_generate_python(self, program) {
    let output = "";
    if (program && program.statements) {
        for (const stmt of program.statements) {
            output = output + CodeGenerator_gen_stmt_py(self, stmt) + "\n";
        }
    }
    
    // Generate __all__ for exports
    let py_exports = [];
    if (program && program.statements) {
        for (const stmt of program.statements) {
            if (stmt.is_exported && stmt.name) {
                py_exports.push("'" + stmt.name + "'");
            }
        }
    }
    if (py_exports.length > 0) {
        output += "\n__all__ = [" + py_exports.join(", ") + "]\n";
    }
    
    return output;
}

function CodeGenerator_gen_stmt_py(self, stmt) {
    if (stmt.kind === NODE_IMPORT) {
        let path = stmt.path.replace(".omni", "");
        if (path.includes("/")) {
            let parts = path.split("/");
            let name = parts[parts.length - 1];
            return "import " + name;
        }
        return "import " + path;
    }
    
    if (stmt.kind === 80) { // NATIVE
        if (stmt.lang === "python" || stmt.lang === "py") {
            return stmt.code;
        }
        return "";
    }
    
    if (stmt.kind === NODE_LET) {
        return stmt.name + " = " + CodeGenerator_gen_expr_py(self, stmt.value);
    }
    
    if (stmt.kind === NODE_RETURN) {
        return "return " + CodeGenerator_gen_expr_py(self, stmt.value);
    }
    
    if (stmt.kind === NODE_FUNCTION) {
        let params = stmt.params.join(", ");
        let body = CodeGenerator_gen_block_py(self, stmt.body);
        return "def " + stmt.name + "(" + params + "):\n" + body;
    }
    
    if (stmt.kind === NODE_STRUCT) {
        let fields = [];
        if (stmt.fields) {
            for (const f of stmt.fields) {
                fields.push("self." + f.name + " = " + f.name);
            }
        }
        let params = stmt.fields ? stmt.fields.map(f => f.name + "=None").join(", ") : "";
        let init_body = fields.length > 0 ? "        " + fields.join("\n        ") : "        pass";
        return "class " + stmt.name + ":\n    def __init__(self, " + params + "):\n" + init_body;
    }
    
    if (stmt.kind === NODE_IF) {
        let cond = CodeGenerator_gen_expr_py(self, stmt.condition);
        let cons = CodeGenerator_gen_block_py(self, stmt.consequence);
        let result = "if " + cond + ":\n" + cons;
        if (stmt.alternative) {
            result += "else:\n" + CodeGenerator_gen_block_py(self, stmt.alternative);
        }
        return result;
    }
    
    if (stmt.expr) {
        return CodeGenerator_gen_expr_py(self, stmt.expr);
    }
    
    // Interface generates ABC in Python
    if (stmt.kind === NODE_INTERFACE) {
        let out = "from abc import ABC, abstractmethod\n\n";
        out += "class " + stmt.name + "(ABC):\n";
        if (stmt.methods && stmt.methods.length > 0) {
            for (const m of stmt.methods) {
                let params_str = m.params ? ", " + m.params.map(p => p.name).join(", ") : "";
                out += "    @abstractmethod\n";
                out += "    def " + m.name + "(self" + params_str + "):\n";
                out += "        pass\n\n";
            }
        } else {
            out += "    pass\n";
        }
        return out;
    }
    
    // Impl generates class that inherits from interface
    if (stmt.kind === NODE_IMPL) {
        let out = "# impl " + stmt.interface_name + " for " + stmt.struct_name + "\n";
        if (stmt.methods) {
            for (const m of stmt.methods) {
                let params = m.params ? ", " + m.params.join(", ") : "";
                let body = CodeGenerator_gen_block_py(self, m.body);
                out += stmt.struct_name + "." + m.name + " = lambda self" + params + ": None\n";
                out += "def " + stmt.struct_name + "_" + m.name + "(self" + params + "):\n" + body;
                out += stmt.struct_name + "." + m.name + " = " + stmt.struct_name + "_" + m.name + "\n";
            }
        }
        return out;
    }
    
    return "# Unknown stmt kind: " + stmt.kind;
}

function CodeGenerator_gen_block_py(self, block) {
    let out = "";
    if (!block || !block.statements || block.statements.length === 0) {
        return "    pass\n";
    }
    for (const s of block.statements) {
        out = out + "    " + CodeGenerator_gen_stmt_py(self, s) + "\n";
    }
    return out;
}

function CodeGenerator_gen_expr_py(self, expr) {
    if (expr === 0 || expr === null || expr === undefined) return "None";
    
    if (expr.kind === NODE_LITERAL) {
        if (expr.value === "true") return "True";
        if (expr.value === "false") return "False";
        if (expr.value === "null") return "None";
        return expr.value;
    }
    
    if (expr.kind === NODE_STRING) {
        return '"' + expr.value + '"';
    }
    
    if (expr.kind === NODE_BOOL) {
        return expr.value ? "True" : "False";
    }
    
    if (expr.kind === NODE_BINARY) {
        let op = expr.op;
        if (op === "&&") op = "and";
        if (op === "||") op = "or";
        return CodeGenerator_gen_expr_py(self, expr.left) + " " + op + " " + CodeGenerator_gen_expr_py(self, expr.right);
    }
    
    if (expr.kind === NODE_IDENTIFIER) {
        return expr.value;
    }
    
    if (expr.kind === NODE_CALL) {
        let args = [];
        if (expr.args) {
            for (const a of expr.args) {
                args.push(CodeGenerator_gen_expr_py(self, a));
            }
        }
        return CodeGenerator_gen_expr_py(self, expr.function) + "(" + args.join(", ") + ")";
    }
    
    if (expr.kind === NODE_STRUCT_INIT) {
        let args = [];
        if (expr.fields) {
            for (const f of expr.fields) {
                args.push(f.name + "=" + CodeGenerator_gen_expr_py(self, f.value));
            }
        }
        return expr.name + "(" + args.join(", ") + ")";
    }
    
    if (expr.kind === NODE_MEMBER) {
        return CodeGenerator_gen_expr_py(self, expr.target) + "." + expr.property;
    }
    
    if (typeof expr === "string") return expr;
    return String(expr);
}

module.exports = { new_code_generator, CodeGenerator_generate, CodeGenerator_generate_python, CodeGenerator_gen_statement, CodeGenerator_gen_import, CodeGenerator_gen_struct, CodeGenerator_gen_block, CodeGenerator_gen_expression, CodeGenerator_gen_stmt_py, CodeGenerator_gen_block_py, CodeGenerator_gen_expr_py, CodeGenerator };

Object.assign(global, ast);
Object.assign(global, token);
Object.assign(global, token);
