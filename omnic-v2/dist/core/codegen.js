BlockLoop: 66 (return)
BlockLoop: 64 (if)
BlockLoop: 28 (==)
BlockLoop: 12 (python)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 66 (return)
BlockLoop: 42 (()
BlockLoop: 10 (program)
BlockLoop: 43 ())
BlockLoop: 61 (let)
BlockLoop: 80 (native)
BlockLoop: 80 (native)
BlockLoop: 61 (let)
BlockLoop: 80 (native)
BlockLoop: 66 (return)
BlockLoop: 61 (let)
BlockLoop: 80 (native)
BlockLoop: 64 (if)
BlockLoop: 28 (==)
BlockLoop: 11 (91)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 66 (return)
BlockLoop: 61 (let)
BlockLoop: 61 (let)
BlockLoop: 80 (native)
BlockLoop: 80 (native)
BlockLoop: 66 (return)
BlockLoop: 61 (let)
BlockLoop: 80 (native)
BlockLoop: 66 (return)
BlockLoop: 64 (if)
BlockLoop: 43 ())
BlockLoop: 66 (return)
BlockLoop: 64 (if)
BlockLoop: 28 (==)
BlockLoop: 10 (NODE_LITERAL)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 64 (if)
BlockLoop: 28 (==)
BlockLoop: 12 (true)
BlockLoop: 43 ())
BlockLoop: 66 (return)
BlockLoop: 64 (if)
BlockLoop: 28 (==)
BlockLoop: 12 (false)
BlockLoop: 43 ())
BlockLoop: 66 (return)
BlockLoop: 64 (if)
BlockLoop: 28 (==)
BlockLoop: 12 (null)
BlockLoop: 43 ())
BlockLoop: 66 (return)
BlockLoop: 66 (return)
BlockLoop: 31 (.)
BlockLoop: 10 (value)
BlockLoop: 64 (if)
BlockLoop: 28 (==)
BlockLoop: 10 (NODE_IMPORT)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 66 (return)
BlockLoop: 42 (()
BlockLoop: 10 (stmt)
BlockLoop: 43 ())
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (path)
BlockLoop: 80 (native)
BlockLoop: 66 (return)
BlockLoop: 61 (let)
BlockLoop: 31 (.)
BlockLoop: 10 (name)
BlockLoop: 61 (let)
BlockLoop: 80 (native)
BlockLoop: 66 (return)
BlockLoop: 21 (+)
BlockLoop: 10 (name)
BlockLoop: 21 (+)
BlockLoop: 12 ( {\n    constructor(data = {}) {\n)
BlockLoop: 21 (+)
BlockLoop: 10 (assignments)
BlockLoop: 21 (+)
BlockLoop: 12 (    }\n})
BlockLoop: 61 (let)
BlockLoop: 80 (native)
BlockLoop: 10 (out)
BlockLoop: 21 (+)
BlockLoop: 12 (})
BlockLoop: 66 (return)
BlockLoop: 64 (if)
BlockLoop: 43 ())
BlockLoop: 66 (return)
BlockLoop: 64 (if)
BlockLoop: 28 (==)
BlockLoop: 10 (NODE_LITERAL)
BlockLoop: 43 ())
BlockLoop: 66 (return)
BlockLoop: 31 (.)
BlockLoop: 10 (value)
BlockLoop: 64 (if)
BlockLoop: 28 (==)
BlockLoop: 10 (NODE_STRING)
BlockLoop: 43 ())
BlockLoop: 44 ({)
BlockLoop: 66 (return)
BlockLoop: 21 (+)
BlockLoop: 10 (expr)
BlockLoop: 31 (.)
BlockLoop: 10 (value)
BlockLoop: 21 (+)
BlockLoop: 12 (')
BlockLoop: 61 (let)
BlockLoop: 80 (native)
BlockLoop: 66 (return)
const ast = require("./ast.js");
const token = require("./token.js");
class CodeGenerator {
    constructor(data = {}) {
        this.target = data.target;
        this.indent = data.indent;
    }
}
function new_code_generator(target) {
    return new CodeGenerator({ target: target, indent: 0 });
}
function CodeGenerator_generate(self, program) {
    if (self) {
    target;
}
    // Unknown stmt kind: 0
    "python";
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    return CodeGenerator_generate_python;
    self;
    program;
    // Unknown stmt kind: 0
}
const output = "";

        if (program && program.statements) {
            for (const stmt of program.statements) {
                output = output + CodeGenerator_gen_statement(self, stmt) + "\n";
            }
        }
    
const exports = [];

        if (program && program.statements) {
             for (const stmt of program.statements) {
                 if (stmt.is_exported && stmt.name) {
                     exports.push(stmt.name);
                 }
             }
        }
        if (exports.length > 0) {
            output += "\nmodule.exports = { " + exports.join(", ") + " };\n";
        }
    
return output;
// Unknown stmt kind: undefined
function CodeGenerator_generate_python(self, program) {
    const output = "";
    
        output = "# Generated by Omni Compiler\n\n";
        output += "# Decorator stubs\n";
        output += "def entity(cls):\n    return cls\n\n";
        output += "def ui(*args, **kwargs):\n    def decorator(func):\n        return func\n    return decorator\n\n";
    
    
        if (program && program.statements) {
            for (const stmt of program.statements) {
                self.indent = 0; // Reset indent for each top-level statement
                output = output + CodeGenerator_gen_stmt_py(self, stmt) + "\n";
            }
        }
    
    const py_exports = [];
    
        if (program && program.statements) {
             for (const stmt of program.statements) {
                 if (stmt.is_exported && stmt.name) {
                     py_exports.push("'" + stmt.name + "'");
                 }
             }
        }
        if (py_exports.length > 0) {
            output += "\n__all__ = [" + py_exports.join(", ") + "]\n";
        }
    
    return output;
}
function CodeGenerator_gen_stmt_py(self, stmt) {
    const indent_str = "";
     indent_str = "    ".repeat(self.indent); 
    if (stmt) {
    kind;
}
    // Unknown stmt kind: 0
    91;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    return "";
}
if (stmt) {
    kind;
}
const path = stmt;
const name = "";

             path = path.replace(".omni", "");
             path = path.replace(/\//g, "."); // core/token -> core.token
             if (path.startsWith(".")) path = path.substring(1); // ./core -> /core -> core (fix logic later if needed)
             if (path.startsWith(".")) path = path.substring(1);
             name = path.split(".").pop();
        
return indent_str;
// Unknown stmt kind: undefined
if (stmt) {
    kind;
}
if (stmt) {
    lang;
}
return stmt;
// Unknown stmt kind: undefined
return "";
// Unknown stmt kind: undefined
if (stmt) {
    kind;
}
return indent_str;
// Unknown stmt kind: undefined
if (stmt) {
    kind;
}
return indent_str;
// Unknown stmt kind: undefined
if (stmt) {
    kind;
}
const decorators = CodeGenerator_gen_decorators_py;
const params = "";
 params = stmt.params.join(", "); 
const decl = indent_str;
const body = CodeGenerator_gen_block_py;
return decorators;
// Unknown stmt kind: undefined
if (stmt) {
    kind;
}
const decorators = CodeGenerator_gen_decorators_py;
const decl = indent_str;
const init_indent = "";
 init_indent = "    ".repeat(self.indent); 
const assignments = "";

             if (stmt.fields.length == 0) {
                 assignments = init_indent + "    pass";
             } else {
                 for(let f of stmt.fields) {
                     assignments += init_indent + "    self." + f.name + " = data.get('" + f.name + "')\n";
                 }
             }
        
const init_fn = init_indent;
return decorators;
// Unknown stmt kind: undefined
if (stmt) {
    kind;
}
const cond = CodeGenerator_gen_expr_py;
const out = indent_str;
if (stmt) {
    alternative;
}
// Unknown stmt kind: undefined
return out;
// Unknown stmt kind: undefined
if (stmt) {
    kind;
}
const cond = CodeGenerator_gen_expr_py;
const out = indent_str;
return out;
// Unknown stmt kind: undefined
if (stmt) {
    expr;
}
return indent_str;
// Unknown stmt kind: undefined
return indent_str;
// Unknown stmt kind: undefined
function CodeGenerator_gen_decorators_py(self, decorators) {
    const out = "";
    const indent_str = "";
     indent_str = "    ".repeat(self.indent); 
    
        if (decorators && decorators.length > 0) {
             for (let d of decorators) {
                 let args = "";
                 if (d.args && d.args.length > 0) {
                     let arg_list = [];
                     for (let a of d.args) {
                         // struct init fields: {name: "x", value: expr}
                         let val = CodeGenerator_gen_expr_py(self, a.value);
                         if (a.name && a.name !== "") {
                             arg_list.push(a.name + "=" + val);
                         } else {
                             arg_list.push(val);
                         }
                     }
                     args = "(" + arg_list.join(", ") + ")";
                 }
                 out += indent_str + "@" + d.name + args + "\n";
             }
        }
    
    return out;
}
function CodeGenerator_gen_block_py(self, block) {
    const out = "";
    
        if (!block.statements || block.statements.length == 0) {
             out = "    ".repeat(self.indent) + "pass";
        } else {
             for (const s of block.statements) {
                  out = out + CodeGenerator_gen_stmt_py(self, s) + "\n";
             }
        }
    
    return out;
}
function CodeGenerator_gen_expr_py(self, expr) {
    if (expr) {
    0;
}
    // Unknown stmt kind: 0
    return "None";
    if (expr) {
    kind;
}
    // Unknown stmt kind: 0
    NODE_LITERAL;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    if (expr) {
    value;
}
    // Unknown stmt kind: 0
    "true";
    // Unknown stmt kind: 0
    return "True";
    if (expr) {
    value;
}
    // Unknown stmt kind: 0
    "false";
    // Unknown stmt kind: 0
    return "False";
    if (expr) {
    value;
}
    // Unknown stmt kind: 0
    "null";
    // Unknown stmt kind: 0
    return "None";
    return expr;
    // Unknown stmt kind: 0
    value;
}
if (expr) {
    kind;
}
return "'";
// Unknown stmt kind: undefined
if (expr) {
    kind;
}
if (expr) {
    value;
}
return "True";
// Unknown stmt kind: undefined
return "False";
// Unknown stmt kind: undefined
if (expr) {
    kind;
}
const op = expr;
if (op) {
    "&&";
}
if (op) {
    "||";
}
if (op) {
    "!";
}
return CodeGenerator_gen_expr_py;
// Unknown stmt kind: undefined
if (expr) {
    kind;
}
const callee = CodeGenerator_gen_expr_py;
const args = "";

            let list = [];
            for(let a of expr.args) list.push(CodeGenerator_gen_expr_py(self, a));
            args = list.join(", ");
        
return callee;
// Unknown stmt kind: undefined
if (expr) {
    kind;
}
return CodeGenerator_gen_expr_py;
// Unknown stmt kind: undefined
if (expr) {
    kind;
}
const fields = "";

              let list = [];
              for(let f of expr.fields) {
                   list.push("'" + f.name + "': " + CodeGenerator_gen_expr_py(self, f.value));
              }
              fields = list.join(", ");
         
return expr;
// Unknown stmt kind: undefined
if (expr) {
    kind;
}
const elems = "";

             let list = [];
             for (let e of expr.elements) list.push(CodeGenerator_gen_expr_py(self, e));
             elems = list.join(", ");
         
return "[";
// Unknown stmt kind: undefined
if (expr) {
    kind;
}
return expr;
if (expr) {
    kind;
}
return CodeGenerator_gen_expr_py;
// Unknown stmt kind: undefined
 if (typeof(expr) == "string") return expr; 
return "None";
// Unknown stmt kind: undefined
function CodeGenerator_gen_statement(self, stmt) {
    if (stmt) {
    kind;
}
    // Unknown stmt kind: 0
    NODE_IMPORT;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    return CodeGenerator_gen_import;
    self;
    stmt;
    // Unknown stmt kind: 0
}
if (stmt) {
    kind;
}
if (stmt) {
    lang;
}
return stmt;
// Unknown stmt kind: undefined
return "";
// Unknown stmt kind: undefined
if (stmt) {
    kind;
}
return "let ";
// Unknown stmt kind: undefined
if (stmt) {
    kind;
}
return "return ";
// Unknown stmt kind: undefined
if (stmt) {
    kind;
}
const params = "";
 params = stmt.params.join(", "); 
const body = CodeGenerator_gen_block;
const decl = "function ";
const decorators_code = CodeGenerator_gen_decorators;
if (decorators_code) {
    "";
}
// Unknown stmt kind: undefined
return decl;
// Unknown stmt kind: undefined
if (stmt) {
    kind;
}
const decl = CodeGenerator_gen_struct;
const decorators_code = CodeGenerator_gen_decorators;
if (decorators_code) {
    "";
}
// Unknown stmt kind: undefined
return decl;
// Unknown stmt kind: undefined
if (stmt) {
    kind;
}
const cond = CodeGenerator_gen_expression;
const cons = CodeGenerator_gen_block;
const alt = "";
if (stmt) {
    alternative;
}
// Unknown stmt kind: undefined
return "if (";
// Unknown stmt kind: undefined
if (stmt) {
    kind;
}
const cond = CodeGenerator_gen_expression;
const body = CodeGenerator_gen_block;
return "while (";
// Unknown stmt kind: undefined
if (stmt) {
    expr;
}
return CodeGenerator_gen_expression;
// Unknown stmt kind: undefined
return "// Unknown stmt kind: ";
// Unknown stmt kind: undefined
function CodeGenerator_gen_import(self, stmt) {
    const path = stmt;
    // Unknown stmt kind: 0
    path;
    
        path = path.replace(".omni", ".js");
        if (path.startsWith(".") == false) path = "./" + path;
        // Extrai nome do arquivo para variÃ¡vel: "./core/token.js" -> "token"
        let name = path.split("/").pop().replace(".js", "");
        // Gera: const token = require("./token.js");
        return "const " + name + " = require(\"" + path + "\");\n" +
               "if (typeof global !== 'undefined') Object.assign(global, " + name + ");";
    
    return "";
}
function CodeGenerator_gen_struct(self, stmt) {
    const name = stmt;
    // Unknown stmt kind: 0
    name;
    const assignments = "";
    
        for (const field of stmt.fields) {
             assignments = assignments + "        this." + field.name + " = data." + field.name + ";\n";
        }
    
    return "class ";
    // Unknown stmt kind: 0
    name;
    // Unknown stmt kind: 0
    " {\n    constructor(data = {}) {\n";
    // Unknown stmt kind: 0
    assignments;
    // Unknown stmt kind: 0
    "    }\n}";
}
function CodeGenerator_gen_block(self, block) {
    const out = "{\n";
    
        if (block && block.statements) {
            for (const s of block.statements) {
                out = out + "    " + CodeGenerator_gen_statement(self, s) + "\n";
            }
        }
    
    out = out;
    // Unknown stmt kind: 0
    "}";
    return out;
}
function CodeGenerator_gen_expression(self, expr) {
    if (expr) {
    0;
}
    // Unknown stmt kind: 0
    return "null";
    if (expr) {
    kind;
}
    // Unknown stmt kind: 0
    NODE_LITERAL;
    // Unknown stmt kind: 0
    return expr;
    // Unknown stmt kind: 0
    value;
    if (expr) {
    kind;
}
    // Unknown stmt kind: 0
    NODE_STRING;
    // Unknown stmt kind: 0
    // Unknown stmt kind: 0
    return "'";
    // Unknown stmt kind: 0
    expr;
    // Unknown stmt kind: 0
    value;
    // Unknown stmt kind: 0
    "'";
}
if (expr) {
    kind;
}
if (expr) {
    value;
}
return "true";
// Unknown stmt kind: undefined
return "false";
// Unknown stmt kind: undefined
if (expr) {
    kind;
}
return CodeGenerator_gen_expression;
// Unknown stmt kind: undefined
if (expr) {
    kind;
}
const args = "";

             let list = [];
             for(let a of expr.args) list.push(CodeGenerator_gen_expression(self, a));
             args = list.join(", ");
         
const callee = CodeGenerator_gen_expression;
const is_class = false;

             if (typeof expr.function.value === 'string') {
                 let val = expr.function.value;
                 let first = val.charAt(0);
                 is_class = (first >= "A" && first <= "Z") && (val.indexOf("_") == -1);
             }
         
if (is_class) {
    return "new ";
}
return callee;
// Unknown stmt kind: undefined
if (expr) {
    kind;
}
return CodeGenerator_gen_expression;
// Unknown stmt kind: undefined
if (expr) {
    kind;
}
const fields = "";

            let list = [];
            for(let f of expr.fields) {
                list.push(f.name + ": " + CodeGenerator_gen_expression(self, f.value));
            }
            fields = list.join(", ");
        
return "new ";
// Unknown stmt kind: undefined
if (expr) {
    kind;
}
const elems = "";

            let list = [];
            for (let e of expr.elements) {
                list.push(CodeGenerator_gen_expression(self, e));
            }
            elems = list.join(", ");
        
return "[";
// Unknown stmt kind: undefined
if (expr) {
    kind;
}
return expr;
// Unknown stmt kind: undefined
if (expr) {
    kind;
}
const left = CodeGenerator_gen_expression;
const right = CodeGenerator_gen_expression;
const code = "";
 code = left + " = " + right; 
return code;
// Unknown stmt kind: undefined
 if (typeof(expr) == "string") return expr; 
return expr;
// Unknown stmt kind: undefined
function CodeGenerator_gen_decorators(self, target_name, decorators) {
    const out = "";
    
        if (decorators && decorators.length > 0) {
             let dec_list = [];
             for (let d of decorators) {
                 let args = "[]";
                 if (d.args && d.args.length > 0) {
                     let arg_list = [];
                     for (let a of d.args) {
                         // struct init fields: {name: "x", value: expr}
                         let val = CodeGenerator_gen_expression(self, a.value);
                         if (a.name && a.name !== "") {
                             arg_list.push('{ name: "' + a.name + '", value: ' + val + ' }');
                         } else {
                             arg_list.push('{ value: ' + val + ' }');
                         }
                     }
                     args = "[" + arg_list.join(", ") + "]";
                 }
                 dec_list.push('{ name: "' + d.name + '", args: ' + args + ' }');
             }
             out = target_name + ".decorators = [" + dec_list.join(", ") + "];";
        }
    
    return out;
}


// Auto-exports
if (typeof exports !== 'undefined') {
    exports.new_code_generator = new_code_generator;
    exports.CodeGenerator_generate = CodeGenerator_generate;
    exports.CodeGenerator_generate_python = CodeGenerator_generate_python;
    exports.CodeGenerator_gen_stmt_py = CodeGenerator_gen_stmt_py;
    exports.CodeGenerator_gen_decorators_py = CodeGenerator_gen_decorators_py;
    exports.CodeGenerator_gen_block_py = CodeGenerator_gen_block_py;
    exports.CodeGenerator_gen_expr_py = CodeGenerator_gen_expr_py;
    exports.CodeGenerator_gen_statement = CodeGenerator_gen_statement;
    exports.CodeGenerator_gen_import = CodeGenerator_gen_import;
    exports.CodeGenerator_gen_struct = CodeGenerator_gen_struct;
    exports.CodeGenerator_gen_block = CodeGenerator_gen_block;
    exports.CodeGenerator_gen_expression = CodeGenerator_gen_expression;
    exports.CodeGenerator_gen_decorators = CodeGenerator_gen_decorators;
    exports.CodeGenerator = CodeGenerator;
}
