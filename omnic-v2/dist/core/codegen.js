// Generated by Omni Compiler
'use strict';

let ast = require('./ast.js');
let token = require('./token.js');

class CodeGenerator {
    constructor(data = {}) {
    }
}

function new_code_generator() {
    return new CodeGenerator({  });
}

function CodeGenerator_generate(self, program) {
    let output = "";
if (program && program.statements) {
            for (const stmt of program.statements) {
                output = output + CodeGenerator_gen_statement(self, stmt) + "\n";
            }
        }
    
    // Auto-Export Logic - based on is_exported flag
    let exports = [];
    if (program && program.statements) {
         for (const stmt of program.statements) {
             if (stmt.is_exported && stmt.name) {
                 exports.push(stmt.name);
             }
         }
    }
    if (exports.length > 0) {
        output += "\nmodule.exports = { " + exports.join(", ") + " };\n";
    }

    return output;
}

function CodeGenerator_gen_statement(self, stmt) {
    if ((stmt.kind === NODE_IMPORT)) {
    return CodeGenerator_gen_import(self, stmt);
}

    if ((stmt.kind === 80)) {
    // Only emit JS native blocks
    if (stmt.lang === "js" || stmt.lang === "javascript") {
        return stmt.code;
    }
    return "";
}

    if ((stmt.kind === NODE_LET)) {
    return (((("let " + stmt.name) + " = ") + CodeGenerator_gen_expression(self, stmt.value)) + ";");
}

    if ((stmt.kind === NODE_RETURN)) {
    return (("return " + CodeGenerator_gen_expression(self, stmt.value)) + ";");
}

    // NODE_SPAWN - parallel execution
    if (stmt.kind === 92) { // NODE_SPAWN
        const call = stmt.call;
        // Call expression might be NODE_CALL with callee or have name directly
        let fn_name = "unknown";
        let args = "";
        
        if (call) {
            // Try different ways to get function name
            if (call.name) fn_name = call.name;
            else if (call.callee && call.callee.value) fn_name = call.callee.value;
            else if (call.callee && call.callee.name) fn_name = call.callee.name;
            else if (call.value) fn_name = call.value;
            
            // Get arguments
            if (call.args) {
                args = call.args.map(a => CodeGenerator_gen_expression(self, a)).join(", ");
            } else if (call.arguments) {
                args = call.arguments.map(a => CodeGenerator_gen_expression(self, a)).join(", ");
            }
        }
        
        // Generate worker_threads spawn
        let out = "(() => {\n";
        out += "    const { Worker, isMainThread } = require('worker_threads');\n";
        out += "    const worker = new Worker(__filename, {\n";
        out += "        workerData: { fn: '" + fn_name + "', args: [" + args + "] }\n";
        out += "    });\n";
        out += "    worker.on('message', result => console.log('[spawn] " + fn_name + " done:', result));\n";
        out += "    worker.on('error', err => console.error('[spawn] " + fn_name + " error:', err));\n";
        out += "})()";
        return out;
    }

    // NODE_CAPSULE - Logic Container with topology-based routing
    if (stmt.kind === 93) { // NODE_CAPSULE
        const capsule_name = stmt.name;
        const flows = stmt.flows || [];
        
        let out = "// Capsule: " + capsule_name + "\n";
        out += "const " + capsule_name + " = {\n";
        out += "    _name: '" + capsule_name + "',\n";
        out += "    _flows: [" + flows.map(f => "'" + f.name + "'").join(", ") + "],\n\n";
        
        for (const flow of flows) {
            const params = flow.params.map(p => p.name).join(", ");
            
            // Generate dynamic bridge (will resolve at runtime based on topology)
            out += "    async " + flow.name + "(" + params + ") {\n";
            out += "        // Dynamic topology routing\n";
            out += "        const resolver = global.TopologyResolver || require('./runtime.js').TopologyResolver;\n";
            out += "        const route = resolver.resolve('" + capsule_name + "');\n";
            out += "        \n";
            out += "        if (route.local) {\n";
            out += "            // Same node - direct call to implementation\n";
            out += "            return this._impl_" + flow.name + "(" + params + ");\n";
            out += "        } else {\n";
            out += "            // Different node - RPC call\n";
            out += "            const response = await fetch(route.url + '/" + capsule_name + "/" + flow.name + "', {\n";
            out += "                method: 'POST',\n";
            out += "                headers: { 'Content-Type': 'application/json' },\n";
            out += "                body: JSON.stringify({ " + flow.params.map(p => p.name + ": " + p.name).join(", ") + " })\n";
            out += "            });\n";
            out += "            return await response.json();\n";
            out += "        }\n";
            out += "    },\n\n";
            
            // Placeholder for implementation
            out += "    _impl_" + flow.name + "(" + params + ") {\n";
            out += "        throw new Error('" + capsule_name + "." + flow.name + " not implemented');\n";
            out += "    },\n\n";
        }
        
        out += "};\n";
        return out;
    }

    if ((stmt.kind === NODE_FUNCTION)) {
    let params = "";
params = stmt.params.join(", ");
    let body = CodeGenerator_gen_block(self, stmt.body);
    return ((((("function " + stmt.name) + "(") + params) + ") ") + body);
}

    if ((stmt.kind === NODE_STRUCT)) {
    return CodeGenerator_gen_struct(self, stmt);
}

    if ((stmt.kind === NODE_IF)) {
    let cond = CodeGenerator_gen_expression(self, stmt.condition);
    let cons = CodeGenerator_gen_block(self, stmt.consequence);
    let alt = "";
    if (stmt.alternative) {
    alt = (" else " + CodeGenerator_gen_block(self, stmt.alternative));
}

    return (((("if (" + cond) + ") ") + cons) + alt);
}

    if ((stmt.kind === NODE_WHILE)) {
    let cond = CodeGenerator_gen_expression(self, stmt.condition);
    let body = CodeGenerator_gen_block(self, stmt.body);
    return ((("while (" + cond) + ") ") + body);
}

    if (stmt.expr) {
    return (CodeGenerator_gen_expression(self, stmt.expr) + ";");
}

    // Interface declarations - check for @service attribute
    if (stmt.kind === NODE_INTERFACE) {
        // Check if this is a @service interface
        let is_service = false;
        let service_url = "";
        if (stmt.attributes) {
            for (const attr of stmt.attributes) {
                if (attr.name === "service") {
                    is_service = true;
                    service_url = attr.params.url || "";
                }
            }
        }
        
        if (is_service && service_url) {
            // Generate RPC client proxy
            let out = "// @service interface: " + stmt.name + " - RPC Client Proxy\n";
            out += "const " + stmt.name + " = {\n";
            if (stmt.methods) {
                for (const m of stmt.methods) {
                    let params_str = m.params ? m.params.map(p => p.name).join(", ") : "";
                    let args_obj = m.params ? m.params.map(p => p.name + ": " + p.name).join(", ") : "";
                    out += "    async " + m.name + "(" + params_str + ") {\n";
                    out += "        const response = await fetch(\"" + service_url + "/" + stmt.name + "/" + m.name + "\", {\n";
                    out += "            method: \"POST\",\n";
                    out += "            headers: { \"Content-Type\": \"application/json\" },\n";
                    out += "            body: JSON.stringify({ " + args_obj + " })\n";
                    out += "        });\n";
                    out += "        return await response.json();\n";
                    out += "    },\n";
                }
            }
            out += "};\n";
            return out;
        } else {
            // Generate JSDoc comments (normal interface)
            let methods_doc = "";
            if (stmt.methods) {
                for (const m of stmt.methods) {
                    let params_str = m.params ? m.params.map(p => p.name + ": " + p.type).join(", ") : "";
                    methods_doc += " * @method " + m.name + "(" + params_str + ") -> " + m.return_type + "\n";
                }
            }
            return "/**\n * @interface " + stmt.name + "\n" + methods_doc + " */";
        }
    }

    // Impl generates methods attached to struct prototype
    if (stmt.kind === NODE_IMPL) {
        // Check for @server attribute
        let is_server = false;
        let server_port = 3000;
        if (stmt.attributes) {
            for (const attr of stmt.attributes) {
                if (attr.name === "server") {
                    is_server = true;
                    server_port = attr.params.port || 3000;
                }
            }
        }
        
        let out = "// impl " + stmt.interface_name + " for " + stmt.struct_name + "\n";
        
        // Generate methods as prototype functions
        if (stmt.methods) {
            for (const m of stmt.methods) {
                let params = m.params ? m.params.join(", ") : "";
                let body = CodeGenerator_gen_block(self, m.body);
                out += stmt.struct_name + ".prototype." + m.name + " = function(" + params + ") " + body + "\n";
            }
        }
        
        // Generate server skeleton if @server
        if (is_server) {
            out += "\n// === Server Skeleton with FlightRecorder ===\n";
            out += "const http = require('http');\n";
            out += "const FlightRecorder = global.FlightRecorder || require('./lib/debug.js').FlightRecorder;\n\n";
            out += "const " + stmt.struct_name + "Instance = new " + stmt.struct_name + "();\n\n";
            out += "const server = http.createServer(async (req, res) => {\n";
            out += "    const url = new URL(req.url, `http://${req.headers.host}`);\n";
            out += "    const [, iface, method] = url.pathname.split('/');\n";
            out += "    \n";
            out += "    let body = '';\n";
            out += "    req.on('data', chunk => body += chunk);\n";
            out += "    req.on('end', async () => {\n";
            out += "        const traceId = FlightRecorder.start(iface + '.' + method);\n";
            out += "        try {\n";
            out += "            const args = JSON.parse(body || '{}');\n";
            out += "            const impl = " + stmt.struct_name + "Instance;\n";
            out += "            if (impl[method]) {\n";
            out += "                const result = await impl[method](...Object.values(args));\n";
            out += "                FlightRecorder.stop(traceId, { success: true });\n";
            out += "                res.writeHead(200, { 'Content-Type': 'application/json' });\n";
            out += "                res.end(JSON.stringify(result));\n";
            out += "            } else {\n";
            out += "                FlightRecorder.stop(traceId, { error: 'Method not found' });\n";
            out += "                res.writeHead(404);\n";
            out += "                res.end(JSON.stringify({ error: 'Method not found' }));\n";
            out += "            }\n";
            out += "        } catch (e) {\n";
            out += "            FlightRecorder.stop(traceId, { error: e.message });\n";
            out += "            res.writeHead(500);\n";
            out += "            res.end(JSON.stringify({ error: e.message }));\n";
            out += "        }\n";
            out += "    });\n";
            out += "});\n\n";
            out += "server.listen(" + server_port + ", () => {\n";
            out += "    console.log('[" + stmt.interface_name + " Server] Listening on port " + server_port + "');\n";
            out += "});\n\n";
            out += "// Save flight recorder on exit\n";
            out += "process.on('SIGINT', () => {\n";
            out += "    FlightRecorder.saveReport();\n";
            out += "    process.exit();\n";
            out += "});\n";
        }
        
        return out;
    }

    return ("// Unknown stmt kind: " + stmt.kind);
}

function CodeGenerator_gen_import(self, stmt) {
    let path = stmt.path;
path = path.replace(".omni", ".js");
        if (path.startsWith(".") == false) path = "./" + path;
        // Extrai nome do arquivo para variÃ¡vel: "./core/token.js" -> "token"
        let name = path.split("/").pop().replace(".js", "");
        // Gera: let token = require("./token.js");
        return "const " + name + " = require(\"" + path + "\");\nif (typeof global !== 'undefined') Object.assign(global, " + name + ");";
    return "";
}

function CodeGenerator_gen_struct(self, stmt) {
    let name = stmt.name;
    let assignments = "";
    for (const field of stmt.fields) {
        assignments = assignments + "        this." + field.name + " = data." + field.name + ";\n";
    }
    
    let out = "class " + name + " {\n    constructor(data = {}) {\n" + assignments + "    }\n}\n";
    
    // Check for @entity attribute
    let is_entity = false;
    let storage_name = "main_db";
    if (stmt.attributes) {
        for (const attr of stmt.attributes) {
            if (attr.name === "entity") {
                is_entity = true;
                storage_name = attr.params.storage || "main_db";
            }
        }
    }
    
    if (is_entity) {
        // Detect FK relationships (fields with uppercase type = entity reference)
        const primitives = ['i64', 'i32', 'f64', 'f32', 'string', 'bool'];
        const fkFields = stmt.fields.filter(f => !primitives.includes(f.typename) && f.name !== 'id');
        const regularFields = stmt.fields.filter(f => primitives.includes(f.typename) && f.name !== 'id');
        const allNonIdFields = stmt.fields.filter(f => f.name !== 'id');
        
        // For FK fields, use field_name as column (e.g., user_id stays user_id)
        const fieldNames = allNonIdFields.map(f => f.name);
        const placeholders = fieldNames.map(() => '?').join(', ');
        const updateSet = fieldNames.map(f => f + '=?').join(', ');
        
        out += "\n// @entity Repository: " + name + "\n";
        
        // Store FK metadata
        if (fkFields.length > 0) {
            out += name + "._relations = {\n";
            for (const fk of fkFields) {
                out += "    " + fk.name + ": { entity: '" + fk.typename + "', column: '" + fk.name + "' },\n";
            }
            out += "};\n\n";
        }
        
        // find(id) with eager loading option
        out += name + ".find = async (id, options = {}) => {\n";
        out += "    const db = await Database.get('" + storage_name + "');\n";
        out += "    const row = await db.get('SELECT * FROM " + name + " WHERE id = ?', [id]);\n";
        out += "    if (!row) return null;\n";
        out += "    const obj = new " + name + "(row);\n";
        // Add lazy loading getters for FK fields
        for (const fk of fkFields) {
            const relName = fk.name.replace('_id', '');
            out += "    // Lazy load " + relName + "\n";
            out += "    Object.defineProperty(obj, '" + relName + "', {\n";
            out += "        get: async function() {\n";
            out += "            if (!this._" + relName + ") this._" + relName + " = await " + fk.typename + ".find(this." + fk.name + ");\n";
            out += "            return this._" + relName + ";\n";
            out += "        }\n";
            out += "    });\n";
        }
        out += "    return obj;\n";
        out += "};\n\n";
        
        // findWith - eager loading
        if (fkFields.length > 0) {
            out += name + ".findWith = async (id, includes = []) => {\n";
            out += "    const obj = await " + name + ".find(id);\n";
            out += "    if (!obj) return null;\n";
            out += "    for (const rel of includes) {\n";
            for (const fk of fkFields) {
                const relName = fk.name.replace('_id', '');
                out += "        if (rel === '" + relName + "') obj._" + relName + " = await " + fk.typename + ".find(obj." + fk.name + ");\n";
            }
            out += "    }\n";
            out += "    return obj;\n";
            out += "};\n\n";
        }
        
        // save
        out += name + ".save = async (obj) => {\n";
        out += "    const db = await Database.get('" + storage_name + "');\n";
        out += "    if (obj.id) {\n";
        out += "        await db.run('UPDATE " + name + " SET " + updateSet + " WHERE id=?', [" + fieldNames.map(f => 'obj.' + f).join(', ') + ", obj.id]);\n";
        out += "    } else {\n";
        out += "        const r = await db.run('INSERT INTO " + name + " (" + fieldNames.join(', ') + ") VALUES (" + placeholders + ")', [" + fieldNames.map(f => 'obj.' + f).join(', ') + "]);\n";
        out += "        obj.id = r.lastID;\n";
        out += "    }\n";
        out += "    return obj;\n";
        out += "};\n\n";
        
        // all
        out += name + ".all = async () => {\n";
        out += "    const db = await Database.get('" + storage_name + "');\n";
        out += "    return (await db.all('SELECT * FROM " + name + "')).map(r => new " + name + "(r));\n";
        out += "};\n\n";
        
        // where (basic query builder)
        out += name + ".where = async (conditions) => {\n";
        out += "    const db = await Database.get('" + storage_name + "');\n";
        out += "    const keys = Object.keys(conditions);\n";
        out += "    const where = keys.map(k => k + ' = ?').join(' AND ');\n";
        out += "    const values = Object.values(conditions);\n";
        out += "    return (await db.all('SELECT * FROM " + name + " WHERE ' + where, values)).map(r => new " + name + "(r));\n";
        out += "};\n\n";
        
        // delete
        out += name + ".delete = async (id) => {\n";
        out += "    const db = await Database.get('" + storage_name + "');\n";
        out += "    await db.run('DELETE FROM " + name + " WHERE id = ?', [id]);\n";
        out += "};\n";
    }
    
    return out;
}

function CodeGenerator_gen_block(self, block) {
    let out = "{\n";
if (block && block.statements) {
            for (const s of block.statements) {
                out = out + "    " + CodeGenerator_gen_statement(self, s) + "\n";
            }
        }
    out = (out + "}");
    return out;
}

function CodeGenerator_gen_expression(self, expr) {
    if ((expr === 0)) {
    return "null";
}

    if ((expr.kind === NODE_LITERAL)) {
    return expr.value;
}

    if ((expr.kind === NODE_BINARY)) {
    return ((((CodeGenerator_gen_expression(self, expr.left) + " ") + expr.op) + " ") + CodeGenerator_gen_expression(self, expr.right));
}

    if ((expr.kind === NODE_CALL)) {
    let args = "";
let list = [];
             for(let a of expr.args) list.push(CodeGenerator_gen_expression(self, a));
             args = list.join(", ");
    let callee = CodeGenerator_gen_expression(self, expr.function);
    let is_class = false;
if (typeof expr.function.value === 'string') {
                 let val = expr.function.value;
                 let first = val.charAt(0);
                 is_class = (first >= "A" && first <= "Z") && (val.indexOf("_") == -1);
             }
    if (is_class) {
    return (((("new " + callee) + "(") + args) + ")");
}

    return (((callee + "(") + args) + ")");
}

    if ((expr.kind === NODE_MEMBER)) {
    return ((CodeGenerator_gen_expression(self, expr.target) + ".") + expr.property);
}

    if ((expr.kind === NODE_STRUCT_INIT)) {
    let fields = "";
let list = [];
            for(let f of expr.fields) {
                list.push(f.name + ": " + CodeGenerator_gen_expression(self, f.value));
            }
            fields = list.join(", ");
    return (((("new " + expr.name) + "({ ") + fields) + " })");
}

    if ((expr.kind === NODE_ARRAY)) {
    let elems = "";
let list = [];
            for (let e of expr.elements) {
                list.push(CodeGenerator_gen_expression(self, e));
            }
            elems = list.join(", ");
    return (("[" + elems) + "]");
}

    if ((expr.kind === NODE_IDENTIFIER)) {
    return expr.value;
}

    if ((expr.kind === NODE_ASSIGNMENT)) {
    let left = CodeGenerator_gen_expression(self, expr.left);
    let right = CodeGenerator_gen_expression(self, expr.right);
    let code = "";
code = left + " = " + right;
    return code;
}

if (typeof(expr) == "string") return expr;
    return expr;
}

function CodeGenerator_generate_python(self, program) {
    let output = "";
    if (program && program.statements) {
        for (const stmt of program.statements) {
            output = output + CodeGenerator_gen_stmt_py(self, stmt) + "\n";
        }
    }
    
    // Generate __all__ for exports
    let py_exports = [];
    if (program && program.statements) {
        for (const stmt of program.statements) {
            if (stmt.is_exported && stmt.name) {
                py_exports.push("'" + stmt.name + "'");
            }
        }
    }
    if (py_exports.length > 0) {
        output += "\n__all__ = [" + py_exports.join(", ") + "]\n";
    }
    
    return output;
}

function CodeGenerator_gen_stmt_py(self, stmt) {
    if (stmt.kind === NODE_IMPORT) {
        let path = stmt.path.replace(".omni", "");
        if (path.includes("/")) {
            let parts = path.split("/");
            let name = parts[parts.length - 1];
            return "import " + name;
        }
        return "import " + path;
    }
    
    if (stmt.kind === 80) { // NATIVE
        if (stmt.lang === "python" || stmt.lang === "py") {
            return stmt.code;
        }
        return "";
    }
    
    if (stmt.kind === NODE_LET) {
        return stmt.name + " = " + CodeGenerator_gen_expr_py(self, stmt.value);
    }
    
    if (stmt.kind === NODE_RETURN) {
        return "return " + CodeGenerator_gen_expr_py(self, stmt.value);
    }
    
    if (stmt.kind === NODE_FUNCTION) {
        let params = stmt.params.join(", ");
        let body = CodeGenerator_gen_block_py(self, stmt.body);
        return "def " + stmt.name + "(" + params + "):\n" + body;
    }
    
    if (stmt.kind === NODE_STRUCT) {
        // Check for @entity attribute
        let is_entity = false;
        let storage_name = "main_db";
        if (stmt.attributes) {
            for (const attr of stmt.attributes) {
                if (attr.name === "entity") {
                    is_entity = true;
                    storage_name = attr.params.storage || "main_db";
                }
            }
        }
        
        if (is_entity) {
            // Generate SQLAlchemy model
            const primitives = ['i64', 'i32', 'f64', 'f32', 'string', 'bool'];
            const typeMapPy = {
                'i64': 'Integer',
                'i32': 'Integer',
                'f64': 'Float',
                'f32': 'Float',
                'string': 'String(255)',
                'bool': 'Boolean'
            };
            
            let out = "from sqlalchemy import Column, Integer, String, Float, Boolean, ForeignKey\n";
            out += "from sqlalchemy.orm import relationship\n\n";
            out += "class " + stmt.name + "(Base):\n";
            out += "    __tablename__ = '" + stmt.name.toLowerCase() + "'\n";
            
            for (const field of stmt.fields) {
                if (field.name === 'id') {
                    out += "    id = Column(Integer, primary_key=True, autoincrement=True)\n";
                } else if (!primitives.includes(field.typename)) {
                    // Foreign key
                    out += "    " + field.name + " = Column(Integer, ForeignKey('" + field.typename.toLowerCase() + ".id'))\n";
                    const relName = field.name.replace('_id', '');
                    out += "    " + relName + " = relationship('" + field.typename + "')\n";
                } else {
                    const pyType = typeMapPy[field.typename] || 'String(255)';
                    out += "    " + field.name + " = Column(" + pyType + ")\n";
                }
            }
            
            // Add class methods for repository pattern
            out += "\n    @classmethod\n";
            out += "    def find(cls, session, id):\n";
            out += "        return session.query(cls).filter(cls.id == id).first()\n";
            out += "\n    @classmethod\n";
            out += "    def all(cls, session):\n";
            out += "        return session.query(cls).all()\n";
            out += "\n    @classmethod\n";
            out += "    def where(cls, session, **conditions):\n";
            out += "        q = session.query(cls)\n";
            out += "        for k, v in conditions.items():\n";
            out += "            q = q.filter(getattr(cls, k) == v)\n";
            out += "        return q.all()\n";
            out += "\n    def save(self, session):\n";
            out += "        session.add(self)\n";
            out += "        session.commit()\n";
            out += "        return self\n";
            out += "\n    def delete(self, session):\n";
            out += "        session.delete(self)\n";
            out += "        session.commit()\n";
            
            return out;
        } else {
            // Regular class (non-entity)
            let fields = [];
            if (stmt.fields) {
                for (const f of stmt.fields) {
                    fields.push("self." + f.name + " = " + f.name);
                }
            }
            let params = stmt.fields ? stmt.fields.map(f => f.name + "=None").join(", ") : "";
            let init_body = fields.length > 0 ? "        " + fields.join("\n        ") : "        pass";
            return "class " + stmt.name + ":\n    def __init__(self, " + params + "):\n" + init_body;
        }
    }
    
    if (stmt.kind === NODE_IF) {
        let cond = CodeGenerator_gen_expr_py(self, stmt.condition);
        let cons = CodeGenerator_gen_block_py(self, stmt.consequence);
        let result = "if " + cond + ":\n" + cons;
        if (stmt.alternative) {
            result += "else:\n" + CodeGenerator_gen_block_py(self, stmt.alternative);
        }
        return result;
    }
    
    if (stmt.expr) {
        return CodeGenerator_gen_expr_py(self, stmt.expr);
    }
    
    // Interface generates ABC in Python
    if (stmt.kind === NODE_INTERFACE) {
        let out = "from abc import ABC, abstractmethod\n\n";
        out += "class " + stmt.name + "(ABC):\n";
        if (stmt.methods && stmt.methods.length > 0) {
            for (const m of stmt.methods) {
                let params_str = m.params ? ", " + m.params.map(p => p.name).join(", ") : "";
                out += "    @abstractmethod\n";
                out += "    def " + m.name + "(self" + params_str + "):\n";
                out += "        pass\n\n";
            }
        } else {
            out += "    pass\n";
        }
        return out;
    }
    
    // Impl generates class that inherits from interface
    if (stmt.kind === NODE_IMPL) {
        let out = "# impl " + stmt.interface_name + " for " + stmt.struct_name + "\n";
        if (stmt.methods) {
            for (const m of stmt.methods) {
                let params = m.params ? ", " + m.params.join(", ") : "";
                let body = CodeGenerator_gen_block_py(self, m.body);
                out += stmt.struct_name + "." + m.name + " = lambda self" + params + ": None\n";
                out += "def " + stmt.struct_name + "_" + m.name + "(self" + params + "):\n" + body;
                out += stmt.struct_name + "." + m.name + " = " + stmt.struct_name + "_" + m.name + "\n";
            }
        }
        return out;
    }
    
    return "# Unknown stmt kind: " + stmt.kind;
}

function CodeGenerator_gen_block_py(self, block) {
    let out = "";
    if (!block || !block.statements || block.statements.length === 0) {
        return "    pass\n";
    }
    for (const s of block.statements) {
        out = out + "    " + CodeGenerator_gen_stmt_py(self, s) + "\n";
    }
    return out;
}

function CodeGenerator_gen_expr_py(self, expr) {
    if (expr === 0 || expr === null || expr === undefined) return "None";
    
    if (expr.kind === NODE_LITERAL) {
        if (expr.value === "true") return "True";
        if (expr.value === "false") return "False";
        if (expr.value === "null") return "None";
        return expr.value;
    }
    
    if (expr.kind === NODE_STRING) {
        return '"' + expr.value + '"';
    }
    
    if (expr.kind === NODE_BOOL) {
        return expr.value ? "True" : "False";
    }
    
    if (expr.kind === NODE_BINARY) {
        let op = expr.op;
        if (op === "&&") op = "and";
        if (op === "||") op = "or";
        return CodeGenerator_gen_expr_py(self, expr.left) + " " + op + " " + CodeGenerator_gen_expr_py(self, expr.right);
    }
    
    if (expr.kind === NODE_IDENTIFIER) {
        return expr.value;
    }
    
    if (expr.kind === NODE_CALL) {
        let args = [];
        if (expr.args) {
            for (const a of expr.args) {
                args.push(CodeGenerator_gen_expr_py(self, a));
            }
        }
        return CodeGenerator_gen_expr_py(self, expr.function) + "(" + args.join(", ") + ")";
    }
    
    if (expr.kind === NODE_STRUCT_INIT) {
        let args = [];
        if (expr.fields) {
            for (const f of expr.fields) {
                args.push(f.name + "=" + CodeGenerator_gen_expr_py(self, f.value));
            }
        }
        return expr.name + "(" + args.join(", ") + ")";
    }
    
    if (expr.kind === NODE_MEMBER) {
        return CodeGenerator_gen_expr_py(self, expr.target) + "." + expr.property;
    }
    
    if (typeof expr === "string") return expr;
    return String(expr);
}

module.exports = { new_code_generator, CodeGenerator_generate, CodeGenerator_generate_python, CodeGenerator_gen_statement, CodeGenerator_gen_import, CodeGenerator_gen_struct, CodeGenerator_gen_block, CodeGenerator_gen_expression, CodeGenerator_gen_stmt_py, CodeGenerator_gen_block_py, CodeGenerator_gen_expr_py, CodeGenerator };

Object.assign(global, ast);
Object.assign(global, token);
Object.assign(global, token);
