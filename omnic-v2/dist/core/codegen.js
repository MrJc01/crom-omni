// Generated by Omni Compiler
'use strict';

const ast = require('./ast.js');
const token = require('./token.js');

class CodeGenerator {
    constructor(data = {}) {
        this.target = data.target;
        this.indent = data.indent;
    }
}

function new_code_generator(target) {
    return new CodeGenerator({ target: target, indent: 0 });
}

function CodeGenerator_generate(self, program) {
    if (self.target === "python") {
    return CodeGenerator_generate_python(self, program);
}

    let output = "";
    if (program && program.statements) {
            for (const stmt of program.statements) {
                output = output + CodeGenerator_gen_statement(self, stmt) + "\n";
            }
        }
    let exports = [];
if (program && program.statements) {
             for (const stmt of program.statements) {
                 if (stmt.is_exported && stmt.name) {
                     exports.push(stmt.name);
                 }
             }
        }
        if (exports.length > 0) {
            output += "\nmodule.exports = { " + exports.join(", ") + " };\n";
        }
    return output;
}

function CodeGenerator_generate_python(self, program) {
    // Python header with common decorator stubs
    let output = "# Generated by Omni Compiler\n\n";
    output += "# Decorator stubs\n";
    output += "def entity(cls):\n    return cls\n\n";
    output += "def ui(*args, **kwargs):\n    def decorator(func):\n        return func\n    return decorator\n\n";
    
if (program && program.statements) {
            for (const stmt of program.statements) {
                self.indent = 0; // Reset indent for each top-level statement
                output = output + CodeGenerator_gen_stmt_py(self, stmt) + "\n";
            }
        }
    let py_exports = [];
if (program && program.statements) {
             for (const stmt of program.statements) {
                 if (stmt.is_exported && stmt.name) {
                     py_exports.push("'" + stmt.name + "'");
                 }
             }
        }
        if (py_exports.length > 0) {
            output += "\n__all__ = [" + py_exports.join(", ") + "]\n";
        }
    // Add main entry point if main function exists
    output += '\nif __name__ == "__main__":\n    main()\n';
    return output;
}

function CodeGenerator_gen_stmt_py(self, stmt) {
    let indent_str = "";
indent_str = "    ".repeat(self.indent);
    if (stmt.kind === 91) {
    return "";
}

    if (stmt.kind === NODE_IMPORT) {
    let path = stmt.path;
    let name = "";
path = path.replace(".omni", "");
             path = path.replace(/\//g, "."); // core/token -> core.token
             if (path.startsWith(".")) path = path.substring(1); // ./core -> /core -> core (fix logic later if needed)
             if (path.startsWith(".")) path = path.substring(1);
             name = path.split(".").pop();
    return indent_str + "import " + path + " as " + name;
}

    if (stmt.kind === 80) {
    if (stmt.lang === "py" || stmt.lang === "python") {
    // Apply indentation to each line of native code
    let lines = stmt.code.split("\n");
    let indented = [];
    for (let line of lines) {
        if (line.trim() !== "") {
            indented.push(indent_str + line.trimStart());
        }
    }
    return indented.join("\n");
}

    return "";
}

    if (stmt.kind === NODE_LET) {
    return indent_str + stmt.name + " = " + CodeGenerator_gen_expr_py(self, stmt.value);
}

    if (stmt.kind === NODE_RETURN) {
    return indent_str + "return " + CodeGenerator_gen_expr_py(self, stmt.value);
}

    if (stmt.kind === NODE_FUNCTION) {
    let params = "";
params = stmt.params.join(", ");
    let decl = indent_str + "def " + stmt.name + "(" + params + "):\n";
    self.indent = self.indent + 1;
    let body = CodeGenerator_gen_block_py(self, stmt.body);
    self.indent = self.indent - 1;
    return decl + body;
}

    if (stmt.kind === NODE_STRUCT) {
    let decl = indent_str + "class " + stmt.name + ":\n";
    self.indent = self.indent + 1;
    let init_indent = "";
init_indent = "    ".repeat(self.indent);
    let assignments = "";
if (stmt.fields.length == 0) {
                 assignments = init_indent + "    pass";
             } else {
                 for(let f of stmt.fields) {
                     assignments += init_indent + "    self." + f.name + " = data.get('" + f.name + "')\n";
                 }
             }
    let init_fn = init_indent + "def __init__(self, data=None):\n";
    init_fn = init_fn + init_indent + "    if data is None: data = {}\n";
    init_fn = init_fn + assignments + "\n";
    self.indent = self.indent - 1;
    return decl + init_fn;
}

    if (stmt.kind === NODE_IF) {
    let cond = CodeGenerator_gen_expr_py(self, stmt.condition);
    let out = indent_str + "if " + cond + ":\n";
    self.indent = self.indent + 1;
    out = out + CodeGenerator_gen_block_py(self, stmt.consequence);
    self.indent = self.indent - 1;
    if (stmt.alternative) {
    out = out + "\n" + indent_str + "else:\n";
    self.indent = self.indent + 1;
    out = out + CodeGenerator_gen_block_py(self, stmt.alternative);
    self.indent = self.indent - 1;
}

    return out;
}

    if (stmt.kind === NODE_WHILE) {
    let cond = CodeGenerator_gen_expr_py(self, stmt.condition);
    let out = indent_str + "while " + cond + ":\n";
    self.indent = self.indent + 1;
    out = out + CodeGenerator_gen_block_py(self, stmt.body);
    self.indent = self.indent - 1;
    return out;
}

    if (stmt.expr) {
    return indent_str + CodeGenerator_gen_expr_py(self, stmt.expr);
}

    return indent_str + "# Unknown stmt: " + stmt.kind;
}

function CodeGenerator_gen_block_py(self, block) {
    let out = "";
if (!block.statements || block.statements.length == 0) {
             out = "    ".repeat(self.indent) + "pass";
        } else {
             for (const s of block.statements) {
                  out = out + CodeGenerator_gen_stmt_py(self, s) + "\n";
             }
        }
    return out;
}

function CodeGenerator_gen_expr_py(self, expr) {
    if (expr === 0) {
    return "None";
}

    if (expr.kind === NODE_LITERAL) {
    if (expr.value === "true") {
    return "True";
}

    if (expr.value === "false") {
    return "False";
}

    if (expr.value === "null") {
    return "None";
}

    return expr.value;
}

    if (expr.kind === NODE_STRING) {
    return "'" + expr.value + "'";
}

    if (expr.kind === NODE_BOOL) {
    if (expr.value) {
    return "True";
}

    return "False";
}

    if (expr.kind === NODE_BINARY) {
    let op = expr.op;
    if (op === "&&") {
    op = "and";
}

    if (op === "||") {
    op = "or";
}

    if (op === "!") {
    op = "not ";
}

    return CodeGenerator_gen_expr_py(self, expr.left) + " " + op + " " + CodeGenerator_gen_expr_py(self, expr.right);
}

    if (expr.kind === NODE_CALL) {
    let callee = CodeGenerator_gen_expr_py(self, expr.function);
    let args = "";
let list = [];
            for(let a of expr.args) list.push(CodeGenerator_gen_expr_py(self, a));
            args = list.join(", ");
    return callee + "(" + args + ")";
}

    if (expr.kind === NODE_MEMBER) {
    return CodeGenerator_gen_expr_py(self, expr.target) + "." + expr.property;
}

    if (expr.kind === NODE_STRUCT_INIT) {
    let fields = "";
let list = [];
              for(let f of expr.fields) {
                   list.push("'" + f.name + "': " + CodeGenerator_gen_expr_py(self, f.value));
              }
              fields = list.join(", ");
    return expr.name + "({ " + fields + " })";
}

    if (expr.kind === NODE_ARRAY) {
    let elems = "";
let list = [];
             for (let e of expr.elements) list.push(CodeGenerator_gen_expr_py(self, e));
             elems = list.join(", ");
    return "[" + elems + "]";
}

    if (expr.kind === NODE_IDENTIFIER) {
    return expr.value;
}

    if (expr.kind === NODE_ASSIGNMENT) {
    return CodeGenerator_gen_expr_py(self, expr.left) + " = " + CodeGenerator_gen_expr_py(self, expr.right);
}

if (typeof(expr) == "string") return expr;
    return "None";
}

function CodeGenerator_gen_statement(self, stmt) {
    if (stmt.kind === NODE_IMPORT) {
    return CodeGenerator_gen_import(self, stmt);
}

    if (stmt.kind === 80) {
    if ((stmt.lang === "js" || stmt.lang) === "javascript") {
    return stmt.code;
}

    return "";
}

    if (stmt.kind === NODE_LET) {
    return "let " + stmt.name + " = " + CodeGenerator_gen_expression(self, stmt.value) + ";";
}

    if (stmt.kind === NODE_RETURN) {
    return "return " + CodeGenerator_gen_expression(self, stmt.value) + ";";
}

    if (stmt.kind === NODE_FUNCTION) {
    let params = "";
params = stmt.params.join(", ");
    let body = CodeGenerator_gen_block(self, stmt.body);
    let decl = "function " + stmt.name + "(" + params + ") " + body;
    let decorators_code = CodeGenerator_gen_decorators(self, stmt.name, stmt.decorators);
    if (decorators_code !== "") {
    decl = decl + "\n" + decorators_code;
}

    return decl;
}

    if (stmt.kind === NODE_STRUCT) {
    let decl = CodeGenerator_gen_struct(self, stmt);
    let decorators_code = CodeGenerator_gen_decorators(self, stmt.name, stmt.decorators);
    if (decorators_code !== "") {
    decl = decl + "\n" + decorators_code;
}

    return decl;
}

    if (stmt.kind === NODE_IF) {
    let cond = CodeGenerator_gen_expression(self, stmt.condition);
    let cons = CodeGenerator_gen_block(self, stmt.consequence);
    let alt = "";
    if (stmt.alternative) {
    alt = " else " + CodeGenerator_gen_block(self, stmt.alternative);
}

    return "if (" + cond + ") " + cons + alt;
}

    if (stmt.kind === NODE_WHILE) {
    let cond = CodeGenerator_gen_expression(self, stmt.condition);
    let body = CodeGenerator_gen_block(self, stmt.body);
    return "while (" + cond + ") " + body;
}

    if (stmt.expr) {
    return CodeGenerator_gen_expression(self, stmt.expr) + ";";
}

    return "// Unknown stmt kind: " + stmt.kind;
}

function CodeGenerator_gen_import(self, stmt) {
    let path = stmt.path;
path = path.replace(".omni", ".js");
        if (path.startsWith(".") == false) path = "./" + path;
        // Extrai nome do arquivo para variÃ¡vel: "./core/token.js" -> "token"
        let name = path.split("/").pop().replace(".js", "");
        // Gera: const token = require("./token.js");
        return "const " + name + " = require(\"" + path + "\");\n" +
               "if (typeof global !== 'undefined') Object.assign(global, " + name + ");";
    return "";
}

function CodeGenerator_gen_struct(self, stmt) {
    let name = stmt.name;
    let assignments = "";
for (const field of stmt.fields) {
             assignments = assignments + "        this." + field.name + " = data." + field.name + ";\n";
        }
    return "class " + name + " {\n    constructor(data = {}) {\n" + assignments + "    }\n}";
}

function CodeGenerator_gen_block(self, block) {
    let out = "{\n";
if (block && block.statements) {
            for (const s of block.statements) {
                out = out + "    " + CodeGenerator_gen_statement(self, s) + "\n";
            }
        }
    out = out + "}";
    return out;
}

function CodeGenerator_gen_expression(self, expr) {
    if (expr === 0) {
    return "null";
}

    if (expr.kind === NODE_LITERAL) {
    return expr.value;
}

    if (expr.kind === NODE_STRING) {
    return "'" + expr.value + "'";
}

    if (expr.kind === NODE_BOOL) {
    if (expr.value) {
    return "true";
}

    return "false";
}

    if (expr.kind === NODE_BINARY) {
    return CodeGenerator_gen_expression(self, expr.left) + " " + expr.op + " " + CodeGenerator_gen_expression(self, expr.right);
}

    if (expr.kind === NODE_CALL) {
    let args = "";
let list = [];
             for(let a of expr.args) list.push(CodeGenerator_gen_expression(self, a));
             args = list.join(", ");
    let callee = CodeGenerator_gen_expression(self, expr.function);
    let is_class = false;
if (typeof expr.function.value === 'string') {
                 let val = expr.function.value;
                 let first = val.charAt(0);
                 is_class = (first >= "A" && first <= "Z") && (val.indexOf("_") == -1);
             }
    if (is_class) {
    return "new " + callee + "(" + args + ")";
}

    return callee + "(" + args + ")";
}

    if (expr.kind === NODE_MEMBER) {
    return CodeGenerator_gen_expression(self, expr.target) + "." + expr.property;
}

    if (expr.kind === NODE_STRUCT_INIT) {
    let fields = "";
let list = [];
            for(let f of expr.fields) {
                list.push(f.name + ": " + CodeGenerator_gen_expression(self, f.value));
            }
            fields = list.join(", ");
    return "new " + expr.name + "({ " + fields + " })";
}

    if (expr.kind === NODE_ARRAY) {
    let elems = "";
let list = [];
            for (let e of expr.elements) {
                list.push(CodeGenerator_gen_expression(self, e));
            }
            elems = list.join(", ");
    return "[" + elems + "]";
}

    if (expr.kind === NODE_IDENTIFIER) {
    return expr.value;
}

    if (expr.kind === NODE_ASSIGNMENT) {
    let left = CodeGenerator_gen_expression(self, expr.left);
    let right = CodeGenerator_gen_expression(self, expr.right);
    let code = "";
code = left + " = " + right;
    return code;
}

if (typeof(expr) == "string") return expr;
    return expr;
}

function CodeGenerator_gen_decorators(self, target_name, decorators) {
    let out = "";
if (decorators && decorators.length > 0) {
             let dec_list = [];
             for (let d of decorators) {
                 let args = "[]";
                 if (d.args && d.args.length > 0) {
                     let arg_list = [];
                     for (let a of d.args) {
                         // struct init fields: {name: "x", value: expr}
                         let val = CodeGenerator_gen_expression(self, a.value);
                         if (a.name && a.name !== "") {
                             arg_list.push('{ name: "' + a.name + '", value: ' + val + ' }');
                         } else {
                             arg_list.push('{ value: ' + val + ' }');
                         }
                     }
                     args = "[" + arg_list.join(", ") + "]";
                 }
                 dec_list.push('{ name: "' + d.name + '", args: ' + args + ' }');
             }
             out = target_name + ".decorators = [" + dec_list.join(", ") + "];";
        }
    return out;
}



// Auto-exports
if (typeof exports !== 'undefined') {
    exports.new_code_generator = new_code_generator;
    exports.CodeGenerator_generate = CodeGenerator_generate;
    exports.CodeGenerator_generate_python = CodeGenerator_generate_python;
    exports.CodeGenerator_gen_stmt_py = CodeGenerator_gen_stmt_py;
    exports.CodeGenerator_gen_block_py = CodeGenerator_gen_block_py;
    exports.CodeGenerator_gen_expr_py = CodeGenerator_gen_expr_py;
    exports.CodeGenerator_gen_statement = CodeGenerator_gen_statement;
    exports.CodeGenerator_gen_import = CodeGenerator_gen_import;
    exports.CodeGenerator_gen_struct = CodeGenerator_gen_struct;
    exports.CodeGenerator_gen_block = CodeGenerator_gen_block;
    exports.CodeGenerator_gen_expression = CodeGenerator_gen_expression;
    exports.CodeGenerator_gen_decorators = CodeGenerator_gen_decorators;
    exports.CodeGenerator = CodeGenerator;
}
