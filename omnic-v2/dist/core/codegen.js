// Generated by Omni Compiler
'use strict';

let ast = require('./ast.js');
let token = require('./token.js');

class CodeGenerator {
    constructor(data = {}) {
    }
}

function new_code_generator() {
    return new CodeGenerator({  });
}

function CodeGenerator_generate(self, program) {
    let output = "";
if (program && program.statements) {
            for (const stmt of program.statements) {
                output = output + CodeGenerator_gen_statement(self, stmt) + "\n";
            }
        }
    
    // Auto-Export Logic
    let exports = [];
    if (program && program.statements) {
         for (const stmt of program.statements) {
             if (stmt.kind == 60) exports.push(stmt.name); // FN (TOKEN_FN=60)
             if (stmt.kind == 70) exports.push(stmt.name); // STRUCT (TOKEN_STRUCT=70)
             if (stmt.kind == 61) exports.push(stmt.name); // LET (TOKEN_LET=61)
         }
    }
    if (exports.length > 0) {
        output += "\nmodule.exports = { " + exports.join(", ") + " };\n";
    }

    return output;
}

function CodeGenerator_gen_statement(self, stmt) {
    if ((stmt.kind === NODE_IMPORT)) {
    return CodeGenerator_gen_import(self, stmt);
}

    if ((stmt.kind === 80)) {
    return stmt.code;
}

    if ((stmt.kind === NODE_LET)) {
    return (((("const " + stmt.name) + " = ") + CodeGenerator_gen_expression(self, stmt.value)) + ";");
}

    if ((stmt.kind === NODE_RETURN)) {
    return (("return " + CodeGenerator_gen_expression(self, stmt.value)) + ";");
}

    if ((stmt.kind === NODE_FUNCTION)) {
    let params = "";
params = stmt.params.join(", ");
    let body = CodeGenerator_gen_block(self, stmt.body);
    return ((((("function " + stmt.name) + "(") + params) + ") ") + body);
}

    if ((stmt.kind === NODE_STRUCT)) {
    return CodeGenerator_gen_struct(self, stmt);
}

    if ((stmt.kind === NODE_IF)) {
    let cond = CodeGenerator_gen_expression(self, stmt.condition);
    let cons = CodeGenerator_gen_block(self, stmt.consequence);
    let alt = "";
    if (stmt.alternative) {
    alt = (" else " + CodeGenerator_gen_block(self, stmt.alternative));
}

    return (((("if (" + cond) + ") ") + cons) + alt);
}

    if ((stmt.kind === NODE_WHILE)) {
    let cond = CodeGenerator_gen_expression(self, stmt.condition);
    let body = CodeGenerator_gen_block(self, stmt.body);
    return ((("while (" + cond) + ") ") + body);
}

    if (stmt.expr) {
    return (CodeGenerator_gen_expression(self, stmt.expr) + ";");
}

    return ("// Unknown stmt kind: " + stmt.kind);
}

function CodeGenerator_gen_import(self, stmt) {
    let path = stmt.path;
path = path.replace(".omni", ".js");
        if (path.startsWith(".") == false) path = "./" + path;
        // Extrai nome do arquivo para variÃ¡vel: "./core/token.js" -> "token"
        let name = path.split("/").pop().replace(".js", "");
        // Gera: let token = require("./token.js");
        return "const " + name + " = require(\"" + path + "\");\nif (typeof global !== 'undefined') Object.assign(global, " + name + ");";
    return "";
}

function CodeGenerator_gen_struct(self, stmt) {
    let name = stmt.name;
    let assignments = "";
for (const field of stmt.fields) {
             assignments = assignments + "        this." + field.name + " = data." + field.name + ";\n";
        }
    return (((("class " + name) + " {\n    constructor(data = {}) {\n") + assignments) + "    }\n}");
}

function CodeGenerator_gen_block(self, block) {
    let out = "{\n";
if (block && block.statements) {
            for (const s of block.statements) {
                out = out + "    " + CodeGenerator_gen_statement(self, s) + "\n";
            }
        }
    out = (out + "}");
    return out;
}

function CodeGenerator_gen_expression(self, expr) {
    if ((expr === 0)) {
    return "null";
}

    if ((expr.kind === NODE_LITERAL)) {
    return expr.value;
}

    if ((expr.kind === NODE_BINARY)) {
    return ((((CodeGenerator_gen_expression(self, expr.left) + " ") + expr.op) + " ") + CodeGenerator_gen_expression(self, expr.right));
}

    if ((expr.kind === NODE_CALL)) {
    let args = "";
let list = [];
             for(let a of expr.args) list.push(CodeGenerator_gen_expression(self, a));
             args = list.join(", ");
    let callee = CodeGenerator_gen_expression(self, expr.function);
    let is_class = false;
if (typeof expr.function.value === 'string') {
                 let val = expr.function.value;
                 let first = val.charAt(0);
                 is_class = (first >= "A" && first <= "Z") && (val.indexOf("_") == -1);
             }
    if (is_class) {
    return (((("new " + callee) + "(") + args) + ")");
}

    return (((callee + "(") + args) + ")");
}

    if ((expr.kind === NODE_MEMBER)) {
    return ((CodeGenerator_gen_expression(self, expr.target) + ".") + expr.property);
}

    if ((expr.kind === NODE_STRUCT_INIT)) {
    let fields = "";
let list = [];
            for(let f of expr.fields) {
                list.push(f.name + ": " + CodeGenerator_gen_expression(self, f.value));
            }
            fields = list.join(", ");
    return (((("new " + expr.name) + "({ ") + fields) + " })");
}

    if ((expr.kind === NODE_ARRAY)) {
    let elems = "";
let list = [];
            for (let e of expr.elements) {
                list.push(CodeGenerator_gen_expression(self, e));
            }
            elems = list.join(", ");
    return (("[" + elems) + "]");
}

    if ((expr.kind === NODE_IDENTIFIER)) {
    return expr.value;
}

    if ((expr.kind === NODE_ASSIGNMENT)) {
    let left = CodeGenerator_gen_expression(self, expr.left);
    let right = CodeGenerator_gen_expression(self, expr.right);
    let code = "";
code = left + " = " + right;
    return code;
}

if (typeof(expr) == "string") return expr;
    return expr;
}
module.exports = { new_code_generator, CodeGenerator_generate, CodeGenerator_gen_statement, CodeGenerator_gen_import, CodeGenerator_gen_struct, CodeGenerator_gen_block, CodeGenerator_gen_expression, CodeGenerator };

Object.assign(global, ast);
Object.assign(global, token);
Object.assign(global, token);
