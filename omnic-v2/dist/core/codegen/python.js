const base = require("./base.js");
if (typeof global !== 'undefined') Object.assign(global, base);
const ast = require("../ast.js");
if (typeof global !== 'undefined') Object.assign(global, ast);
const token = require("../token.js");
if (typeof global !== 'undefined') Object.assign(global, token);
function CodeGenerator_generate_python(self, program) {
    const output = "";
    
        output = "# Generated by Omni Compiler\n\n";
        output += "# Decorator stubs\n";
        output += "def entity(cls):\n    return cls\n\n";
        output += "def ui(*args, **kwargs):\n    def decorator(func):\n        return func\n    return decorator\n\n";
    
    
        if (program && program.statements) {
            for (const stmt of program.statements) {
                self.indent = 0; // Reset indent for each top-level statement
                output = output + CodeGenerator_gen_stmt_py(self, stmt) + "\n";
            }
        }
    
    const py_exports = [];
    
        if (program && program.statements) {
             for (const stmt of program.statements) {
                 if (stmt.is_exported && stmt.name) {
                     py_exports.push("'" + stmt.name + "'");
                 }
             }
        }
        if (py_exports.length > 0) {
            output += "\n__all__ = [" + py_exports.join(", ") + "]\n";
        }
    
    return output;
}
function CodeGenerator_gen_stmt_py(self, stmt) {
    const indent_str = "";
     indent_str = "    ".repeat(self.indent); 
    if (stmt.kind == 91) {
    return "";
}
    if (stmt.kind == NODE_IMPORT) {
    const path = stmt.path;
    const name = "";
    
             path = path.replace(".omni", "");
             path = path.replace(/\//g, "."); // core/token -> core.token
             if (path.startsWith(".")) path = path.substring(1); // ./core -> /core -> core (fix logic later if needed)
             if (path.startsWith(".")) path = path.substring(1);
             name = path.split(".").pop();
        
    return indent_str + "import " + path + " as " + name;
}
    if (stmt.kind == 80) {
    if (stmt.lang == "py" || stmt.lang == "python") {
    return stmt.code;
}
    return "";
}
    if (stmt.kind == NODE_LET) {
    return indent_str + stmt.name + " = " + CodeGenerator_gen_expr_py(self, stmt.value);
}
    if (stmt.kind == NODE_RETURN) {
    return indent_str + "return " + CodeGenerator_gen_expr_py(self, stmt.value);
}
    if (stmt.kind == NODE_FUNCTION) {
    const decorators = CodeGenerator_gen_decorators_py(self, stmt.decorators);
    const params = "";
     params = stmt.params.join(", "); 
    const decl = indent_str + "def " + stmt.name + "(" + params + "):\n";
    self.indent = self.indent + 1;
    const body = CodeGenerator_gen_block_py(self, stmt.body);
    self.indent = self.indent;
    // Unknown stmt kind: 0
    1;
    return decorators + decl + body;
}
    if (stmt.kind == NODE_STRUCT) {
    const decorators = CodeGenerator_gen_decorators_py(self, stmt.decorators);
    const decl = indent_str + "class " + stmt.name + ":\n";
    self.indent = self.indent + 1;
    const init_indent = "";
     init_indent = "    ".repeat(self.indent); 
    const assignments = "";
    
             if (stmt.fields.length == 0) {
                 assignments = init_indent + "    pass";
             } else {
                 for(let f of stmt.fields) {
                     assignments += init_indent + "    self." + f.name + " = data.get('" + f.name + "')\n";
                 }
             }
        
    const init_fn = init_indent + "def __init__(self, data=None):\n";
    init_fn = init_fn + init_indent + "    if data is None: data = {}\n";
    init_fn = init_fn + assignments + "\n";
    self.indent = self.indent;
    // Unknown stmt kind: 0
    1;
    return decorators + decl + init_fn;
}
    if (stmt.kind == NODE_IF) {
    const cond = CodeGenerator_gen_expr_py(self, stmt.condition);
    const out = indent_str + "if " + cond + ":\n";
    self.indent = self.indent + 1;
    out = out + CodeGenerator_gen_block_py(self, stmt.consequence);
    self.indent = self.indent;
    // Unknown stmt kind: 0
    1;
    if (stmt.alternative) {
    out = out + "\n" + indent_str + "else:\n";
    self.indent = self.indent + 1;
    out = out + CodeGenerator_gen_block_py(self, stmt.alternative);
    self.indent = self.indent;
    // Unknown stmt kind: 0
    1;
}
    return out;
}
    if (stmt.kind == NODE_WHILE) {
    const cond = CodeGenerator_gen_expr_py(self, stmt.condition);
    const out = indent_str + "while " + cond + ":\n";
    self.indent = self.indent + 1;
    out = out + CodeGenerator_gen_block_py(self, stmt.body);
    self.indent = self.indent;
    // Unknown stmt kind: 0
    1;
    return out;
}
    if (stmt.expr) {
    return indent_str + CodeGenerator_gen_expr_py(self, stmt.expr);
}
    return indent_str + "# Unknown stmt: " + stmt.kind;
}
function CodeGenerator_gen_decorators_py(self, decorators) {
    const out = "";
    const indent_str = "";
     indent_str = "    ".repeat(self.indent); 
    
        if (decorators && decorators.length > 0) {
             for (let d of decorators) {
                 let args = "";
                 if (d.args && d.args.length > 0) {
                     let arg_list = [];
                     for (let a of d.args) {
                         // struct init fields: {name: "x", value: expr}
                         let val = CodeGenerator_gen_expr_py(self, a.value);
                         if (a.name && a.name !== "") {
                             arg_list.push(a.name + "=" + val);
                         } else {
                             arg_list.push(val);
                         }
                     }
                     args = "(" + arg_list.join(", ") + ")";
                 }
                 out += indent_str + "@" + d.name + args + "\n";
             }
        }
    
    return out;
}
function CodeGenerator_gen_block_py(self, block) {
    const out = "";
    
        if (!block.statements || block.statements.length == 0) {
             out = "    ".repeat(self.indent) + "pass";
        } else {
             for (const s of block.statements) {
                  out = out + CodeGenerator_gen_stmt_py(self, s) + "\n";
             }
        }
    
    return out;
}
function CodeGenerator_gen_expr_py(self, expr) {
    if (expr == 0) {
    return "None";
}
    if (expr.kind == NODE_LITERAL) {
    if (expr.value == "true") {
    return "True";
}
    if (expr.value == "false") {
    return "False";
}
    if (expr.value == "null") {
    return "None";
}
    return expr.value;
}
    if (expr.kind == NODE_STRING) {
    return "'" + expr.value + "'";
}
    if (expr.kind == NODE_BOOL) {
    if (expr.value) {
    return "True";
}
    return "False";
}
    if (expr.kind == NODE_BINARY) {
    const op = expr.op;
    if (op == "&&") {
    op = "and";
}
    if (op == "||") {
    op = "or";
}
    if (op == "!") {
    op = "not ";
}
    return CodeGenerator_gen_expr_py(self, expr.left) + " " + op + " " + CodeGenerator_gen_expr_py(self, expr.right);
}
    if (expr.kind == NODE_CALL) {
    const callee = CodeGenerator_gen_expr_py(self, expr.function);
    const args = "";
    
            let list = [];
            for(let a of expr.args) list.push(CodeGenerator_gen_expr_py(self, a));
            args = list.join(", ");
        
    return callee + "(" + args + ")";
}
    if (expr.kind == NODE_MEMBER) {
    return CodeGenerator_gen_expr_py(self, expr.target) + "." + expr.property;
}
    if (expr.kind == NODE_STRUCT_INIT) {
    const fields = "";
    
              let list = [];
              for(let f of expr.fields) {
                   list.push("'" + f.name + "': " + CodeGenerator_gen_expr_py(self, f.value));
              }
              fields = list.join(", ");
         
    return expr.name + "({ " + fields + " })";
}
    if (expr.kind == NODE_ARRAY) {
    const elems = "";
    
             let list = [];
             for (let e of expr.elements) list.push(CodeGenerator_gen_expr_py(self, e));
             elems = list.join(", ");
         
    return "[" + elems + "]";
}
    if (expr.kind == NODE_IDENTIFIER) {
    return expr.value;
}
    if (expr.kind == NODE_ASSIGNMENT) {
    return CodeGenerator_gen_expr_py(self, expr.left) + " = " + CodeGenerator_gen_expr_py(self, expr.right);
}
     if (typeof(expr) == "string") return expr; 
    return "None";
}


// Auto-exports
if (typeof exports !== 'undefined') {
    exports.CodeGenerator_generate_python = CodeGenerator_generate_python;
    exports.CodeGenerator_gen_stmt_py = CodeGenerator_gen_stmt_py;
    exports.CodeGenerator_gen_decorators_py = CodeGenerator_gen_decorators_py;
    exports.CodeGenerator_gen_block_py = CodeGenerator_gen_block_py;
    exports.CodeGenerator_gen_expr_py = CodeGenerator_gen_expr_py;
}
