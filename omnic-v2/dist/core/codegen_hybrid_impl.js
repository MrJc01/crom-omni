const fs = require('fs');
const path = require('path');

let HybridImpl = {
    LanguageProfile_load_impl: function(self) {
        // Try multiple paths for profile
        let paths = [
            path.join(__dirname, '..', 'targets', self.name + '.json'),
            path.join(__dirname, '..', '..', 'targets', self.name + '.json'),
            path.join(process.cwd(), 'targets', self.name + '.json')
        ];
        
        let profile = null;
        for (const p of paths) {
            if (fs.existsSync(p)) {
                profile = JSON.parse(fs.readFileSync(p, 'utf-8'));
                break;
            }
        }
        
        if (profile) {
            self.extension = profile.extension || '.txt';
            self.templates = profile.templates || {};
            self.type_map = profile.type_map || {};
            self.operators = profile.operators || {};
            self.indent_str = profile.indent || '    ';
            self.statement_end = profile.statement_end || ';';
            self.loaded = true;
        } else {
            // Fallback defaults for JavaScript
            self.extension = '.js';
            self.templates = {
                program_header: "// Generated by Omni Compiler\n'use strict';\n\n",
                fn_decl: "function {name}({params}) {\n{body}\n}",
                let_decl: "let {name} = {value};",
                return_stmt: "return {value};",
                if_stmt: "if ({condition}) {\n{consequence}\n}",
                if_else_stmt: "if ({condition}) {\n{consequence}\n} else {\n{alternative}\n}",
                while_stmt: "while ({condition}) {\n{body}\n}",
                class_decl: "class {name} {\n{body}\n}",
                call_expr: "{callee}({args})",
                binary_expr: "{left} {op} {right}",
                bool_true: "true",
                bool_false: "false",
                null: "null"
            };
            self.type_map = { i64: "number", string: "string", bool: "boolean" };
            self.operators = { eq: "===", neq: "!==", and: "&&", or: "||" };
            self.loaded = true;
        }
        return self;
    },

    LanguageProfile_render_impl: function(self, template_name, data) {
        let template = self.templates[template_name];
        if (!template) {
            return "/* Template '" + template_name + "' not found */";
        }
        return template.replace(/\{(\w+)\}/g, (_, key) => {
            return data.hasOwnProperty(key) ? data[key] : '';
        });
    },

    LanguageProfile_map_operator_impl: function(self, op) {
        let opMap = { '==': 'eq', '!=': 'neq', '&&': 'and', '||': 'or', '<': 'lt', '>': 'gt' };
        let key = opMap[op];
        if (key && self.operators[key]) {
            return self.operators[key];
        }
        return op;
    },

    HybridCodeGenerator_indent_impl: function(self, code) {
        let prefix = self.profile.indent_str.repeat(self.indent_level);
        return code.split('\n').map(line => line ? prefix + line : line).join('\n');
    },

    check_native_lang: function(self, stmt) {
        let lang = stmt.lang || 'js';
        // Strip quotes if present
        if ((lang.startsWith('"') && lang.endsWith('"')) || (lang.startsWith("'") && lang.endsWith("'"))) {
            lang = lang.substring(1, lang.length - 1);
        }
        
        let targetLang = self.profile.name;
        
        if (lang === 'js' || lang === 'javascript') {
            if (targetLang === 'js' || targetLang === 'javascript') {
                return stmt.code;
            }
        } else if (lang === 'py' || lang === 'python') {
            if (targetLang === 'py' || targetLang === 'python') {
                return stmt.code;
            }
        } else if (lang === targetLang) {
            return stmt.code;
        }
        return "";
    },

    gen_expression_literal: function(self, expr) {
        let val = String(expr.value);
        if (val === 'true') val = self.profile.templates.bool_true || 'true';
        if (val === 'false') val = self.profile.templates.bool_false || 'false';
        if (val === 'null') val = self.profile.templates.null || 'null';
        return val;
    },

    gen_expression_bool: function(self, expr) {
        return expr.value ? 
            (self.profile.templates.bool_true || 'true') : 
            (self.profile.templates.bool_false || 'false');
    },

    gen_struct_body: function(stmt) {
        let constructor_body = "";
        for (const field of stmt.fields || []) {
            constructor_body += "        this." + field.name + " = data." + field.name + ";\n";
        }
        return constructor_body;
    },

    gen_entity_repo: function(stmt) {
        let name = stmt.name;
        let fields = (stmt.fields || []).filter(f => f.name !== 'id').map(f => f.name);
        // field_names unused in original code logic?
        
        let out = "\n// @entity Repository: " + name + "\n";
        out += name + ".find = async (id) => {\n";
        out += "    let db = await Database.get('main_db');\n";
        out += "    let row = await db.get('SELECT * FROM " + name + " WHERE id = ?', [id]);\n";
        out += "    return row ? new " + name + "(row) : null;\n";
        out += "};\n\n";
        
        out += name + ".all = async () => {\n";
        out += "    let db = await Database.get('main_db');\n";
        out += "    return (await db.all('SELECT * FROM " + name + "')).map(r => new " + name + "(r));\n";
        out += "};\n";
        return out;
    },

    gen_capsule: function(stmt) {
        let name = stmt.name;
        let flows = "";
        let flowDefs = stmt.flows || [];
        let flow_list = flowDefs.map(f => "'" + f.name + "'").join(', ');
        
        for (const flow of flowDefs) {
            let params = flow.params.map(p => p.name).join(', ');
            let paramJson = flow.params.map(p => p.name + ": " + p.name).join(', ');
            
            flows += "    async " + flow.name + "(" + params + ") {\n";
            flows += "        let route = TopologyResolver.resolve('" + name + "');\n";
            flows += "        if (route.local) {\n";
            flows += "            return this._impl_" + flow.name + "(" + params + ");\n";
            flows += "        } else {\n";
            flows += "            let response = await fetch(route.url + '/" + name + "/" + flow.name + "', {\n";
            flows += "                method: 'POST',\n";
            flows += "                headers: { 'Content-Type': 'application/json' },\n";
            flows += "                body: JSON.stringify({ " + paramJson + " })\n";
            flows += "            });\n";
            flows += "            return await response.json();\n";
            flows += "        }\n";
            flows += "    },\n\n";
            
            flows += "    _impl_" + flow.name + "(" + params + ") {\n";
            flows += "        throw new Error('" + name + "." + flow.name + " not implemented');\n";
            flows += "    },\n\n";
        }
        
        let out = "// Capsule: " + name + "\n";
        out += "const " + name + " = {\n";
        out += "    _name: '" + name + "',\n";
        out += "    _flows: [" + flow_list + "],\n\n";
        out += flows;
        out += "};\n";
        return out;
    },

    gen_spawn_code: function(fn_name, args_str) {
        let out = "(() => {\n";
        out += "    const { Worker } = require('worker_threads');\n";
        out += "    let worker = new Worker(__filename, {\n";
        out += "        workerData: { fn: '" + fn_name + "', args: [" + args_str + "] }\n";
        out += "    });\n";
        out += "    worker.on('message', r => console.log('[spawn] " + fn_name + " done:', r));\n";
        out += "    worker.on('error', e => console.error('[spawn] " + fn_name + " error:', e));\n";
        out += "})()";
        return out;
    },

    gen_service_client: function(stmt) {
        let name = stmt.name;
        let methods = "";
        
        for (const method of stmt.methods || []) {
            let params = method.params ? method.params.map(p => p.name).join(', ') : '';
            methods += "    async " + method.name + "(" + params + ") {\n";
            methods += "        let url = Discovery.resolve('" + name + "');\n";
            methods += "        let response = await fetch(url + '/" + name + "/" + method.name + "', {\n";
            methods += "            method: 'POST',\n";
            methods += "            headers: { 'Content-Type': 'application/json' },\n";
            methods += "            body: JSON.stringify({ " + params + " })\n";
            methods += "        });\n";
            methods += "        return await response.json();\n";
            methods += "    },\n";
        }
        
        return "// @service RPC Client: " + name + "\n" +
               "const " + name + " = {\n" + methods + "};\n";
    },
    
    gen_import: function(stmt) {
        let module_path = stmt.path || stmt.module || '';
        module_path = module_path.replace(/^['"]|['"]$/g, '');
        let alias = stmt.alias || module_path.split('/').pop().replace('.omni', '');
        console.log('[DEBUG GEN_IMPORT] module_path = "' + module_path + '"');
        
        // Inline bundling for std/ imports
        if (module_path.startsWith('std/') || module_path.startsWith('std\\')) {
            // Find the std/ folder
            let projectRoot = process.cwd();
            let stdPath = path.join(projectRoot, module_path);
            console.log('[DEBUG] Inline bundling: ' + module_path + ' -> ' + stdPath);
            
            // Try parent directories if not found
            if (!fs.existsSync(stdPath)) {
                let dir = projectRoot;
                for (let i = 0; i < 5; i++) {
                    dir = path.dirname(dir);
                    stdPath = path.join(dir, module_path);
                    if (fs.existsSync(stdPath)) break;
                }
            }
            
            if (fs.existsSync(stdPath)) {
                try {
                    const source = fs.readFileSync(stdPath, 'utf-8');
                    const lexer_mod = require('./lexer.js');
                    const parser_mod = require('./parser.js');
                    const codegen_hybrid = require('./codegen_hybrid.js');
                    
                    const lexer = lexer_mod.Lexer_new(source);
                    const tokens = lexer_mod.Lexer_tokenize(lexer);
                    const parser = parser_mod.Parser_new(tokens);
                    const ast = parser_mod.Parser_parse(parser);
                    
                    // Generate inline code using hybrid generator
                    let generator = codegen_hybrid.HybridCodeGenerator_new('js');
                    let code = "// ===== INLINE: " + module_path + " =====\n";
                    
                    if (ast && ast.statements) {
                        for (const s of ast.statements) {
                            // Skip import statements in imported files to avoid recursion issues
                            if (s.kind === 10) continue; // NODE_IMPORT = 10
                            let stmtCode = codegen_hybrid.HybridCodeGenerator_gen_statement(generator, s);
                            if (stmtCode) code += stmtCode + "\n";
                        }
                    }
                    code += "// ===== END: " + module_path + " =====\n";
                    return code;
                } catch (e) {
                    return "// [ERROR] Failed to inline " + module_path + ": " + e.message;
                }
            } else {
                return "// [WARN] Could not find: " + module_path + " (searched " + stdPath + ")";
            }
        }
        
        // Fallback for non-std imports
        return "// MARKER: Hybrid Import\n" + 
               "const " + alias + " = require(\"" + module_path + "\");\n" +
               "if (typeof global !== 'undefined') Object.assign(global, " + alias + ");";
    }
};

module.exports = HybridImpl;
