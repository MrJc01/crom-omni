// Generated by Omni Compiler
'use strict';
const token = require('./token.js');
const { 
    TOKEN_EOF, TOKEN_ILLEGAL, TOKEN_IDENTIFIER, TOKEN_INT, TOKEN_STRING,
    TOKEN_ASSIGN, TOKEN_PLUS, TOKEN_MINUS, TOKEN_BANG, TOKEN_ASTERISK, TOKEN_SLASH,
    TOKEN_LT, TOKEN_GT, TOKEN_EQ, TOKEN_NOT_EQ, TOKEN_COLON, TOKEN_DOT,
    TOKEN_AND, TOKEN_OR, TOKEN_LE, TOKEN_GE, TOKEN_COMMA, TOKEN_SEMICOLON,
    TOKEN_LPAREN, TOKEN_RPAREN, TOKEN_LBRACE, TOKEN_RBRACE, TOKEN_LBRACKET, TOKEN_RBRACKET,
    TOKEN_FN, TOKEN_LET, TOKEN_TRUE, TOKEN_FALSE, TOKEN_IF, TOKEN_ELSE, TOKEN_RETURN, TOKEN_WHILE,
    TOKEN_STRUCT, TOKEN_NATIVE, TOKEN_IMPORT, TOKEN_PACKAGE, TOKEN_EXPORT
} = token;


let NODE_PROGRAM = 1;

let NODE_LET = 2;

let NODE_LITERAL = 3;

let NODE_FUNCTION = 4;

let NODE_BLOCK = 5;

let NODE_CALL = 6;

let NODE_RETURN = 7;

let NODE_BINARY = 8;

let NODE_MEMBER = 9;

let NODE_IMPORT = 10;

let NODE_ARRAY = 11;

let NODE_STRUCT_INIT = 12;

let NODE_IF = 13;

let NODE_WHILE = 14;

let NODE_IDENTIFIER = 15;

let NODE_ASSIGNMENT = 16;

let NODE_STRING = 17;

let NODE_BOOL = 18;
let NODE_PREFIX = 19;

let NODE_CAPSULE = 20;
let NODE_FLOW = 21;

let NODE_STRUCT = 70;

let NODE_NATIVE = 80;

class Program {
    constructor(data = {}) {
        this.statements = data.statements;
    }
}

class AssignmentExpr {
    constructor(data = {}) {
        this.kind = data.kind;
        this.left = data.left;
        this.right = data.right;
    }
}

class PrefixExpr {
    constructor(data = {}) {
        this.kind = data.kind;
        this.op = data.op;
        this.right = data.right;
    }
}

class NativeStmt {
    constructor(data = {}) {
        this.kind = data.kind;
        this.lang = data.lang;
        this.code = data.code;
    }
}

class LetStmt {
    constructor(data = {}) {
        this.kind = data.kind;
        this.name = data.name;
        this.value = data.value;
        this.is_exported = data.is_exported;
    }
}

class ImportDecl {
    constructor(data = {}) {
        this.kind = data.kind;
        this.path = data.path;
    }
}

class ExpressionStmt {
    constructor(data = {}) {
        this.kind = data.kind;
        this.expr = data.expr;
    }
}

class IntegerLiteral {
    constructor(data = {}) {
        this.kind = data.kind;
        this.value = data.value;
    }
}

class StringLiteral {
    constructor(data = {}) {
        this.kind = data.kind;
        this.value = data.value;
    }
}

class BoolLiteral {
    constructor(data = {}) {
        this.kind = data.kind;
        this.value = data.value;
    }
}

class StructInitExpr {
    constructor(data = {}) {
        this.kind = data.kind;
        this.name = data.name;
        this.fields = data.fields;
    }
}

class StructInitField {
    constructor(data = {}) {
        this.name = data.name;
        this.value = data.value;
    }
}

class BinaryExpr {
    constructor(data = {}) {
        this.kind = data.kind;
        this.left = data.left;
        this.op = data.op;
        this.right = data.right;
    }
}

class MemberExpr {
    constructor(data = {}) {
        this.kind = data.kind;
        this.target = data.target;
        this.property = data.property;
    }
}

class FunctionDecl {
    constructor(data = {}) {
        this.kind = data.kind;
        this.name = data.name;
        this.params = data.params;
        this.body = data.body;
        this.is_exported = data.is_exported;
    }
}

class Block {
    constructor(data = {}) {
        this.kind = data.kind;
        this.statements = data.statements;
    }
}

class CallExpr {
    constructor(data = {}) {
        this.kind = data.kind;
        this.function = data.function;
        this.args = data.args;
    }
}

class ReturnStmt {
    constructor(data = {}) {
        this.kind = data.kind;
        this.value = data.value;
    }
}

class IfStmt {
    constructor(data = {}) {
        this.kind = data.kind;
        this.condition = data.condition;
        this.consequence = data.consequence;
        this.alternative = data.alternative;
    }
}

class WhileStmt {
    constructor(data = {}) {
        this.kind = data.kind;
        this.condition = data.condition;
        this.body = data.body;
    }
}

class StructDecl {
    constructor(data = {}) {
        this.kind = data.kind;
        this.name = data.name;
        this.fields = data.fields;
        this.is_exported = data.is_exported;
    }
}

class StructField {
    constructor(data = {}) {
        this.name = data.name;
        this.typename = data.typename;
    }
}

function new_struct_field(name, typename) {
    return new StructField({ name: name, typename: typename });
}

class Identifier {
    constructor(data = {}) {
        this.kind = data.kind;
        this.value = data.value;
    }
}

class CapsuleDecl {
    constructor(data = {}) {
        this.kind = data.kind;
        this.name = data.name;
        this.body = data.body;
        this.is_exported = data.is_exported;
    }
}

class FlowDecl {
    constructor(data = {}) {
        this.kind = data.kind;
        this.name = data.name;
        this.params = data.params;
        this.return_type = data.return_type;
        this.body = data.body;
        this.is_exported = data.is_exported;
    }
}

module.exports = {
    NODE_PROGRAM, NODE_LET, NODE_LITERAL, NODE_FUNCTION, NODE_BLOCK,
    NODE_CALL, NODE_RETURN, NODE_BINARY, NODE_MEMBER, NODE_IMPORT,
    NODE_ARRAY, NODE_STRUCT_INIT, NODE_IF, NODE_WHILE, NODE_IDENTIFIER,
    NODE_ASSIGNMENT, NODE_STRING, NODE_BOOL, NODE_PREFIX, NODE_STRUCT, NODE_NATIVE,
    Program, AssignmentExpr, PrefixExpr, NativeStmt, LetStmt, ImportDecl, ExpressionStmt,
    IntegerLiteral, StringLiteral, BoolLiteral, StructInitExpr, StructInitField,
    BinaryExpr, MemberExpr, FunctionDecl, Block, CallExpr, ReturnStmt,
    IfStmt, WhileStmt, StructDecl, StructField, new_struct_field, Identifier,
    CapsuleDecl, FlowDecl, NODE_CAPSULE, NODE_FLOW
};
Object.assign(global, module.exports);

