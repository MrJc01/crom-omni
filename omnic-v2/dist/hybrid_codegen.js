// Hybrid Metamorphosis Code Generator
// Uses LanguageProfile templates for atomic syntax + Architecture Hooks for complex structures
// Generated by Omni Compiler v6

'use strict';

const fs = require('fs');
const path = require('path');
const { TemplateGenerator, loadProfile, render, indent } = require('./template_engine.js');
const ast = require('./core/ast.js');

// AST Node Constants (from ast.js)
const NODE_PROGRAM = 1;
const NODE_LET = 2;
const NODE_LITERAL = 3;
const NODE_FUNCTION = 4;
const NODE_BLOCK = 5;
const NODE_CALL = 6;
const NODE_RETURN = 7;
const NODE_BINARY = 8;
const NODE_MEMBER = 9;
const NODE_IMPORT = 10;
const NODE_ARRAY = 11;
const NODE_STRUCT_INIT = 12;
const NODE_IF = 13;
const NODE_WHILE = 14;
const NODE_IDENTIFIER = 15;
const NODE_ASSIGNMENT = 16;
const NODE_STRING = 17;
const NODE_BOOL = 18;
const NODE_STRUCT = 70;
const NODE_NATIVE = 80;
const NODE_INTERFACE = 90;
const NODE_IMPL = 91;
const NODE_SPAWN = 92;
const NODE_CAPSULE = 93;
// LANGUAGE PROFILE SYSTEM
// ============================================================================

class LanguageProfile {
    constructor(name) {
        this.name = name;
        this.profile = null;
        this.templates = {};
        this.typeMap = {};
        this.operators = {};
        this.loaded = false;
    }
    
    load() {
        if (this.loaded) return this;
        
        try {
            this.profile = loadProfile(this.name);
            this.templates = this.profile.templates || {};
            this.typeMap = this.profile.type_map || {};
            this.operators = this.profile.operators || {};
            this.loaded = true;
        } catch (e) {
            console.error(`[codegen] Failed to load profile "${this.name}":`, e.message);
            // Fallback to JavaScript defaults
            this.loadDefaults();
        }
        return this;
    }
    
    loadDefaults() {
        this.templates = {
            let_decl: "let {name} = {value};",
            fn_decl: "function {name}({params}) {\n{body}\n}",
            if_stmt: "if ({condition}) {\n{consequence}\n}",
            if_else_stmt: "if ({condition}) {\n{consequence}\n} else {\n{alternative}\n}",
            while_stmt: "while ({condition}) {\n{body}\n}",
            return_stmt: "return {value};",
            class_decl: "class {name} {\n{body}\n}",
            call_expr: "{callee}({args})",
            binary_expr: "{left} {op} {right}",
            comment: "// {text}"
        };
        this.typeMap = { i64: "number", string: "string", bool: "boolean" };
        this.operators = { eq: "===", neq: "!==", and: "&&", or: "||" };
        this.loaded = true;
    }
    
    render(templateName, data) {
        const template = this.templates[templateName];
        if (!template) return `/* Template "${templateName}" not found */`;
        return render(template, data);
    }
    
    mapType(omniType) {
        return this.typeMap[omniType] || omniType;
    }
    
    mapOperator(op) {
        const opMap = { '==': 'eq', '!=': 'neq', '&&': 'and', '||': 'or', '<': 'lt', '>': 'gt' };
        const key = opMap[op];
        if (key && this.operators[key]) return this.operators[key];
        return op;
    }
}

// ============================================================================
// ARCHITECTURE HOOKS (for complex structures like MVC, Microservices)
// ============================================================================

const ArchitectureHooks = {
    // Hook for @entity - generates repository pattern
    entity: {
        generate(profile, structNode) {
            // Already handled in gen_struct with entity detection
            return null;
        }
    },
    
    // Hook for @ui - generates UI components based on target framework
    ui: {
        react: {
            button: (props) => `<Button onClick={${props.action}}>${props.label}</Button>`,
            screen: (name, body) => `export default function ${name}() {\n  return (\n    <div>${body}</div>\n  );\n}`,
            list: (items, render) => `{${items}.map(item => ${render}(item))}`
        },
        vue: {
            button: (props) => `<button @click="${props.action}">${props.label}</button>`,
            screen: (name, body) => `<template>\n  <div>${body}</div>\n</template>\n<script setup>\n</script>`,
            list: (items, render) => `<div v-for="item in ${items}">${render}</div>`
        },
        blade: {
            button: (props) => `<button onclick="${props.action}">${props.label}</button>`,
            screen: (name, body) => `@extends('layouts.app')\n@section('content')\n${body}\n@endsection`,
            list: (items, render) => `@foreach($${items} as $item)\n${render}\n@endforeach`
        }
    },
    
    // Hook for @server - generates routes based on target framework
    server: {
        express: {
            get: (path, handler) => `router.get('${path}', async (req, res) => {\n  ${handler}\n});`,
            post: (path, handler) => `router.post('${path}', async (req, res) => {\n  ${handler}\n});`
        },
        nextjs: {
            get: (path, handler) => `export async function GET(request) {\n  ${handler}\n  return NextResponse.json(result);\n}`,
            post: (path, handler) => `export async function POST(request) {\n  const body = await request.json();\n  ${handler}\n  return NextResponse.json(result);\n}`
        },
        laravel: {
            get: (path, handler) => `Route::get('${path}', function() {\n  ${handler}\n});`,
            post: (path, handler) => `Route::post('${path}', function(Request $request) {\n  ${handler}\n});`
        },
        fastapi: {
            get: (path, handler) => `@app.get("${path}")\nasync def handler():\n    ${handler}`,
            post: (path, handler) => `@app.post("${path}")\nasync def handler(data: dict):\n    ${handler}`
        }
    }
};

// ============================================================================
// HYBRID CODE GENERATOR
// ============================================================================

class HybridCodeGenerator {
    constructor(options = {}) {
        this.target = options.target || 'js';
        this.framework = options.framework || null;
        this.uiAdapter = options.ui_adapter || 'react';
        this.serverAdapter = options.server_adapter || 'express';
        
        this.profile = new LanguageProfile(this.target).load();
        this.indentLevel = 0;
        this.exports = [];
        this.imports = [];
        
        // AST Validation tracking
        this.astNodeCount = 0;
        this.generatedNodeCount = 0;
    }
    
    get indent() {
        return this.profile.profile?.indent || '    ';
    }
    
    indentCode(code) {
        if (!code) return '';
        const prefix = this.indent.repeat(this.indentLevel);
        return code.split('\n').map(line => line ? prefix + line : line).join('\n');
    }
    
    // Main generation entry point
    generate(program) {
        if (!program || !program.statements) return '';
        
        let output = this.profile.render('program_header', {}) || '';
        this.exports = [];
        this.imports = [];
        
        // Generate all statements
        for (const stmt of program.statements) {
            this.astNodeCount++;
            const code = this.genStatement(stmt);
            if (code) {
                output += code + '\n';
                this.generatedNodeCount++;
            }
        }
        
        // Auto-generate exports
        if (this.exports.length > 0) {
            output += '\nmodule.exports = { ' + this.exports.join(', ') + ' };\n';
        }
        
        // Validate AST parity
        this.validateParity();
        
        return output;
    }
    
    validateParity() {
        // "Se compilar, funcionar√°" - validate AST coverage
        const coverage = (this.generatedNodeCount / this.astNodeCount) * 100;
        if (coverage < 100 && this.astNodeCount > 0) {
            console.warn(`[codegen] AST coverage: ${coverage.toFixed(1)}% (${this.generatedNodeCount}/${this.astNodeCount} nodes)`);
        }
    }
    
    // ========================================================================
    // STATEMENT GENERATION (Template-Based)
    // ========================================================================
    
    genStatement(stmt) {
        if (!stmt) return '';
        
        // Import
        if (stmt.kind === NODE_IMPORT) {
            return this.genImport(stmt);
        }
        
        // Native block
        if (stmt.kind === 80) { // NODE_NATIVE
            if (stmt.lang === 'js' || stmt.lang === 'javascript' || stmt.lang === this.target) {
                return stmt.code;
            }
            return '';
        }
        
        // Let declaration - TEMPLATE BASED
        if (stmt.kind === NODE_LET) {
            return this.profile.render('let_decl', {
                name: stmt.name,
                value: this.genExpression(stmt.value)
            });
        }
        
        // Return statement - TEMPLATE BASED
        if (stmt.kind === NODE_RETURN) {
            return this.profile.render('return_stmt', {
                value: this.genExpression(stmt.value)
            });
        }
        
        // Function declaration - TEMPLATE BASED
        if (stmt.kind === NODE_FUNCTION) {
            const params = stmt.params ? stmt.params.join(', ') : '';
            this.indentLevel++;
            const body = this.genBlock(stmt.body);
            this.indentLevel--;
            
            if (stmt.is_exported) this.exports.push(stmt.name);
            
            return this.profile.render('fn_decl', {
                name: stmt.name,
                params: params,
                body: body
            });
        }
        
        // Struct/Class declaration
        if (stmt.kind === NODE_STRUCT) {
            return this.genStruct(stmt);
        }
        
        // If statement - TEMPLATE BASED
        if (stmt.kind === NODE_IF) {
            return this.genIf(stmt);
        }
        
        // While statement - TEMPLATE BASED
        if (stmt.kind === NODE_WHILE) {
            this.indentLevel++;
            const body = this.genBlock(stmt.body);
            this.indentLevel--;
            
            return this.profile.render('while_stmt', {
                condition: this.genExpression(stmt.condition),
                body: body
            });
        }
        
        // Capsule (Logic Container)
        if (stmt.kind === NODE_CAPSULE) {
            return this.genCapsule(stmt);
        }
        
        // Spawn (parallel execution)
        if (stmt.kind === NODE_SPAWN) {
            return this.genSpawn(stmt);
        }
        
        // Expression statement (Call as statement)
        if (stmt.kind === NODE_CALL) {
            return this.genExpression(stmt) + (this.profile.profile?.statement_end || ';');
        }
        
        // Assignment
        if (stmt.kind === NODE_ASSIGNMENT) {
            return `${stmt.name} = ${this.genExpression(stmt.value)};`;
        }
        
        // Interface (with @service/@server attributes)
        if (stmt.kind === NODE_INTERFACE) {
            return this.genInterface(stmt);
        }
        
        return `// Unknown stmt kind: ${stmt.kind}`;
    }
    
    // ========================================================================
    // EXPRESSION GENERATION
    // ========================================================================
    
    genExpression(expr) {
        if (!expr) return '';
        
        // Literal number
        if (expr.kind === 1 || expr.kind === 2) {
            return String(expr.value);
        }
        
        // String literal
        if (expr.kind === 17) {
            return `"${expr.value}"`;
        }
        
        // Boolean
        if (expr.kind === 18) {
            const template = expr.value ? 'bool_true' : 'bool_false';
            return this.profile.templates[template] || String(expr.value);
        }
        
        // Identifier
        if (expr.kind === 3) {
            return expr.value || expr.name;
        }
        
        // Binary expression - TEMPLATE BASED
        if (expr.kind === 4) {
            return this.profile.render('binary_expr', {
                left: this.genExpression(expr.left),
                op: this.profile.mapOperator(expr.op),
                right: this.genExpression(expr.right)
            });
        }
        
        // Call expression
        if (expr.kind === 5) {
            const args = expr.args ? expr.args.map(a => this.genExpression(a)).join(', ') : '';
            return this.profile.render('call_expr', {
                callee: expr.name || this.genExpression(expr.callee),
                args: args
            });
        }
        
        // Member access
        if (expr.kind === 6) {
            return `${this.genExpression(expr.object)}.${expr.member}`;
        }
        
        // Array literal
        if (expr.kind === 7) {
            const elements = expr.elements ? expr.elements.map(e => this.genExpression(e)).join(', ') : '';
            return `[${elements}]`;
        }
        
        // Struct initialization
        if (expr.kind === 8) {
            const fields = expr.fields ? Object.entries(expr.fields).map(([k, v]) => `${k}: ${this.genExpression(v)}`).join(', ') : '';
            return `new ${expr.name}({ ${fields} })`;
        }
        
        return String(expr.value || expr.name || '');
    }
    
    // ========================================================================
    // COMPLEX STRUCTURE GENERATORS
    // ========================================================================
    
    genBlock(body) {
        if (!body) return '';
        // Handle body as array or as object with statements property
        const statements = Array.isArray(body) ? body : (body.statements || []);
        if (!Array.isArray(statements)) return '';
        return statements.map(s => this.indentCode(this.genStatement(s))).join('\n');
    }
    
    genIf(stmt) {
        this.indentLevel++;
        const consequence = this.genBlock(stmt.consequence);
        this.indentLevel--;
        
        if (stmt.alternative && stmt.alternative.length > 0) {
            this.indentLevel++;
            const alternative = this.genBlock(stmt.alternative);
            this.indentLevel--;
            
            return this.profile.render('if_else_stmt', {
                condition: this.genExpression(stmt.condition),
                consequence: consequence,
                alternative: alternative
            });
        }
        
        return this.profile.render('if_stmt', {
            condition: this.genExpression(stmt.condition),
            consequence: consequence
        });
    }
    
    genStruct(stmt) {
        const isEntity = stmt.attributes?.some(a => a.name === 'entity');
        
        // Generate class
        let out = `class ${stmt.name} {\n`;
        out += `    constructor(data = {}) {\n`;
        for (const field of stmt.fields || []) {
            out += `        this.${field.name} = data.${field.name};\n`;
        }
        out += `    }\n`;
        out += `}\n`;
        
        // If @entity, add repository methods
        if (isEntity) {
            out += this.genEntityRepository(stmt);
        }
        
        return out;
    }
    
    genEntityRepository(stmt) {
        const name = stmt.name;
        const fields = stmt.fields || [];
        const fieldNames = fields.filter(f => f.name !== 'id').map(f => f.name);
        
        let out = `\n// @entity Repository: ${name}\n`;
        out += `${name}.find = async (id) => {\n`;
        out += `    const db = await Database.get('main_db');\n`;
        out += `    const row = await db.get('SELECT * FROM ${name} WHERE id = ?', [id]);\n`;
        out += `    return row ? new ${name}(row) : null;\n`;
        out += `};\n\n`;
        
        out += `${name}.all = async () => {\n`;
        out += `    const db = await Database.get('main_db');\n`;
        out += `    return (await db.all('SELECT * FROM ${name}')).map(r => new ${name}(r));\n`;
        out += `};\n\n`;
        
        out += `${name}.save = async (obj) => {\n`;
        out += `    const db = await Database.get('main_db');\n`;
        out += `    if (obj.id) {\n`;
        out += `        await db.run('UPDATE ${name} SET ${fieldNames.map(f => f + '=?').join(', ')} WHERE id=?', [${fieldNames.map(f => 'obj.' + f).join(', ')}, obj.id]);\n`;
        out += `    } else {\n`;
        out += `        const r = await db.run('INSERT INTO ${name} (${fieldNames.join(', ')}) VALUES (${fieldNames.map(() => '?').join(', ')})', [${fieldNames.map(f => 'obj.' + f).join(', ')}]);\n`;
        out += `        obj.id = r.lastID;\n`;
        out += `    }\n`;
        out += `    return obj;\n`;
        out += `};\n`;
        
        return out;
    }
    
    genCapsule(stmt) {
        const name = stmt.name;
        const flows = stmt.flows || [];
        
        let out = `// Capsule: ${name}\n`;
        out += `const ${name} = {\n`;
        out += `    _name: '${name}',\n`;
        out += `    _flows: [${flows.map(f => `'${f.name}'`).join(', ')}],\n\n`;
        
        for (const flow of flows) {
            const params = flow.params.map(p => p.name).join(', ');
            out += `    async ${flow.name}(${params}) {\n`;
            out += `        const route = TopologyResolver.resolve('${name}');\n`;
            out += `        if (route.local) {\n`;
            out += `            return this._impl_${flow.name}(${params});\n`;
            out += `        } else {\n`;
            out += `            const response = await fetch(route.url + '/${name}/${flow.name}', {\n`;
            out += `                method: 'POST',\n`;
            out += `                headers: { 'Content-Type': 'application/json' },\n`;
            out += `                body: JSON.stringify({ ${flow.params.map(p => `${p.name}: ${p.name}`).join(', ')} })\n`;
            out += `            });\n`;
            out += `            return await response.json();\n`;
            out += `        }\n`;
            out += `    },\n\n`;
            
            out += `    _impl_${flow.name}(${params}) {\n`;
            out += `        throw new Error('${name}.${flow.name} not implemented');\n`;
            out += `    },\n\n`;
        }
        
        out += `};\n`;
        return out;
    }
    
    genSpawn(stmt) {
        const call = stmt.call;
        let fnName = call?.name || call?.callee?.value || 'unknown';
        let args = '';
        
        if (call?.args) {
            args = call.args.map(a => this.genExpression(a)).join(', ');
        }
        
        let out = `(() => {\n`;
        out += `    const { Worker } = require('worker_threads');\n`;
        out += `    const worker = new Worker(__filename, {\n`;
        out += `        workerData: { fn: '${fnName}', args: [${args}] }\n`;
        out += `    });\n`;
        out += `    worker.on('message', r => console.log('[spawn] ${fnName} done:', r));\n`;
        out += `    worker.on('error', e => console.error('[spawn] ${fnName} error:', e));\n`;
        out += `})()`;
        return out;
    }
    
    genImport(stmt) {
        const alias = stmt.alias || stmt.module.split('/').pop().replace('.omni', '');
        return `const ${alias} = require("${stmt.module}");\nif (typeof global !== 'undefined') Object.assign(global, ${alias});`;
    }
    
    genInterface(stmt) {
        const isService = stmt.attributes?.some(a => a.name === 'service');
        const isServer = stmt.attributes?.some(a => a.name === 'server');
        
        if (isService) {
            return this.genServiceClient(stmt);
        }
        if (isServer) {
            return this.genServerSkeleton(stmt);
        }
        
        return `// Interface: ${stmt.name}`;
    }
    
    genServiceClient(stmt) {
        const name = stmt.name;
        let out = `// @service RPC Client: ${name}\n`;
        out += `const ${name} = {\n`;
        
        for (const method of stmt.methods || []) {
            const params = method.params ? method.params.map(p => p.name).join(', ') : '';
            out += `    async ${method.name}(${params}) {\n`;
            out += `        const url = Discovery.resolve('${name}');\n`;
            out += `        const response = await fetch(url + '/${name}/${method.name}', {\n`;
            out += `            method: 'POST',\n`;
            out += `            headers: { 'Content-Type': 'application/json' },\n`;
            out += `            body: JSON.stringify({ ${params} })\n`;
            out += `        });\n`;
            out += `        return await response.json();\n`;
            out += `    },\n`;
        }
        
        out += `};\n`;
        return out;
    }
    
    genServerSkeleton(stmt) {
        const name = stmt.name;
        let out = `// @server Skeleton: ${name}\n`;
        out += `const http = require('http');\n`;
        out += `const ${name}Server = http.createServer(async (req, res) => {\n`;
        out += `    const url = new URL(req.url, 'http://localhost');\n`;
        out += `    const path = url.pathname;\n`;
        out += `    FlightRecorder.startRequest(req);\n`;
        out += `    // Route dispatch...\n`;
        out += `    res.end();\n`;
        out += `});\n`;
        return out;
    }
}

// ============================================================================
// EXPORTS (Backward Compatibility)
// ============================================================================

// Legacy interface for existing compiler
function new_code_generator() {
    return new HybridCodeGenerator({ target: 'js' });
}

function CodeGenerator_generate(self, program) {
    if (self instanceof HybridCodeGenerator) {
        return self.generate(program);
    }
    // Fallback for legacy
    const gen = new HybridCodeGenerator({ target: 'js' });
    return gen.generate(program);
}

function CodeGenerator_gen_statement(self, stmt) {
    if (self instanceof HybridCodeGenerator) {
        return self.genStatement(stmt);
    }
    const gen = new HybridCodeGenerator({ target: 'js' });
    return gen.genStatement(stmt);
}

function CodeGenerator_gen_expression(self, expr) {
    if (self instanceof HybridCodeGenerator) {
        return self.genExpression(expr);
    }
    const gen = new HybridCodeGenerator({ target: 'js' });
    return gen.genExpression(expr);
}

module.exports = {
    HybridCodeGenerator,
    LanguageProfile,
    ArchitectureHooks,
    new_code_generator,
    CodeGenerator_generate,
    CodeGenerator_gen_statement,
    CodeGenerator_gen_expression
};
