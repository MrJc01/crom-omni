// Template Engine for Profile-Based Code Generation
// Generated by Omni Compiler

const fs = require('fs');
const path = require('path');

// Cache for loaded profiles
const profileCache = {};

/**
 * Load a language profile from targets/ folder
 * @param {string} language - Profile name (js, python, lua, c)
 * @returns {object} Language profile
 */
function loadProfile(language) {
    if (profileCache[language]) {
        return profileCache[language];
    }
    
    const profilePath = path.join(__dirname, '..', 'targets', `${language}.json`);
    
    if (!fs.existsSync(profilePath)) {
        throw new Error(`Language profile not found: ${profilePath}`);
    }
    
    const profile = JSON.parse(fs.readFileSync(profilePath, 'utf-8'));
    profileCache[language] = profile;
    return profile;
}

/**
 * Render a template with data
 * @param {string} template - Template string with {placeholders}
 * @param {object} data - Data object with values
 * @returns {string} Rendered string
 */
function render(template, data) {
    if (!template) return '';
    
    return template.replace(/\{(\w+)\}/g, (match, key) => {
        if (data.hasOwnProperty(key)) {
            return data[key] !== undefined ? data[key] : '';
        }
        return match; // Keep original if no replacement
    });
}

/**
 * Apply indentation to a block of code
 * @param {string} code - Code block
 * @param {number} level - Indentation level
 * @param {string} indent - Indent string (from profile)
 * @returns {string} Indented code
 */
function indent(code, level, indentStr = '    ') {
    if (!code) return '';
    const prefix = indentStr.repeat(level);
    return code.split('\n').map(line => line ? prefix + line : line).join('\n');
}

/**
 * Map Omni type to target language type
 * @param {string} omniType - Omni type name
 * @param {object} profile - Language profile
 * @returns {string} Target type
 */
function mapType(omniType, profile) {
    return profile.type_map[omniType] || omniType;
}

/**
 * Map operator to target language operator
 * @param {string} op - Operator symbol
 * @param {object} profile - Language profile
 * @returns {string} Target operator
 */
function mapOperator(op, profile) {
    // Map common operators
    const opMap = {
        '==': 'eq',
        '!=': 'neq',
        '<': 'lt',
        '<=': 'lte',
        '>': 'gt',
        '>=': 'gte',
        '&&': 'and',
        '||': 'or',
        '!': 'not',
        '+': 'add',
        '-': 'sub',
        '*': 'mul',
        '/': 'div',
        '%': 'mod'
    };
    
    const opKey = opMap[op];
    if (opKey && profile.operators && profile.operators[opKey]) {
        return profile.operators[opKey];
    }
    return op;
}

/**
 * Get a template from profile
 * @param {object} profile - Language profile
 * @param {string} name - Template name
 * @returns {string} Template string
 */
function getTemplate(profile, name) {
    return profile.templates[name] || '';
}

/**
 * Template-based code generator
 */
class TemplateGenerator {
    constructor(language) {
        this.profile = loadProfile(language);
        this.indentLevel = 0;
    }
    
    get indent() {
        return this.profile.indent || '    ';
    }
    
    render(templateName, data) {
        const template = getTemplate(this.profile, templateName);
        return render(template, data);
    }
    
    type(omniType) {
        return mapType(omniType, this.profile);
    }
    
    operator(op) {
        return mapOperator(op, this.profile);
    }
    
    indentCode(code) {
        return indent(code, this.indentLevel, this.indent);
    }
    
    // Generate function declaration
    genFunction(name, params, body) {
        return this.render('fn_decl', {
            name,
            params: params.join(', '),
            body: this.indentCode(body)
        });
    }
    
    // Generate let/variable declaration
    genLet(name, value, type = null) {
        return this.render('let_decl', {
            name,
            value,
            type: type ? this.type(type) : ''
        });
    }
    
    // Generate if statement
    genIf(condition, consequence, alternative = null) {
        if (alternative) {
            return this.render('if_else_stmt', {
                condition,
                consequence: this.indentCode(consequence),
                alternative: this.indentCode(alternative)
            });
        }
        return this.render('if_stmt', {
            condition,
            consequence: this.indentCode(consequence)
        });
    }
    
    // Generate while statement
    genWhile(condition, body) {
        return this.render('while_stmt', {
            condition,
            body: this.indentCode(body)
        });
    }
    
    // Generate return statement
    genReturn(value) {
        if (value === null || value === undefined) {
            return this.render('return_void', {});
        }
        return this.render('return_stmt', { value });
    }
    
    // Generate class/struct
    genClass(name, body, parent = null) {
        if (parent) {
            return this.render('class_extends', {
                name,
                parent,
                body: this.indentCode(body)
            });
        }
        return this.render('class_decl', {
            name,
            body: this.indentCode(body)
        });
    }
    
    // Generate function call
    genCall(callee, args) {
        return this.render('call_expr', {
            callee,
            args: args.join(', ')
        });
    }
    
    // Generate binary expression
    genBinary(left, op, right) {
        return this.render('binary_expr', {
            left,
            op: this.operator(op),
            right
        });
    }
    
    // Generate program header
    header() {
        return this.render('program_header', {});
    }
    
    // Generate program footer
    footer() {
        return this.render('program_footer', {});
    }
    
    // Generate comment
    genComment(text) {
        return this.render('comment', { text });
    }
}

module.exports = {
    loadProfile,
    render,
    indent,
    mapType,
    mapOperator,
    getTemplate,
    TemplateGenerator
};
