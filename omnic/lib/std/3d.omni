// std/3d.omni - 3D Graphics Standard Library (Three.js Backend)
// Provides Scene3D, Camera3D, Mesh3D, and Renderer3D wrappers

native "js" {
// =============================================================================
// Omni 3D Runtime (Three.js Shim)
// =============================================================================

// Check if we're in browser or Node environment
const _isBrowser = typeof window !== 'undefined';

// Three.js CDN loader for browser
function ThreeJS_load(callback) {
    if (_isBrowser) {
        if (typeof THREE !== 'undefined') {
            callback();
            return;
        }
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
        script.onload = callback;
        document.head.appendChild(script);
    } else {
        // Node.js - print message and mock
        console.log('[3D] Three.js requires browser environment. Run with --web flag and open HTML file.');
        console.log('[3D] Mocking 3D runtime for console output...');
        callback();
    }
}

// Scene3D class
class Scene3D {
    constructor(opts = {}) {
        this.handle = opts.handle || 0;
        if (_isBrowser && typeof THREE !== 'undefined') {
            this._scene = new THREE.Scene();
        } else {
            this._scene = { type: 'Scene3D', children: [] };
        }
    }
}

// Camera3D class
class Camera3D {
    constructor(opts = {}) {
        this.handle = opts.handle || 0;
        if (_isBrowser && typeof THREE !== 'undefined') {
            this._camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        } else {
            this._camera = { type: 'Camera3D', position: { x: 0, y: 0, z: 0 } };
        }
    }
}

// Renderer3D class
class Renderer3D {
    constructor(opts = {}) {
        this.handle = opts.handle || 0;
        if (_isBrowser && typeof THREE !== 'undefined') {
            this._renderer = new THREE.WebGLRenderer();
            this._renderer.setSize(window.innerWidth, window.innerHeight);
        } else {
            this._renderer = { type: 'Renderer3D' };
        }
    }
}

// Mesh3D class
class Mesh3D {
    constructor(opts = {}) {
        this.handle = opts.handle || 0;
        this._mesh = null;
    }
}

// Factory functions
function Scene_create() {
    return new Scene3D();
}

function Camera_create() {
    return new Camera3D();
}

function Renderer_create() {
    return new Renderer3D();
}

function Renderer_init(renderer) {
    if (_isBrowser && renderer._renderer && renderer._renderer.domElement) {
        document.body.appendChild(renderer._renderer.domElement);
    }
    console.log('[3D] Renderer initialized');
}

function Camera_set_z(camera, z) {
    if (camera._camera && camera._camera.position) {
        camera._camera.position.z = z;
    }
    console.log('[3D] Camera Z set to:', z);
}

function Sphere_create(radius, color, scene) {
    const mesh = new Mesh3D();
    if (_isBrowser && typeof THREE !== 'undefined') {
        const geometry = new THREE.SphereGeometry(radius, 32, 32);
        const material = new THREE.MeshBasicMaterial({ color: color });
        mesh._mesh = new THREE.Mesh(geometry, material);
        if (scene._scene && scene._scene.add) {
            scene._scene.add(mesh._mesh);
        }
    }
    console.log('[3D] Sphere created - radius:', radius, 'color:', color);
    return mesh;
}

function Mesh_set_position(mesh, x, y, z) {
    if (mesh._mesh && mesh._mesh.position) {
        mesh._mesh.position.set(x, y, z);
    }
}

function Renderer_render(renderer, scene, camera) {
    if (_isBrowser && renderer._renderer && scene._scene && camera._camera) {
        renderer._renderer.render(scene._scene, camera._camera);
    }
}

function AnimationLoop(callback) {
    if (_isBrowser) {
        function loop() {
            requestAnimationFrame(loop);
            callback();
        }
        loop();
    } else {
        console.log('[3D] Animation loop started (mock mode - no output in console)');
    }
}

// Math helpers
function cos(x) { return Math.cos(x); }
function sin(x) { return Math.sin(x); }
}

// Struct definitions for type safety
struct Scene3D { handle: int }
struct Camera3D { handle: int }
struct Renderer3D { handle: int }
struct Mesh3D { handle: int }
