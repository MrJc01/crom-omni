use crate::core::codegen::CodeGenerator;
use crate::core::ast::{Program, Statement, Expression, Literal, Type};
use anyhow::Result;

pub struct CBackend;

impl CBackend {
    pub fn new() -> Self {
        Self
    }
}

impl CodeGenerator for CBackend {
    fn generate(&self, program: &Program) -> Result<String> {
        let mut code = String::from("/* Generated by Omni Compiler (Target: ANSI C) */\n");
        code.push_str("#include <stdio.h>\n");
        code.push_str("#include <stdlib.h>\n");
        code.push_str("#include <string.h>\n");
        code.push_str("#include <stdbool.h>\n\n");
    
        // Feature: C-Native Networking Stub (Phase 9)
        if cfg!(target_os = "windows") {
            code.push_str("#include <winsock2.h>\n");
            code.push_str("#pragma comment(lib, \"ws2_32.lib\")\n");
        } else {
            code.push_str("#include <sys/socket.h>\n");
            code.push_str("#include <netinet/in.h>\n");
            code.push_str("#include <unistd.h>\n");
        }

        code.push_str("\n// Omni Runtime Extensions\n");
        code.push_str("void socket_init() {\n");
        code.push_str("    #ifdef _WIN32\n");
        code.push_str("    WSADATA wsa;\n");
        code.push_str("    WSAStartup(MAKEWORD(2,2), &wsa);\n");
        code.push_str("    #endif\n");
        code.push_str("}\n\n");

        code.push_str("void std_http_listen(int port) {\n");
        code.push_str("    if (port == 0) port = 8080;\n");
        code.push_str("    #ifdef _WIN32\n");
        code.push_str("        SOCKET server_fd, new_socket;\n");
        code.push_str("    #else\n");
        code.push_str("        int server_fd, new_socket;\n");
        code.push_str("    #endif\n");
        code.push_str("    struct sockaddr_in address;\n");
        code.push_str("    int addrlen = sizeof(address);\n");
        code.push_str("    const char *hello = \"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: 26\\r\\n\\r\\nOmni Sovereign Core v1.0\";\n");
        
        code.push_str("    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) exit(1);\n");
        code.push_str("    address.sin_family = AF_INET;\n");
        code.push_str("    address.sin_addr.s_addr = INADDR_ANY;\n");
        code.push_str("    address.sin_port = htons(port);\n");
        code.push_str("    bind(server_fd, (struct sockaddr *)&address, sizeof(address));\n");
        code.push_str("    listen(server_fd, 3);\n");
        code.push_str("    printf(\"ðŸš€ Sovereign Server running on port %d (C-Native)\\n\", port);\n");
        code.push_str("    while(1) {\n");
        code.push_str("        #ifdef _WIN32\n");
        code.push_str("            new_socket = accept(server_fd, (struct sockaddr *)&address, &addrlen);\n");
        code.push_str("            send(new_socket, hello, (int)strlen(hello), 0);\n");
        code.push_str("            closesocket(new_socket);\n");
        code.push_str("        #else\n");
        code.push_str("            new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);\n");
        code.push_str("            send(new_socket, hello, strlen(hello), 0);\n");
        code.push_str("            close(new_socket);\n");
        code.push_str("        #endif\n");
        code.push_str("    }\n");
        code.push_str("}\n\n");

        // Memory Management Headers (Omni RC)
        code.push_str("// --- Omni Memory Management ---\n");
        code.push_str("typedef struct { int _ref_count; } OmniRef;\n");
        code.push_str("void omni_retain(void* ptr) {\n");
        code.push_str("    if (ptr) ((OmniRef*)ptr)->_ref_count++;\n");
        code.push_str("}\n");
        code.push_str("void omni_release(void* ptr) {\n");
        code.push_str("    if (ptr) {\n");
        code.push_str("        ((OmniRef*)ptr)->_ref_count--;\n");
        code.push_str("        if (((OmniRef*)ptr)->_ref_count <= 0) free(ptr);\n");
        code.push_str("    }\n");
        code.push_str("}\n// ------------------------------\n\n");
        
        // Typedefs bÃ¡sicos para Any (void*)
        code.push_str("typedef void* Any;\n\n");

        for item in &program.items {
            match item {
                crate::core::ast::TopLevelItem::Capsule(capsule) => {
                    code.push_str(&format!("/* Capsule: {} */\n", capsule.name));
                    
                    // Struct Definition
                    // TODO: Implement struct fields logic when AST supports it fully
                    // code.push_str(&format!("typedef struct {} {{\n}} {};\n\n", capsule.name, capsule.name));

                    for item in &capsule.items {
                        if let crate::core::ast::TopLevelItem::Flow(flow) = item {
                            // Function Signature
                            // Assuming void return for now if not specified or explicit Type
                            let ret_type = "void"; 
                            let args = flow.params.iter().map(|p| {
                                format!("Any {}", p.name)
                            }).collect::<Vec<_>>().join(", ");

                            code.push_str(&format!("{} {}_{}({}) {{\n", ret_type, capsule.name, flow.name, args));

                            // Body
                            for stmt in &flow.body.statements {
                               code.push_str(&self.gen_statement(stmt, 1));
                            }

                            code.push_str("}\n\n");
                        }
                    }
                }
                crate::core::ast::TopLevelItem::NativeBlock { lang, code: native_lines } => {
                     if lang == "c" {
                         code.push('\n');
                         code.push_str(&native_lines.join("\n"));
                         code.push('\n');
                     }
                }
                _ => {}
            }
        }
        
        // Main shim if present
        // Check if there is a 'Main' capsule with 'main' flow? 
        // For now, let's just append a main for testing 01_hello.omni if needed, 
        // but typically 01_hello.omni has a top-level Main capsule.
        
        Ok(code)
    }
}

impl CBackend {
    fn gen_statement(&self, stmt: &Statement, indent: usize) -> String {
        let pad = "    ".repeat(indent);
        match stmt {
            Statement::Expression(expr) => {
                format!("{}{};\n", pad, self.gen_expression(expr))
            }
            Statement::Return(expr) => {
                 if let Some(e) = expr {
                     format!("{}return {};\n", pad, self.gen_expression(e))
                 } else {
                     format!("{}return;\n", pad)
                 }
            }
            Statement::NativeBlock { lang, code } => {
                if lang == "c" {
                    format!("{}{}\n", pad, code.join("\n"))
                } else {
                    format!("{}/* Native block ({}) ignored */\n", pad, lang)
                }
            }
            Statement::LetBinding { name, value, .. } => {
                let val_code = self.gen_expression(value);
                // If value starts with '{', it's an array initializer.
                if val_code.trim().starts_with('{') {
                     // const unsigned char name[] = { ... };
                     format!("{}const unsigned char {}[] = {};\n", pad, name, val_code)
                } else {
                     format!("{}Any {} = {};\n{}omni_retain({});\n", pad, name, val_code, pad, name)
                }
            }
            Statement::Assignment { target, value } => {
                 let target_code = self.gen_expression(target);
                 let val_code = self.gen_expression(value);
                 // RC Dance: Release old, Assign new, Retain new
                 format!("{}omni_release({});\n{}{} = {};\n{}omni_retain({});\n", 
                    pad, target_code, 
                    pad, target_code, val_code, 
                    pad, target_code)
            }
            _ => format!("{}// Unsupported statement in C prototype\n", pad),
        }
    }

    fn gen_expression(&self, expr: &Expression) -> String {
        match expr {
            Expression::Literal(lit) => match lit {
                Literal::String(s) => format!("\"{}\"", s),
                Literal::Integer(i) => i.to_string(),
                Literal::Float(f) => f.to_string(),
                Literal::Bool(b) => if *b { "true".to_string() } else { "false".to_string() },
            },
            Expression::BinaryOp { left, op, right } => {
                let l = self.gen_expression(left);
                let r = self.gen_expression(right);
                let op_str = match op {
                    crate::core::ast::BinaryOperator::Add => "+",
                    crate::core::ast::BinaryOperator::Subtract => "-",
                    crate::core::ast::BinaryOperator::Multiply => "*",
                    crate::core::ast::BinaryOperator::Divide => "/",
                    crate::core::ast::BinaryOperator::Equals => "==",
                    crate::core::ast::BinaryOperator::NotEquals => "!=",
                    crate::core::ast::BinaryOperator::LessThan => "<",
                    crate::core::ast::BinaryOperator::GreaterThan => ">",
                    crate::core::ast::BinaryOperator::LessEquals => "<=",
                    crate::core::ast::BinaryOperator::GreaterEquals => ">=",
                    crate::core::ast::BinaryOperator::LogicalAnd => "&&",
                    crate::core::ast::BinaryOperator::LogicalOr => "||",
                };
                format!("({} {} {})", l, op_str, r)
            }
            Expression::Call { function, args } => {
                 let func_name = self.gen_expression(function);
                 // Mapping built-ins
                 if func_name == "\"io.print\"" || func_name == "io_print" { 
                     if let Some(arg) = args.first() {
                         return format!("printf(\"%s\\n\", (char*){})", self.gen_expression(arg));
                     }
                 }
                 format!("{}({})", func_name, args.iter().map(|a| self.gen_expression(a)).collect::<Vec<_>>().join(", "))
            }
            Expression::Identifier(name) => name.replace(".", "_"),
            Expression::Array(elements) => {
                 let elems = elements.iter().map(|e| self.gen_expression(e)).collect::<Vec<_>>().join(", ");
                 format!("{{ {} }}", elems)
            },
            Expression::StructInit { name, .. } => {
                format!("/* StructInit {} */ 0", name) // Placeholder: NULL (0)
            }
            Expression::MemberAccess { object, member } => {
                // Assuming object is Any (void*), we can't dereference without cast.
                // For now, prototype just prints a warning comment
                format!("/* {}.{} */", self.gen_expression(object), member)
            }
            _ => "0 /* unsupported expr */".to_string(),
        }
    }
}
