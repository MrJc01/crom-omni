use crate::core::codegen::CodeGenerator;
use crate::core::ast::{Program, Statement, Expression, Literal, Type};
use anyhow::Result;

pub struct CBackend;

impl CBackend {
    pub fn new() -> Self {
        Self
    }
}

impl CodeGenerator for CBackend {
    fn generate(&self, program: &Program) -> Result<String> {
        let mut code = String::new();
        
        // Header padrão
        code.push_str("/* Generated by Omni Compiler (Target: ANSI C) */\n");
        code.push_str("#include <stdio.h>\n");
        code.push_str("#include <stdlib.h>\n");
        code.push_str("#include <string.h>\n");
        code.push_str("#include <stdbool.h>\n\n");
        
        // Typedefs básicos para Any (void*)
        code.push_str("typedef void* Any;\n\n");

        for item in &program.items {
            match item {
                crate::core::ast::TopLevelItem::Capsule(capsule) => {
                    code.push_str(&format!("/* Capsule: {} */\n", capsule.name));
                    
                    // Struct Definition
                    // TODO: Implement struct fields logic when AST supports it fully
                    // code.push_str(&format!("typedef struct {} {{\n}} {};\n\n", capsule.name, capsule.name));

                    for item in &capsule.items {
                        if let crate::core::ast::TopLevelItem::Flow(flow) = item {
                            // Function Signature
                            // Assuming void return for now if not specified or explicit Type
                            let ret_type = "void"; 
                            let args = flow.params.iter().map(|p| {
                                format!("Any {}", p.name)
                            }).collect::<Vec<_>>().join(", ");

                            code.push_str(&format!("{} {}_{}({}) {{\n", ret_type, capsule.name, flow.name, args));

                            // Body
                            for stmt in &flow.body.statements {
                               code.push_str(&self.gen_statement(stmt, 1));
                            }

                            code.push_str("}\n\n");
                        }
                    }
                }
                _ => {}
            }
        }
        
        // Main shim if present
        // Check if there is a 'Main' capsule with 'main' flow? 
        // For now, let's just append a main for testing 01_hello.omni if needed, 
        // but typically 01_hello.omni has a top-level Main capsule.
        
        Ok(code)
    }
}

impl CBackend {
    fn gen_statement(&self, stmt: &Statement, indent: usize) -> String {
        let pad = "    ".repeat(indent);
        match stmt {
            Statement::Expression(expr) => {
                format!("{}{};\n", pad, self.gen_expression(expr))
            }
            Statement::Return(expr) => {
                 if let Some(e) = expr {
                     format!("{}return {};\n", pad, self.gen_expression(e))
                 } else {
                     format!("{}return;\n", pad)
                 }
            }
            Statement::NativeBlock { lang, code } => {
                if lang == "c" {
                    format!("{}{}\n", pad, code.join("\n"))
                } else {
                    format!("{}/* Native block ({}) ignored */\n", pad, lang)
                }
            }
            // Basic support ONLY for hello world
            _ => format!("{}// Unsupported statement in C prototype\n", pad),
        }
    }

    fn gen_expression(&self, expr: &Expression) -> String {
        match expr {
            Expression::Literal(lit) => match lit {
                Literal::String(s) => format!("\"{}\"", s),
                Literal::Integer(i) => i.to_string(),
                Literal::Float(f) => f.to_string(),
                Literal::Bool(b) => if *b { "true".to_string() } else { "false".to_string() },
            },
            Expression::Call { function, args } => {
                 let func_name = self.gen_expression(function);
                 // Mapping built-ins
                 if func_name == "\"io.print\"" || func_name == "io_print" { // Hardcoded hack for stdlib mapping
                     // In C, print depends on type. For prototype, assume string
                     if let Some(arg) = args.first() {
                         return format!("printf(\"%s\\n\", (char*){})", self.gen_expression(arg));
                     }
                 }
                 format!("{}({})", func_name, args.iter().map(|a| self.gen_expression(a)).collect::<Vec<_>>().join(", "))
            }
            Expression::Identifier(name) => name.replace(".", "_"), // main.print -> main_print
            _ => "/* expr */".to_string(),
        }
    }
}
