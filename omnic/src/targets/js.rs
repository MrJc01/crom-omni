use crate::core::ast::*;
use crate::core::codegen::CodeGenerator;
use anyhow::Result;

/// Backend para JavaScript (ES6+)
pub struct JsBackend;

impl JsBackend {
    pub fn new() -> Self {
        Self
    }
}

impl CodeGenerator for JsBackend {
    fn generate(&self, program: &Program) -> Result<String> {
        let mut buffer = String::new();
        
        buffer.push_str("// Generated by Omni Compiler\n");
        buffer.push_str("'use strict';\n\n");

        // 1. Package / Imports
        // Omni: package com.foo; -> ignorado no JS simples ou vira namespace
        // Omni: import std; -> const std = require('std');
        for import in &program.imports {
             // Convert .omni extension to .js for requires
             let mut path = import.path.clone();
             if path.ends_with(".omni") {
                 path = path.replace(".omni", ".js");
             }
             
             // Extract variable name from path
             let var_name = import.alias.clone().unwrap_or_else(|| {
                 // std/http -> http, token.js -> token
                 let base = path.split('/').last().unwrap_or(&path);
                 base.trim_end_matches(".js").to_string()
             });
             
             // Handle std imports specially (built-in)
             if path.starts_with("std") {
                 // Ignora imports da stdlib do Omni que são built-in no JS
             } else {
                 // Ensure relative path starts with ./
                 let require_path = if !path.starts_with("./") && !path.starts_with("../") && !path.starts_with("/") {
                     format!("./{}", path)
                 } else {
                     path
                 };
                 buffer.push_str(&format!("const {} = require('{}');\n", var_name, require_path));
             }
        }
        buffer.push('\n');

        // 2. Items (Structs, Functions, Capsules, Flows, and Let bindings)
        for item in &program.items {
            match item {
                TopLevelItem::Struct(s) => {
                    buffer.push_str(&self.gen_struct(s));
                }
                TopLevelItem::Function(f) => {
                    buffer.push_str(&self.gen_function(f));
                }
                TopLevelItem::Capsule(c) => {
                    buffer.push_str(&self.gen_capsule(c));
                }
                TopLevelItem::Flow(fl) => {
                    buffer.push_str(&self.gen_flow(fl));
                }
                TopLevelItem::LetBinding { name, value, is_mut: _, .. } => {
                    let keyword = "let";
                    buffer.push_str(&format!("{} {} = {};\n", keyword, name, self.gen_expression(value)));
                }
            }
            buffer.push('\n');
        }

        // 3. Main Call? 
        // Se houver main, poderíamos chamar automaticamente. 
        // O Omni geralmente é compilado para ser executado, então se tiver main:
        if program.items.iter().any(|i| matches!(i, TopLevelItem::Function(f) if f.name == "main")) {
            buffer.push_str("\n// Entry Point\n");
            buffer.push_str("if (require.main === module) {\n");
             buffer.push_str("    main();\n");
            buffer.push_str("}\n");
        }

        Ok(buffer)
    }
}

impl JsBackend {
    fn gen_attributes(&self, attributes: &[Attribute], target_name: &str) -> String {
        if attributes.is_empty() {
            return String::new();
        }
        
        let attrs_str = attributes.iter().map(|attr| {
            let args = attr.args.iter()
                .map(|arg| self.gen_expression(arg))
                .collect::<Vec<_>>()
                .join(", ");
            format!("{{ name: '{}', args: [{}] }}", attr.name, args)
        }).collect::<Vec<_>>().join(", ");
        
        format!("{}.__attributes = [{}];\n", target_name, attrs_str)
    }

    fn gen_struct(&self, s: &StructDeclaration) -> String {
        // Omni struct -> JS Class data-only
        let mut code = format!("class {} {{\n", s.name);
        
        // Constructor para inicializar campos
        code.push_str("    constructor(data = {}) {\n");
        for field in &s.fields {
            // this.id = data.id;
            code.push_str(&format!("        this.{} = data.{};\n", field.name, field.name));
        }
        code.push_str("    }\n");
        code.push_str("}\n");
        code.push_str(&self.gen_attributes(&s.attributes, &s.name));
        code
    }

    fn gen_function(&self, f: &FunctionDeclaration) -> String {
        // fn nome(params) { ... } -> function nome(params) { ... }
        let params = f.params.iter()
            .map(|p| p.name.clone())
            .collect::<Vec<_>>()
            .join(", ");
        
        let header = format!("function {}({}) ", f.name, params);
        let body = self.gen_block(&f.body);
        
        let mut code = format!("{}{}", header, body);
        code.push_str(&self.gen_attributes(&f.attributes, &f.name));
        code
    }

    /// Generate JS for a capsule (as a namespace object)
    fn gen_capsule(&self, c: &CapsuleDeclaration) -> String {
        let mut code = format!("// Capsule: {}\n", c.name);
        code.push_str(&format!("const {} = {{}};\n\n", c.name));
        
        for item in &c.items {
            match item {
                TopLevelItem::Function(f) => {
                    // Capsule methods: CapsuleName.methodName = function(...) { }
                    let params = f.params.iter()
                        .map(|p| p.name.clone())
                        .collect::<Vec<_>>()
                        .join(", ");
                    let body = self.gen_block(&f.body);
                    code.push_str(&format!("{}.{} = function({}) {};\n", c.name, f.name, params, body));
                    code.push_str(&self.gen_attributes(&f.attributes, &format!("{}.{}", c.name, f.name)));
                }
                TopLevelItem::Struct(s) => {
                    // Nested class definition
                    code.push_str(&format!("{}.{} = ", c.name, s.name));
                    code.push_str(&self.gen_struct(s));
                }
                TopLevelItem::Flow(fl) => {
                    // Flow as method
                    let params = fl.params.iter()
                        .map(|p| p.name.clone())
                        .collect::<Vec<_>>()
                        .join(", ");
                    let body = self.gen_block(&fl.body);
                    code.push_str(&format!("{}.{} = function({}) {};\n", c.name, fl.name, params, body));
                }
                TopLevelItem::LetBinding { name, value, .. } => {
                    code.push_str(&format!("{}.{} = {};\n", c.name, name, self.gen_expression(value)));
                }
                TopLevelItem::Capsule(nested) => {
                    // Nested capsule
                    code.push_str(&format!("{}.{} = {{}};\n", c.name, nested.name));
                    // Recursively generate nested content - simplified for now
                }
            }
        }
        
        code.push_str(&self.gen_attributes(&c.attributes, &c.name));
        code.push('\n');
        code
    }

    /// Generate JS for a flow (as a regular function)
    fn gen_flow(&self, fl: &FlowDeclaration) -> String {
        let params = fl.params.iter()
            .map(|p| p.name.clone())
            .collect::<Vec<_>>()
            .join(", ");
        
        let header = format!("function {}({}) ", fl.name, params);
        let body = self.gen_block(&fl.body);
        
        let mut code = format!("{}{}", header, body);
        code.push_str(&self.gen_attributes(&fl.attributes, &fl.name));
        code
    }

    fn gen_block(&self, b: &Block) -> String {
        let mut code = String::from("{\n");
        for stmt in &b.statements {
            code.push_str(&self.gen_statement(stmt));
            code.push('\n');
        }
        code.push_str("}\n");
        code
    }

    fn gen_statement(&self, stmt: &Statement) -> String {
        match stmt {
            Statement::LetBinding { name, value, is_mut, .. } => {
                // JS usa let/const. Omni 'let' é imutável -> const. Omni 'mut' -> let.
                let keyword = "let";
                format!("    {} {} = {};", keyword, name, self.gen_expression(value))
            }
            Statement::Assignment { target, value } => {
                format!("    {} = {};", self.gen_expression(target), self.gen_expression(value))
            }
            Statement::Return(opt_expr) => {
                if let Some(expr) = opt_expr {
                    format!("    return {};", self.gen_expression(expr))
                } else {
                    "    return;".to_string()
                }
            }
            Statement::Expression(expr) => {
                 format!("    {};", self.gen_expression(expr))
            }
            Statement::While { condition, body } => {
                let cond = self.gen_expression(condition);
                let body_code = self.gen_block(body);
                format!("    while ({}) {}", cond, body_code)
            }
            Statement::For { var, iterator, body } => {
                let iter = self.gen_expression(iterator);
                let body_code = self.gen_block(body);
                format!("    for (const {} of {}) {}", var, iter, body_code)
            }
            Statement::Break => "    break;".to_string(),
            Statement::Continue => "    continue;".to_string(),
            Statement::If { condition, then_branch, else_branch } => {
                let cond = self.gen_expression(condition);
                let then_code = self.gen_block(then_branch);
                let mut code = format!("    if ({}) {}", cond, then_code);
                
                if let Some(else_b) = else_branch {
                    code.push_str(" else ");
                    code.push_str(&self.gen_block(else_b));
                }
                code
            }
            Statement::NativeBlock { lang, code } => {
                if lang == "js" {
                    // Emit native code as raw text
                    // The native block content is extracted directly from source
                    // and should be emitted as-is
                    code.join("\n")
                } else {
                    String::new()
                }
            }
        }
    }

    /// Returns the precedence level of a binary operator (higher = binds tighter)
    fn operator_precedence(op: &BinaryOperator) -> u8 {
        match op {
            // Logical OR has lowest precedence
            BinaryOperator::LogicalOr => 1,
            // Logical AND has higher precedence than OR
            BinaryOperator::LogicalAnd => 2,
            // Comparison operators
            BinaryOperator::Equals | BinaryOperator::NotEquals |
            BinaryOperator::LessThan | BinaryOperator::GreaterThan |
            BinaryOperator::LessEquals | BinaryOperator::GreaterEquals => 3,
            // Additive operators
            BinaryOperator::Add | BinaryOperator::Subtract => 4,
            // Multiplicative operators (highest)
            BinaryOperator::Multiply | BinaryOperator::Divide => 5,
        }
    }

    /// Generates an expression, adding parentheses only when the child has lower precedence
    fn gen_expression_with_precedence(&self, expr: &Expression, parent_op: &BinaryOperator) -> String {
        match expr {
            Expression::BinaryOp { op: child_op, .. } => {
                let child_prec = Self::operator_precedence(child_op);
                let parent_prec = Self::operator_precedence(parent_op);
                
                // Add parens if child has lower precedence, or same precedence for OR (left-associative safety)
                if child_prec < parent_prec {
                    format!("({})", self.gen_expression(expr))
                } else {
                    self.gen_expression(expr)
                }
            }
            _ => self.gen_expression(expr)
        }
    }

    fn gen_expression(&self, expr: &Expression) -> String {
        match expr {
            Expression::Literal(l) => match l {
                Literal::String(s) => format!("\"{}\"", s.replace("\\", "\\\\").replace("\"", "\\\"").replace("\n", "\\n").replace("\r", "\\r")),
                Literal::Integer(i) => i.to_string(),
                Literal::Float(f) => f.to_string(),
                Literal::Bool(b) => b.to_string(),
            },
            Expression::Identifier(s) => s.clone(),
            Expression::Array(items) => {
                let inner = items.iter()
                    .map(|e| self.gen_expression(e))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("[{}]", inner)
            },
            Expression::Index { target, index } => {
                let t = self.gen_expression(target);
                let i = self.gen_expression(index);
                format!("{}[{}]", t, i)
            },
            Expression::BinaryOp { left, op, right } => {
                let l = self.gen_expression_with_precedence(left, op);
                let r = self.gen_expression_with_precedence(right, op);
                let op_str = match op {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equals => "===",
                    BinaryOperator::NotEquals => "!==",
                    BinaryOperator::LessThan => "<",
                    BinaryOperator::GreaterThan => ">",
                    BinaryOperator::LessEquals => "<=",
                    BinaryOperator::GreaterEquals => ">=",
                    BinaryOperator::LogicalAnd => "&&",
                    BinaryOperator::LogicalOr => "||",
                };
                format!("{} {} {}", l, op_str, r)
            },
            Expression::Call { function, args } => {
                let func_name = self.gen_expression(function);
                let args_str = args.iter()
                    .map(|a| self.gen_expression(a))
                    .collect::<Vec<_>>()
                    .join(", ");
                
                // Print removido (agora via std)
                if func_name == "String" {
                    return format!("String({})", args_str);
                }
                
                format!("{}({})", func_name, args_str)
            }
            Expression::StructInit { name, fields } => {
                // Struct instantiation: Token { kind: 1 } -> new Token({ kind: 1 })
                let fields_str = fields.iter()
                    .map(|f| format!("{}: {}", f.name, self.gen_expression(&f.value)))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("new {}({{ {} }})", name, fields_str)
            }
            Expression::MemberAccess { object, member } => {
                // Member access: obj.field -> obj.field
                format!("{}.{}", self.gen_expression(object), member)
            },
            Expression::ObjectLiteral(fields) => {
                let fields_str = fields.iter()
                    .map(|f| format!("{}: {}", f.name, self.gen_expression(&f.value)))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("{{ {} }}", fields_str)
            }
        }
    }
}
