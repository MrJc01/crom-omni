use crate::core::ast::*;
use crate::core::codegen::CodeGenerator;
use anyhow::Result;

/// Backend para JavaScript (ES6+)
pub struct JsBackend;

impl JsBackend {
    pub fn new() -> Self {
        Self
    }
}

impl CodeGenerator for JsBackend {
    fn generate(&self, program: &Program) -> Result<String> {
        let mut buffer = String::new();
        
        buffer.push_str("// Generated by Omni Compiler\n");
        buffer.push_str("'use strict';\n\n");

        // 1. Package / Imports
        // Omni: package com.foo; -> ignorado no JS simples ou vira namespace
        // Omni: import std; -> const std = require('std');
        for import in &program.imports {
             // Tratamento especial para std no futuro, por enquanto gera require simples
             let var_name = import.alias.clone().unwrap_or_else(|| {
                 // std/http -> http
                 import.path.split('/').last().unwrap_or(&import.path).to_string()
             });
             // Se for 'std', o JS nativo não precisa de require para coisas básicas como console.log, 
             // mas se fosse um módulo real:
             if import.path.starts_with("std") {
                 // Ignora imports da stdlib do Omni que são built-in no JS (como print/console)
                 // Ou mapeia para polyfills. Vamos ignorar std puro por enquanto.
             } else {
                buffer.push_str(&format!("const {} = require('{}');\n", var_name, import.path));
             }
        }
        buffer.push('\n');

        // 2. Items (Structs e Functions)
        for item in &program.items {
            match item {
                TopLevelItem::Struct(s) => {
                    buffer.push_str(&self.gen_struct(s));
                }
                TopLevelItem::Function(f) => {
                    buffer.push_str(&self.gen_function(f));
                }
            }
            buffer.push('\n');
        }

        // 3. Main Call? 
        // Se houver main, poderíamos chamar automaticamente. 
        // O Omni geralmente é compilado para ser executado, então se tiver main:
        if program.items.iter().any(|i| matches!(i, TopLevelItem::Function(f) if f.name == "main")) {
            buffer.push_str("\n// Entry Point\n");
            buffer.push_str("if (require.main === module) {\n");
             buffer.push_str("    main();\n");
            buffer.push_str("}\n");
        }

        Ok(buffer)
    }
}

impl JsBackend {
    fn gen_struct(&self, s: &StructDeclaration) -> String {
        // Omni struct -> JS Class data-only
        let mut code = format!("class {} {{\n", s.name);
        
        // Constructor para inicializar campos
        code.push_str("    constructor(data = {}) {\n");
        for field in &s.fields {
            // this.id = data.id;
            code.push_str(&format!("        this.{} = data.{};\n", field.name, field.name));
        }
        code.push_str("    }\n");
        code.push_str("}\n");
        code
    }

    fn gen_function(&self, f: &FunctionDeclaration) -> String {
        // fn nome(params) { ... } -> function nome(params) { ... }
        let params = f.params.iter()
            .map(|p| p.name.clone())
            .collect::<Vec<_>>()
            .join(", ");
        
        let header = format!("function {}({}) ", f.name, params);
        let body = self.gen_block(&f.body);
        
        format!("{}{}", header, body)
    }

    fn gen_block(&self, b: &Block) -> String {
        let mut code = String::from("{\n");
        for stmt in &b.statements {
            code.push_str(&self.gen_statement(stmt));
            code.push('\n');
        }
        code.push_str("}\n");
        code
    }

    fn gen_statement(&self, stmt: &Statement) -> String {
        match stmt {
            Statement::LetBinding { name, value, is_mut, .. } => {
                // JS usa let/const. Omni 'let' é imutável -> const. Omni 'mut' -> let.
                let keyword = if *is_mut { "let" } else { "const" };
                format!("    {} {} = {};", keyword, name, self.gen_expression(value))
            }
            Statement::Assignment { target, value } => {
                format!("    {} = {};", target, self.gen_expression(value))
            }
            Statement::Return(opt_expr) => {
                if let Some(expr) = opt_expr {
                    format!("    return {};", self.gen_expression(expr))
                } else {
                    "    return;".to_string()
                }
            }
            Statement::Expression(expr) => {
                 format!("    {};", self.gen_expression(expr))
            }
            Statement::If { condition, then_branch, else_branch } => {
                let cond = self.gen_expression(condition);
                let then_code = self.gen_block(then_branch);
                let mut code = format!("    if ({}) {}", cond, then_code);
                
                if let Some(else_b) = else_branch {
                    code.push_str(" else ");
                    code.push_str(&self.gen_block(else_b));
                }
                code
            }
        }
    }

    fn gen_expression(&self, expr: &Expression) -> String {
        match expr {
            Expression::Literal(l) => match l {
                Literal::String(s) => format!("\"{}\"", s), // TODO: Escape chars
                Literal::Integer(i) => i.to_string(),
                Literal::Float(f) => f.to_string(),
                Literal::Bool(b) => b.to_string(),
            },
            Expression::Identifier(s) => s.clone(),
            Expression::BinaryOp { left, op, right } => {
                let l = self.gen_expression(left);
                let r = self.gen_expression(right);
                let op_str = match op {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equals => "===",
                    BinaryOperator::NotEquals => "!==",
                };
                format!("({} {} {})", l, op_str, r)
            },
            Expression::Call { function, args } => {
                let func_name = self.gen_expression(function);
                let args_str = args.iter()
                    .map(|a| self.gen_expression(a))
                    .collect::<Vec<_>>()
                    .join(", ");
                
                // Mapeamento de STD (Polyfills básicos)
                if func_name == "print" {
                    return format!("console.log({})", args_str);
                }
                if func_name == "String" {
                    return format!("String({})", args_str);
                }
                
                format!("{}({})", func_name, args_str)
            }
        }
    }
}
