use crate::core::ast::*;
use crate::core::codegen::CodeGenerator;
use anyhow::Result;

/// Backend para JavaScript (ES6+)
pub struct JsBackend;

impl JsBackend {
    pub fn new() -> Self {
        Self
    }
}

impl CodeGenerator for JsBackend {
    fn generate(&self, program: &Program) -> Result<String> {
        let mut buffer = String::new();
        
        buffer.push_str("// Generated by Omni Compiler\n");
        buffer.push_str("'use strict';\n\n");

        // 1. Package / Imports
        // Omni: package com.foo; -> ignorado no JS simples ou vira namespace
        // Omni: import std; -> const std = require('std');
        for import in &program.imports {
             // Convert .omni extension to .js for requires
             let mut path = import.path.clone();
             if path.ends_with(".omni") {
                 path = path.replace(".omni", ".js");
             }
             
             // Extract variable name from path
             let var_name = import.alias.clone().unwrap_or_else(|| {
                 // std/http -> http, token.js -> token
                 let base = path.split('/').last().unwrap_or(&path);
                 base.trim_end_matches(".js").to_string()
             });
             
             // Handle std imports specially (built-in)
             if path.starts_with("std") {
                 // Ignora imports da stdlib do Omni que são built-in no JS
             } else {
                 // Ensure relative path starts with ./
                 let require_path = if !path.starts_with("./") && !path.starts_with("../") && !path.starts_with("/") {
                     format!("./{}", path)
                 } else {
                     path
                 };
                 buffer.push_str(&format!("const {} = require('{}');\n", var_name, require_path));
             }
        }
        buffer.push('\n');

        // 2. Items (Structs, Functions, and Let bindings)
        for item in &program.items {
            match item {
                TopLevelItem::Struct(s) => {
                    buffer.push_str(&self.gen_struct(s));
                }
                TopLevelItem::Function(f) => {
                    buffer.push_str(&self.gen_function(f));
                }
                TopLevelItem::LetBinding { name, value, is_mut, .. } => {
                    let keyword = if *is_mut { "let" } else { "const" };
                    buffer.push_str(&format!("{} {} = {};\n", keyword, name, self.gen_expression(value)));
                }
            }
            buffer.push('\n');
        }

        // 3. Main Call? 
        // Se houver main, poderíamos chamar automaticamente. 
        // O Omni geralmente é compilado para ser executado, então se tiver main:
        if program.items.iter().any(|i| matches!(i, TopLevelItem::Function(f) if f.name == "main")) {
            buffer.push_str("\n// Entry Point\n");
            buffer.push_str("if (require.main === module) {\n");
             buffer.push_str("    main();\n");
            buffer.push_str("}\n");
        }

        Ok(buffer)
    }
}

impl JsBackend {
    fn gen_struct(&self, s: &StructDeclaration) -> String {
        // Omni struct -> JS Class data-only
        let mut code = format!("class {} {{\n", s.name);
        
        // Constructor para inicializar campos
        code.push_str("    constructor(data = {}) {\n");
        for field in &s.fields {
            // this.id = data.id;
            code.push_str(&format!("        this.{} = data.{};\n", field.name, field.name));
        }
        code.push_str("    }\n");
        code.push_str("}\n");
        code
    }

    fn gen_function(&self, f: &FunctionDeclaration) -> String {
        // fn nome(params) { ... } -> function nome(params) { ... }
        let params = f.params.iter()
            .map(|p| p.name.clone())
            .collect::<Vec<_>>()
            .join(", ");
        
        let header = format!("function {}({}) ", f.name, params);
        let body = self.gen_block(&f.body);
        
        format!("{}{}", header, body)
    }

    fn gen_block(&self, b: &Block) -> String {
        let mut code = String::from("{\n");
        for stmt in &b.statements {
            code.push_str(&self.gen_statement(stmt));
            code.push('\n');
        }
        code.push_str("}\n");
        code
    }

    fn gen_statement(&self, stmt: &Statement) -> String {
        match stmt {
            Statement::LetBinding { name, value, is_mut, .. } => {
                // JS usa let/const. Omni 'let' é imutável -> const. Omni 'mut' -> let.
                let keyword = if *is_mut { "let" } else { "const" };
                format!("    {} {} = {};", keyword, name, self.gen_expression(value))
            }
            Statement::Assignment { target, value } => {
                format!("    {} = {};", self.gen_expression(target), self.gen_expression(value))
            }
            Statement::Return(opt_expr) => {
                if let Some(expr) = opt_expr {
                    format!("    return {};", self.gen_expression(expr))
                } else {
                    "    return;".to_string()
                }
            }
            Statement::Expression(expr) => {
                 format!("    {};", self.gen_expression(expr))
            }
            Statement::While { condition, body } => {
                let cond = self.gen_expression(condition);
                let body_code = self.gen_block(body);
                format!("    while ({}) {}", cond, body_code)
            }
            Statement::For { var, iterator, body } => {
                let iter = self.gen_expression(iterator);
                let body_code = self.gen_block(body);
                format!("    for (const {} of {}) {}", var, iter, body_code)
            }
            Statement::Break => "    break;".to_string(),
            Statement::Continue => "    continue;".to_string(),
            Statement::If { condition, then_branch, else_branch } => {
                let cond = self.gen_expression(condition);
                let then_code = self.gen_block(then_branch);
                let mut code = format!("    if ({}) {}", cond, then_code);
                
                if let Some(else_b) = else_branch {
                    code.push_str(" else ");
                    code.push_str(&self.gen_block(else_b));
                }
                code
            }
            Statement::NativeBlock { lang, code } => {
                if lang == "js" {
                    code.join("\n")
                } else {
                    String::new()
                }
            }
        }
    }

    fn gen_expression(&self, expr: &Expression) -> String {
        match expr {
            Expression::Literal(l) => match l {
                Literal::String(s) => format!("\"{}\"", s), // TODO: Escape chars
                Literal::Integer(i) => i.to_string(),
                Literal::Float(f) => f.to_string(),
                Literal::Bool(b) => b.to_string(),
            },
            Expression::Identifier(s) => s.clone(),
            Expression::Array(items) => {
                let inner = items.iter()
                    .map(|e| self.gen_expression(e))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("[{}]", inner)
            },
            Expression::Index { target, index } => {
                let t = self.gen_expression(target);
                let i = self.gen_expression(index);
                format!("{}[{}]", t, i)
            },
            Expression::BinaryOp { left, op, right } => {
                let l = self.gen_expression(left);
                let r = self.gen_expression(right);
                let op_str = match op {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equals => "===",
                    BinaryOperator::NotEquals => "!==",
                    BinaryOperator::LessThan => "<",
                    BinaryOperator::GreaterThan => ">",
                    BinaryOperator::LessEquals => "<=",
                    BinaryOperator::GreaterEquals => ">=",
                    BinaryOperator::LogicalAnd => "&&",
                    BinaryOperator::LogicalOr => "||",
                };
                format!("({} {} {})", l, op_str, r)
            },
            Expression::Call { function, args } => {
                let func_name = self.gen_expression(function);
                let args_str = args.iter()
                    .map(|a| self.gen_expression(a))
                    .collect::<Vec<_>>()
                    .join(", ");
                
                // Print removido (agora via std)
                if func_name == "String" {
                    return format!("String({})", args_str);
                }
                
                format!("{}({})", func_name, args_str)
            }
            Expression::StructInit { name, fields } => {
                // Struct instantiation: Token { kind: 1 } -> new Token({ kind: 1 })
                let fields_str = fields.iter()
                    .map(|f| format!("{}: {}", f.name, self.gen_expression(&f.value)))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("new {}({{ {} }})", name, fields_str)
            }
            Expression::MemberAccess { object, member } => {
                // Member access: obj.field -> obj.field
                format!("{}.{}", self.gen_expression(object), member)
            }
        }
    }
}
