use crate::core::ast::*;
use crate::core::codegen::CodeGenerator;
use anyhow::Result;

/// Backend para Python 3.x
/// A principal complexidade aqui é gerenciar a indentação obrigatória.
pub struct PythonBackend;

impl PythonBackend {
    pub fn new() -> Self {
        Self
    }
}

impl CodeGenerator for PythonBackend {
    fn generate(&self, program: &Program) -> Result<String> {
        let mut buffer = String::new();
        
        buffer.push_str("# Generated by Omni Compiler\n");
        buffer.push_str("import sys\n\n"); // Imports padrão úteis

        // 1. Package / Imports
        for import in &program.imports {
             // std/http -> import http
             let var_name = import.alias.clone().unwrap_or_else(|| {
                 import.path.split('/').last().unwrap_or(&import.path).to_string()
             });
             
             // Ignora std libs que mapeamos nativamente, se necessário
             if !import.path.starts_with("std") {
                buffer.push_str(&format!("import {}\n", var_name));
             }
        }
        buffer.push('\n');

        // 2. Items
        for item in &program.items {
            match item {
                TopLevelItem::Struct(s) => {
                    buffer.push_str(&self.gen_struct(s, 0));
                }
                TopLevelItem::Function(f) => {
                    buffer.push_str(&self.gen_function(f, 0));
                }
                TopLevelItem::Capsule(c) => {
                    // Capsule as a class with static methods
                    buffer.push_str(&format!("class {}:\n", c.name));
                    if c.items.is_empty() {
                        buffer.push_str("    pass\n");
                    } else {
                        for inner_item in &c.items {
                            match inner_item {
                                TopLevelItem::Function(f) => {
                                    buffer.push_str(&self.gen_function(f, 1));
                                }
                                _ => {}
                            }
                        }
                    }
                }
                TopLevelItem::Flow(fl) => {
                    // Flow as a regular function
                    buffer.push_str(&self.gen_flow(fl, 0));
                }
                TopLevelItem::LetBinding { name, value, .. } => {
                    // Python doesn't have const, just use variable assignment
                    buffer.push_str(&format!("{} = {}\n", name, self.gen_expression(value)));
                }
            }
            buffer.push('\n');
        }

        // 3. Entry Point
        // if __name__ == "__main__":
        //     main()
        if program.items.iter().any(|i| matches!(i, TopLevelItem::Function(f) if f.name == "main")) {
            buffer.push_str("\nif __name__ == \"__main__\":\n");
            buffer.push_str("    main()\n");
        }

        Ok(buffer)
    }
}

// Métodos Privados com Controle de Indentação
impl PythonBackend {
    fn indent(&self, level: usize) -> String {
        "    ".repeat(level)
    }

    fn gen_struct(&self, s: &StructDeclaration, indent: usize) -> String {
        let prefix = self.indent(indent);
        let mut code = format!("{}class {}:\n", prefix, s.name);
        
        // Constructor __init__
        let next_indent = indent + 1;
        let prefix_next = self.indent(next_indent);
        
        code.push_str(&format!("{}def __init__(self, data=None):\n", prefix_next));
        
        let prefix_body = self.indent(next_indent + 1);
        if s.fields.is_empty() {
            code.push_str(&format!("{}pass\n", prefix_body));
        } else {
            code.push_str(&format!("{}if data is None: data = {{}}\n", prefix_body));
            for field in &s.fields {
                code.push_str(&format!("{}self.{} = data.get('{}')\n", prefix_body, field.name, field.name));
            }
        }
        code
    }

    fn gen_function(&self, f: &FunctionDeclaration, indent: usize) -> String {
        let prefix = self.indent(indent);
        
        // Params
        let params = f.params.iter()
            .map(|p| p.name.clone())
            .collect::<Vec<_>>()
            .join(", ");
        
        let header = format!("{}def {}({}):\n", prefix, f.name, params);
        
        // Body (Block)
        // Python precisa de pelo menos uma linha. Se bloco vazio, 'pass'.
        let body = self.gen_block(&f.body, indent + 1);
        
        format!("{}{}", header, body)
    }

    fn gen_flow(&self, fl: &FlowDeclaration, indent: usize) -> String {
        let prefix = self.indent(indent);
        
        let params = fl.params.iter()
            .map(|p| p.name.clone())
            .collect::<Vec<_>>()
            .join(", ");
        
        let header = format!("{}def {}({}):\n", prefix, fl.name, params);
        let body = self.gen_block(&fl.body, indent + 1);
        
        format!("{}{}", header, body)
    }

    fn gen_block(&self, b: &Block, indent: usize) -> String {
        if b.statements.is_empty() {
            return format!("{}pass\n", self.indent(indent));
        }

        let mut code = String::new();
        for stmt in &b.statements {
            code.push_str(&self.gen_statement(stmt, indent));
            code.push('\n');
        }
        code
    }

    fn gen_statement(&self, stmt: &Statement, indent: usize) -> String {
        let prefix = self.indent(indent);
        match stmt {
            Statement::LetBinding { name, value, .. } => {
                // Em Python não tem let/const. Só nome = valor.
                // Tipo é dinâmico, ignorado no MVP.
                format!("{}{} = {}", prefix, name, self.gen_expression(value))
            }
            Statement::Assignment { target, value } => {
                format!("{}{} = {}", prefix, self.gen_expression(target), self.gen_expression(value))
            }
            Statement::Return(opt_expr) => {
                if let Some(expr) = opt_expr {
                    format!("{}return {}", prefix, self.gen_expression(expr))
                } else {
                    format!("{}return", prefix)
                }
            }
            Statement::While { condition, body } => {
                let cond = self.gen_expression(condition);
                let mut code = format!("{}while {}:\n", prefix, cond);
                code.push_str(&self.gen_block(body, indent + 1));
                code
            },
            Statement::For { var, iterator, body } => {
                let iter = self.gen_expression(iterator);
                let mut code = format!("{}for {} in {}:\n", prefix, var, iter);
                code.push_str(&self.gen_block(body, indent + 1));
                code
            },
            Statement::Break => format!("{}break", prefix),
            Statement::Continue => format!("{}continue", prefix),
            Statement::Expression(expr) => {
                 format!("{}{}", prefix, self.gen_expression(expr))
            }
            Statement::If { condition, then_branch, else_branch } => {
                let cond = self.gen_expression(condition);
                let mut code = format!("{}if {}:\n", prefix, cond);
                
                // Then block
                code.push_str(&self.gen_block(then_branch, indent + 1));
                
                // Else block
                if let Some(else_b) = else_branch {
                    code.push_str(&format!("{}else:\n", prefix));
                    code.push_str(&self.gen_block(else_b, indent + 1));
                }
                code.trim_end().to_string() 
            }
            Statement::NativeBlock { lang, code } => {
                // For Python, only output if lang is "python" or "py"
                if lang == "python" || lang == "py" {
                    let code_str = code.join("\n");
                    format!("{}{}", prefix, code_str.trim())
                } else {
                    format!("{}# native \"{}\" block not supported", prefix, lang)
                }
            }
        }
    }

    fn gen_expression(&self, expr: &Expression) -> String {
        match expr {
            Expression::Literal(l) => match l {
                Literal::String(s) => format!("\"{}\"", s.replace("\\", "\\\\").replace("\"", "\\\"").replace("\n", "\\n").replace("\r", "\\r")), 
                Literal::Integer(i) => i.to_string(),
                Literal::Float(f) => f.to_string(),
                Literal::Bool(b) => if *b { "True".to_string() } else { "False".to_string() }, 
            },
            Expression::Identifier(s) => s.clone(),
            Expression::Array(items) => {
                let inner = items.iter()
                    .map(|e| self.gen_expression(e))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("[{}]", inner)
            },
            Expression::Index { target, index } => {
                let t = self.gen_expression(target);
                let i = self.gen_expression(index);
                format!("{}[{}]", t, i)
            },
            Expression::BinaryOp { left, op, right } => {
                let l = self.gen_expression(left);
                let r = self.gen_expression(right);
                let op_str = match op {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equals => "==",
                    BinaryOperator::NotEquals => "!=",
                    BinaryOperator::LessThan => "<",
                    BinaryOperator::GreaterThan => ">",
                    BinaryOperator::LessEquals => "<=",
                    BinaryOperator::GreaterEquals => ">=",
                    BinaryOperator::LogicalAnd => "and",
                    BinaryOperator::LogicalOr => "or",
                };
                format!("({} {} {})", l, op_str, r)
            },
            Expression::Call { function, args } => {
                let func_name = self.gen_expression(function);
                let args_str = args.iter()
                    .map(|a| self.gen_expression(a))
                    .collect::<Vec<_>>()
                    .join(", ");
                
                if func_name == "print" {
                    return format!("print({})", args_str);
                }
                if func_name == "String" {
                    return format!("str({})", args_str); 
                }
                
                format!("{}({})", func_name, args_str)
            }
            Expression::StructInit { name, fields } => {
                // Struct instantiation: Token { kind: 1 } -> Token(kind=1)
                let fields_str = fields.iter()
                    .map(|f| format!("{}={}", f.name, self.gen_expression(&f.value)))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("{}({})", name, fields_str)
            }
            Expression::MemberAccess { object, member } => {
                // Member access: obj.field -> obj.field
                format!("{}.{}", self.gen_expression(object), member)
            },
            Expression::ObjectLiteral(fields) => {
                let fields_str = fields.iter()
                    .map(|f| format!("\"{}\": {}", f.name, self.gen_expression(&f.value)))
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("{{ {} }}", fields_str)
            }
        }
    }
}
