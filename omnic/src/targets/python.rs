use crate::core::ast::*;
use crate::core::codegen::CodeGenerator;
use anyhow::Result;

/// Backend para Python 3.x
/// A principal complexidade aqui é gerenciar a indentação obrigatória.
pub struct PythonBackend;

impl PythonBackend {
    pub fn new() -> Self {
        Self
    }
}

impl CodeGenerator for PythonBackend {
    fn generate(&self, program: &Program) -> Result<String> {
        let mut buffer = String::new();
        
        buffer.push_str("# Generated by Omni Compiler\n");
        buffer.push_str("import sys\n\n"); // Imports padrão úteis

        // 1. Package / Imports
        for import in &program.imports {
             // std/http -> import http
             let var_name = import.alias.clone().unwrap_or_else(|| {
                 import.path.split('/').last().unwrap_or(&import.path).to_string()
             });
             
             // Ignora std libs que mapeamos nativamente, se necessário
             if !import.path.starts_with("std") {
                buffer.push_str(&format!("import {}\n", var_name));
             }
        }
        buffer.push('\n');

        // 2. Items
        for item in &program.items {
            match item {
                TopLevelItem::Struct(s) => {
                    buffer.push_str(&self.gen_struct(s, 0));
                }
                TopLevelItem::Function(f) => {
                    buffer.push_str(&self.gen_function(f, 0));
                }
            }
            buffer.push('\n');
        }

        // 3. Entry Point
        // if __name__ == "__main__":
        //     main()
        if program.items.iter().any(|i| matches!(i, TopLevelItem::Function(f) if f.name == "main")) {
            buffer.push_str("\nif __name__ == \"__main__\":\n");
            buffer.push_str("    main()\n");
        }

        Ok(buffer)
    }
}

// Métodos Privados com Controle de Indentação
impl PythonBackend {
    fn indent(&self, level: usize) -> String {
        "    ".repeat(level)
    }

    fn gen_struct(&self, s: &StructDeclaration, indent: usize) -> String {
        let prefix = self.indent(indent);
        let mut code = format!("{}class {}:\n", prefix, s.name);
        
        // Constructor __init__
        let next_indent = indent + 1;
        let prefix_next = self.indent(next_indent);
        
        code.push_str(&format!("{}def __init__(self, data=None):\n", prefix_next));
        
        let prefix_body = self.indent(next_indent + 1);
        if s.fields.is_empty() {
            code.push_str(&format!("{}pass\n", prefix_body));
        } else {
            code.push_str(&format!("{}if data is None: data = {{}}\n", prefix_body));
            for field in &s.fields {
                code.push_str(&format!("{}self.{} = data.get('{}')\n", prefix_body, field.name, field.name));
            }
        }
        code
    }

    fn gen_function(&self, f: &FunctionDeclaration, indent: usize) -> String {
        let prefix = self.indent(indent);
        
        // Params
        let params = f.params.iter()
            .map(|p| p.name.clone())
            .collect::<Vec<_>>()
            .join(", ");
        
        let header = format!("{}def {}({}):\n", prefix, f.name, params);
        
        // Body (Block)
        // Python precisa de pelo menos uma linha. Se bloco vazio, 'pass'.
        let body = self.gen_block(&f.body, indent + 1);
        
        format!("{}{}", header, body)
    }

    fn gen_block(&self, b: &Block, indent: usize) -> String {
        if b.statements.is_empty() {
            return format!("{}pass\n", self.indent(indent));
        }

        let mut code = String::new();
        for stmt in &b.statements {
            code.push_str(&self.gen_statement(stmt, indent));
            code.push('\n');
        }
        code
    }

    fn gen_statement(&self, stmt: &Statement, indent: usize) -> String {
        let prefix = self.indent(indent);
        match stmt {
            Statement::LetBinding { name, value, .. } => {
                // Em Python não tem let/const. Só nome = valor.
                // Tipo é dinâmico, ignorado no MVP.
                format!("{}{} = {}", prefix, name, self.gen_expression(value))
            }
            Statement::Assignment { target, value } => {
                format!("{}{} = {}", prefix, target, self.gen_expression(value))
            }
            Statement::Return(opt_expr) => {
                if let Some(expr) = opt_expr {
                    format!("{}return {}", prefix, self.gen_expression(expr))
                } else {
                    format!("{}return", prefix)
                }
            }
            Statement::Expression(expr) => {
                 format!("{}{}", prefix, self.gen_expression(expr))
            }
            Statement::If { condition, then_branch, else_branch } => {
                let cond = self.gen_expression(condition);
                let mut code = format!("{}if {}:\n", prefix, cond);
                
                // Then block
                code.push_str(&self.gen_block(then_branch, indent + 1));
                
                // Else block
                if let Some(else_b) = else_branch {
                    code.push_str(&format!("{}else:\n", prefix));
                    code.push_str(&self.gen_block(else_b, indent + 1));
                }
                code.trim_end().to_string() // Remove newline extra pra não ficar buraco
            }
        }
    }

    fn gen_expression(&self, expr: &Expression) -> String {
        match expr {
            Expression::Literal(l) => match l {
                Literal::String(s) => format!("\"{}\"", s), 
                Literal::Integer(i) => i.to_string(),
                Literal::Float(f) => f.to_string(),
                Literal::Bool(b) => if *b { "True".to_string() } else { "False".to_string() }, // Python True/False
            },
            Expression::Identifier(s) => s.clone(),
            Expression::BinaryOp { left, op, right } => {
                let l = self.gen_expression(left);
                let r = self.gen_expression(right);
                let op_str = match op {
                    BinaryOperator::Add => "+",
                    BinaryOperator::Subtract => "-",
                    BinaryOperator::Multiply => "*",
                    BinaryOperator::Divide => "/",
                    BinaryOperator::Equals => "==",
                    BinaryOperator::NotEquals => "!=",
                };
                format!("({} {} {})", l, op_str, r)
            },
            Expression::Call { function, args } => {
                let func_name = self.gen_expression(function);
                let args_str = args.iter()
                    .map(|a| self.gen_expression(a))
                    .collect::<Vec<_>>()
                    .join(", ");
                
                // Mapeamento STD
                if func_name == "print" {
                    // Python print é igual, mas 'console.log' era JS.
                    return format!("print({})", args_str);
                }
                if func_name == "String" {
                    return format!("str({})", args_str); // JS String -> Python str
                }
                
                format!("{}({})", func_name, args_str)
            }
        }
    }
}
