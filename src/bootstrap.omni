capsule Bootstrap {
    // This file will eventually become the Omni compiler written in Omni.
    // Task 04.4: Compiler-in-compiler

    // --- AST Definitions ---
    struct Program {
        statements: List<Statement>,
        functions: List<FunctionDecl>,
        structs: List<StructDecl>
    }

    flow parse(tokens: List<Token>) -> Program {
        let p = Parser { tokens: tokens, current: 0 };
        let stmts: List<Statement> = [];
        let funcs: List<FunctionDecl> = [];
        let structs: List<StructDecl> = [];
        
        while (p.current < std.list.len(p.tokens)) {
            // Check for Top Level Items
            let t = peek(p);
            if (t.lexeme == "flow" || t.lexeme == "fn") {
                funcs.push(parse_function(p)); 
            } else if (t.lexeme == "struct") {
                structs.push(parse_struct(p));
            } else {
                 stmts.push(parse_statement(p));
            }
        }

        return Program { statements: stmts, functions: funcs, structs: structs };
    }

    flow parse_struct(p: Parser) -> StructDecl {
        advance(p); // 'struct'
        let name = advance(p).lexeme;
        advance(p); // '{'
        let fields: List<Param> = [];
        while (peek(p).lexeme != "}") {
            let fname = advance(p).lexeme;
            advance(p); // ':'
            let fty = advance(p).lexeme;
            // optional comma?
            if (peek(p).lexeme == ",") { advance(p); } 
            // In strict parser maybe check newline or comma
            fields.push(Param { name: fname, ty: fty });
        }
        advance(p); // '}'
        return StructDecl { name: name, fields: fields };
    }

    flow parse_block(p: Parser) -> List<Statement> {
        advance(p); // eat '{'
        let stmts: List<Statement> = [];
        while (peek(p).lexeme != "}") {
            stmts.push(parse_statement(p));
        }
        advance(p); // eat '}'
        return stmts;
    }

    flow parse_function(p: Parser) -> FunctionDecl {
        // flow/fn name(params) { body }
        let keyword = advance(p); // eat 'flow'/'fn'
        let name = advance(p).lexeme;
        
        advance(p); // eat '('
        let params: List<Param> = [];
        // TODO: Parse params
        while (peek(p).lexeme != ")") {
             // Dumb skip params for now
             advance(p);
        }
        advance(p); // eat ')'
        
        // Optional return type skipping -> List<Token>
        if (peek(p).lexeme == "-") {
            advance(p); // -
            advance(p); // >
            advance(p); // Type
        }

        let body = parse_block(p);
        
        return FunctionDecl { name: name, params: params, body: body };
    }

    flow parse_statement(p: Parser) -> Statement {
        let t = peek(p);
        
        // let x = ...
        if (t.lexeme == "let") {
            advance(p); // eat 'let'
            let name = advance(p).lexeme;
            advance(p); // eat '='
            let val = parse_expression(p);
            advance(p); // eat ';'
            return Statement { kind: "Let", name: name, value: val };
        }
        
        if (t.lexeme == "return") {
            advance(p); // eat 'return'
            let val = parse_expression(p); // TODO: check parsing optional expr
            advance(p); // eat ';'
            return Statement { kind: "Return", name: "", value: val };
        }

        if (t.lexeme == "if") {
            advance(p); // eat 'if'
            advance(p); // eat '('
            let cond = parse_expression(p);
            advance(p); // eat ')'
            let body = parse_block(p);
            // TODO: else
            // Return Statement... struct needs to hold block? 
            // Simplified: return Let for now to satisfy type checker or make Statement recursive
            // Note: Statement struct defined as {kind, name, value: Expression}. It can't hold list of statements easily unless we change Struct.
            // For bootstrap v0.1 simplification, we might skip full AST tree for if/while statements or hack it.
            return Statement { kind: "IfStub", name: "if", value: cond };
        }
        
        if (t.lexeme == "native") {
             advance(p); // 'native'
             let lang = advance(p).lexeme; // "js"
             advance(p); // '{'
             // Skip until '}'
             while (peek(p).lexeme != "}") { advance(p); }
             advance(p); // '}'
             return Statement { kind: "NativeStub", name: lang, value: Expression { kind: "Native", value: "", left: null, right: null, op: "" } };
        }

        // Default: Expression Statement
        let expr = parse_expression(p);
        advance(p); // eat ';'
        return Statement { kind: "Expr", name: "", value: expr };
    }

    flow parse_expression(p: Parser) -> Expression {
        let t = advance(p);
        if (t.kind == "IntegerLiteral") {
            return Expression { kind: "Literal", value: t.lexeme, left: null, right: null, op: "" };
        }
        if (t.kind == "Identifier") {
            return Expression { kind: "Identifier", value: t.lexeme, left: null, right: null, op: "" };
        }
        return Expression { kind: "Unknown", value: "", left: null, right: null, op: "" };
    }

    // --- Helper Flows ---

    flow peek(p: Parser) -> Token {
        // Safe access needed
        native "js" { return p.tokens[p.current]; }
    }

    flow advance(p: Parser) -> Token {
        let t = peek(p);
        p.current = p.current + 1;
        return t;
    }

    flow lex(source: string) -> List<Token> {
        let tokens: List<Token> = [];
        // ... (Lexer implementation needs update to be more robust)
        native "js" {
            // Simplified Lexer for Bootstrapping
            let i = 0;
            while (i < source.length) {
                let c = source[i];
                if (c === ' ' || c === '\n') { i++; continue; }
                
                if (c === 'l' && source.substr(i, 3) === 'let') {
                    tokens.push({ kind: "Keyword", lexeme: "let", line: 1 });
                    i += 3; continue;
                }
                
                let t = "";
                if (c === '{') t = "{";
                if (c === '}') t = "}";
                if (c === '(') t = "(";
                if (c === ')') t = ")";
                if (c === ':') t = ":";
                if (c === ',') t = ",";
                
                if (t !== "") {
                   tokens.push({ kind: "Symbol", lexeme: t, line: 1 });
                   i++; continue;
                }

                if (c === '=') {
                   tokens.push({ kind: "Symbol", lexeme: "=", line: 1 });
                   i++; continue;
                }
                
                if (c === ';') {
                   tokens.push({ kind: "Symbol", lexeme: ";", line: 1 });
                   i++; continue;
                }

                if (c === '"') {
                    let str = "";
                    i++; // skip open quote
                    while (i < source.length && source[i] !== '"') {
                        str += source[i];
                        i++;
                    }
                    i++; // skip close quote
                    tokens.push({ kind: "StringLiteral", lexeme: str, line: 1 });
                    continue;
                }

                if (c.match(/[0-9]/)) {
                    let num = "";
                    while (i < source.length && source[i].match(/[0-9]/)) {
                        num += source[i];
                        i++;
                    }
                    tokens.push({ kind: "IntegerLiteral", lexeme: num, line: 1 });
                    continue;
                }
                
                if (c.match(/[a-z]/)) {
                    let id = "";
                    while (i < source.length && source[i].match(/[a-z]/)) {
                        id += source[i];
                        i++;
                    }
                    tokens.push({ kind: "Identifier", lexeme: id, line: 1 });
                    continue;
                }
                i++;
            }
        }
        return tokens;
    }

    flow main() {
        io.print("Omni Self-Hosting Bootstrap v0.1");
        let source = "struct Point { x: int } flow test() { let z = 10; if (z) { return z; } native \"js\" { console.log(z); } }";
        let tokens = lex(source);
        io.print("Lexing complete: " + tokens.len());
        
        let prog = parse(tokens);
        io.print("Parsing complete.");
    }
}
