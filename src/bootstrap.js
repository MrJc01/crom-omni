// Generated by Omni Compiler
'use strict';


function print(msg) {
console.log(msg);

}

// Capsule: Bootstrap
const Bootstrap = {};

Bootstrap.Program = class Program {
    constructor(data = {}) {
        this.statements = data.statements;
        this.functions = data.functions;
        this.structs = data.structs;
    }
}
Bootstrap.parse = function(tokens) {
    let p = new Parser({ tokens: tokens, current: 0 });
    let stmts = [];
    let funcs = [];
    let structs = [];
    while (p.current < std.list.len(p.tokens)) {
    let t = peek(p);
    if (t.lexeme === "flow" || t.lexeme === "fn") {
    funcs.push(parse_function(p));
}
 else {
    if (t.lexeme === "struct") {
    structs.push(parse_struct(p));
}
 else {
    stmts.push(parse_statement(p));
}

}

}

    return new Program({ statements: stmts, functions: funcs, structs: structs });
}
;
Bootstrap.parse_struct = function(p) {
    advance(p);
    let name = advance(p).lexeme;
    advance(p);
    let fields = [];
    while (peek(p).lexeme !== "}") {
    let fname = advance(p).lexeme;
    advance(p);
    let fty = advance(p).lexeme;
    if (peek(p).lexeme === ",") {
    advance(p);
}

    fields.push(new Param({ name: fname, ty: fty }));
}

    advance(p);
    return new StructDecl({ name: name, fields: fields });
}
;
Bootstrap.parse_block = function(p) {
    advance(p);
    let stmts = [];
    while (peek(p).lexeme !== "}") {
    stmts.push(parse_statement(p));
}

    advance(p);
    return stmts;
}
;
Bootstrap.parse_function = function(p) {
    let keyword = advance(p);
    let name = advance(p).lexeme;
    advance(p);
    let params = [];
    while (peek(p).lexeme !== ")") {
    advance(p);
}

    advance(p);
    if (peek(p).lexeme === "-") {
    advance(p);
    advance(p);
    advance(p);
}

    let body = parse_block(p);
    return new FunctionDecl({ name: name, params: params, body: body });
}
;
Bootstrap.parse_statement = function(p) {
    let t = peek(p);
    if (t.lexeme === "let") {
    advance(p);
    let name = advance(p).lexeme;
    advance(p);
    let val = parse_expression(p);
    advance(p);
    return new Statement({ kind: "Let", name: name, value: val });
}

    if (t.lexeme === "return") {
    advance(p);
    let val = parse_expression(p);
    advance(p);
    return new Statement({ kind: "Return", name: "", value: val });
}

    if (t.lexeme === "if") {
    advance(p);
    advance(p);
    let cond = parse_expression(p);
    advance(p);
    let body = parse_block(p);
    return new Statement({ kind: "IfStub", name: "if", value: cond });
}

    if (t.lexeme === "native") {
    advance(p);
    let lang = advance(p).lexeme;
    advance(p);
    while (peek(p).lexeme !== "}") {
    advance(p);
}

    advance(p);
    return new Statement({ kind: "NativeStub", name: lang, value: new Expression({ kind: "Native", value: "", left: null, right: null, op: "" }) });
}

    let expr = parse_expression(p);
    advance(p);
    return new Statement({ kind: "Expr", name: "", value: expr });
}
;
Bootstrap.parse_expression = function(p) {
    let t = advance(p);
    if (t.kind === "IntegerLiteral") {
    return new Expression({ kind: "Literal", value: t.lexeme, left: null, right: null, op: "" });
}

    if (t.kind === "Identifier") {
    return new Expression({ kind: "Identifier", value: t.lexeme, left: null, right: null, op: "" });
}

    return new Expression({ kind: "Unknown", value: "", left: null, right: null, op: "" });
}
;
Bootstrap.peek = function(p) {
return p.tokens[p.current];
}
;
Bootstrap.advance = function(p) {
    let t = peek(p);
    p.current = p.current + 1;
    return t;
}
;
Bootstrap.lex = function(source) {
    let tokens = [];
let i = 0;
            while (i < source.length) {
                let c = source[i];
                if (c === ' ' || c === '\n') { i++; continue; }
                
                if (c === 'l' && source.substr(i, 3) === 'let') {
                    tokens.push({ kind: "Keyword", lexeme: "let", line: 1 });
                    i += 3; continue;
                }
                
                let t = "";
                if (c === '{') t = "{";
                if (c === '}') t = "}";
                if (c === '(') t = "(";
                if (c === ')') t = ")";
                if (c === ':') t = ":";
                if (c === ',') t = ",";
                
                if (t !== "") {
                   tokens.push({ kind: "Symbol", lexeme: t, line: 1 });
                   i++; continue;
                }

                if (c === '=') {
                   tokens.push({ kind: "Symbol", lexeme: "=", line: 1 });
                   i++; continue;
                }
                
                if (c === ';') {
                   tokens.push({ kind: "Symbol", lexeme: ";", line: 1 });
                   i++; continue;
                }

                if (c === '"') {
                    let str = "";
                    i++; // skip open quote
                    while (i < source.length && source[i] !== '"') {
                        str += source[i];
                        i++;
                    }
                    i++; // skip close quote
                    tokens.push({ kind: "StringLiteral", lexeme: str, line: 1 });
                    continue;
                }

                if (c.match(/[0-9]/)) {
                    let num = "";
                    while (i < source.length && source[i].match(/[0-9]/)) {
                        num += source[i];
                        i++;
                    }
                    tokens.push({ kind: "IntegerLiteral", lexeme: num, line: 1 });
                    continue;
                }
                
                if (c.match(/[a-z]/)) {
                    let id = "";
                    while (i < source.length && source[i].match(/[a-z]/)) {
                        id += source[i];
                        i++;
                    }
                    tokens.push({ kind: "Identifier", lexeme: id, line: 1 });
                    continue;
                }
                i++;
            }
    return tokens;
}
;
Bootstrap.main = function() {
    io.print("Omni Self-Hosting Bootstrap v0.1");
    let source = "struct Point { x: int } flow test() { let z = 10; if (z) { return z; } native \\\"js\\\" { console.log(z); } }";
    let tokens = lex(source);
    io.print("Lexing complete: " + tokens.len());
    let prog = parse(tokens);
    io.print("Parsing complete.");
}
;


